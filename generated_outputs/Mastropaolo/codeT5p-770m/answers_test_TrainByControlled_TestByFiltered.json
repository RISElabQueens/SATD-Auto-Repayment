{"4039": "@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nif (mDisk == null) {\nfinish();\nreturn;\n}\nsetContentView(R.layout.storage_wizard_generic);\nmFormatPrivate = getIntent().getBooleanExtra(EXTRA_FORMAT_PRIVATE, false);\nif (mFormatPrivate) {\nsetHeaderText(R.string.storage_wizard_format_confirm_title);\nsetBodyText(R.string.storage_wizard_format_confirm_body,\n                    mDisk.getDescription());\n} else {\nsetHeaderText(R.string.storage_wizard_format_confirm_public_title);\nsetBodyText(R.string.storage_wizard_format_confirm_public_body,\n                    mDisk.getDescription());\n}\ngetNextButton().setText(R.string.storage_wizard_format_confirm_next);\n}", "4040": "public void invokeWithJavaArgs(Object[] args) throws Throwable {\nIokeObject msg = ioke.newMessage(\"invoke\");\nMessage invoke = (Message) IokeObject.data(msg);\nList<Runtime.RescueInfo> pendingRescues = new ArrayList<Runtime.RescueInfo>();\nIokeObject rr = IokeObject.as(((Message)IokeObject.data(ioke.mimic)).sendTo(ioke.mimic, ioke.ground, ioke.rescue), ioke.ground);\nList<Object> conds = new ArrayList();\nfinal IokeObject pendingCondition = IokeObject.as(IokeObject.getCellChain(ioke.condition,\n                                                                                  ioke.message,\n                                                                                  ioke.ground,\n                                                                                  \"Pending\"), ioke.ground);\nconds.add(pendingCondition);\npendingRescues.add(new Runtime.RescueInfo(rr, conds, pendingRescues, ioke.getBindIndex()));\nioke.registerRescues(pendingRescues);\ntry {\ninvoke.sendTo(msg, iokeStepDefObject, iokeStepDefObject, multilineArg(args));\n} catch(ControlFlow.Rescue e) {\nif(e.getRescue().token == pendingRescues) {\nthrow JRuby.cucumberPending(\"TODO\");\n//                throw (Exception)(e.getCondition().getCell(ioke.message, ioke.ground, \"rootException\"));\n} else {\nthrow e;\n}\n} finally {\nioke.unregisterRescues(pendingRescues);\n}\n}", "4041": "public void mark() {\nposition.mark();\n}", "4042": "private static StringBuilder ioListToStringBuilder(final OtpErlangObject o,\n            final StringBuilder sb0, final int maxLength) {\nStringBuilder sb = sb0;\nif (sb.length() >= maxLength) {\nreturn sb;\n}\nif (o instanceof OtpErlangLong) {\nfinal OtpErlangLong l = (OtpErlangLong) o;\ntry {\nsb.append(l.charValue());\n} catch (final OtpErlangRangeException e) {\n}\n} else if (o instanceof OtpErlangString) {\nfinal OtpErlangString s = (OtpErlangString) o;\nsb.append(s.stringValue());\n} else if (o instanceof OtpErlangList) {\nfinal OtpErlangList l = (OtpErlangList) o;\nfor (final OtpErlangObject i : l) {\nif (sb.length() < maxLength) {\nioListToStringBuilder(i, sb, maxLength);\n}\n}\nif (sb.length() < maxLength) {\nioListToStringBuilder(l.getLastTail(), sb, maxLength);\n}\n} else if (o instanceof OtpErlangBinary) {\nfinal OtpErlangBinary b = (OtpErlangBinary) o;\nfinal String s = new String(b.binaryValue(), Charsets.ISO_8859_1);\nsb.append(s);\n} else if (o!= null) {\nsb.append(o.toString());\n}\nif (sb.length() > maxLength) {\nsb = new StringBuilder(sb.substring(0, maxLength));\nsb.append(\"... <truncated>\");\n}\nreturn sb;\n}", "4046": "@Override public void handle(AnnotationValues<Getter> annotation, JCAnnotation ast, JavacAST.Node annotationNode) {\nGetter getter = annotation.getInstance();\nJCClassDecl javacClassTree = (JCClassDecl) annotationNode.up().up().get();\nint access = toJavacModifier(getter.value());\nJCMethodDecl getterMethod = createGetter(access, annotationNode.up(), annotationNode.getTreeMaker());\njavacClassTree.defs = javacClassTree.defs.append(getterMethod);\n}", "4052": "@Test\npublic void testFailedStepRestarted() throws Exception {\nSimpleFlow flow = new SimpleFlow(\"job\");\nList<StateTransition> transitions = new ArrayList<StateTransition>();\ntransitions.add(StateTransition.createStateTransition(new StepState(new StepSupport(\"step1\") {\n\t\t\t@Override\npublic void execute(StepExecution stepExecution) throws JobInterruptedException,\n\t\t\t\t\tUnexpectedJobExecutionException {\nstepExecution.setStatus(BatchStatus.FAILED);\nstepExecution.setExitStatus(ExitStatus.FAILED);\njobRepository.update(stepExecution);\n}\n\t\t}), \"step2\"));\ntransitions.add(StateTransition.createEndStateTransition(new StepState(new StubStep(\"step2\") {\n\t\t\t@Override\npublic void execute(StepExecution stepExecution) throws JobInterruptedException,\n\t\t\t\t\tUnexpectedJobExecutionException {\nif (fail) {\nstepExecution.setStatus(BatchStatus.FAILED);\nstepExecution.setExitStatus(ExitStatus.FAILED);\njobRepository.update(stepExecution);\n} else {\nsuper.execute(stepExecution);\n}\n}\n\t\t})));\nflow.setStateTransitions(transitions);\njob.setFlow(flow);\njob.afterPropertiesSet();\nfail = true;\njob.execute(jobExecution);\nassertEquals(ExitStatus.FAILED, jobExecution.getExitStatus());\nassertEquals(2, jobExecution.getStepExecutions().size());\njobRepository.update(jobExecution);\njobExecution = jobRepository.createJobExecution(\"job\", new JobParameters());\nfail = false;\njob.execute(jobExecution);\nassertEquals(ExitStatus.COMPLETED, jobExecution.getExitStatus());\nassertEquals(1, jobExecution.getStepExecutions().size());\n}", "4058": "@Override\npublic void onCreate(Bundle icicle) {\nsuper.onCreate(icicle);\nsetInputMethodSettingsCategoryTitle(R.string.language_selection_title);\nsetSubtypeEnablerTitle(R.string.select_language);\naddPreferencesFromResource(R.xml.prefs);\nfinal Resources res = getResources();\nfinal Context context = getActivity();\nmVoicePreference = (ListPreference) findPreference(PREF_VOICE_MODE);\nmShowCorrectionSuggestionsPreference =\n(ListPreference) findPreference(PREF_SHOW_SUGGESTIONS_SETTING);\nSharedPreferences prefs = getPreferenceManager().getSharedPreferences();\nprefs.registerOnSharedPreferenceChangeListener(this);\nmAutoCorrectionThresholdPreference =\n(ListPreference) findPreference(PREF_AUTO_CORRECTION_THRESHOLD);\nmBigramSuggestion = (CheckBoxPreference) findPreference(PREF_BIGRAM_SUGGESTION);\nmBigramPrediction = (CheckBoxPreference) findPreference(PREF_BIGRAM_PREDICTIONS);\nmDebugSettingsPreference = findPreference(PREF_DEBUG_SETTINGS);\nif (mDebugSettingsPreference!= null) {\nfinal Intent debugSettingsIntent = new Intent(Intent.ACTION_MAIN);\ndebugSettingsIntent.setClassName(\n                    context.getPackageName(), DebugSettings.class.getName());\nmDebugSettingsPreference.setIntent(debugSettingsIntent);\n}\nensureConsistencyOfAutoCorrectionSettings();\nfinal PreferenceGroup generalSettings =\n                (PreferenceGroup) findPreference(PREF_GENERAL_SETTINGS);\nfinal PreferenceGroup textCorrectionGroup =\n                (PreferenceGroup) findPreference(PREF_CORRECTION_SETTINGS);\nfinal PreferenceGroup miscSettings =\n                (PreferenceGroup) findPreference(PREF_MISC_SETTINGS);\nfinal boolean showVoiceKeyOption = res.getBoolean(\n                R.bool.config_enable_show_voice_key_option);\nif (!showVoiceKeyOption) {\ngeneralSettings.removePreference(mVoicePreference);\n}\nfinal PreferenceGroup advancedSettings =\n                (PreferenceGroup) findPreference(PREF_ADVANCED_SETTINGS);\n// Remove those meaningless options for now. TODO: delete them for good\nadvancedSettings.removePreference(findPreference(PREF_BIGRAM_SUGGESTION));\nadvancedSettings.removePreference(findPreference(PREF_KEY_ENABLE_SPAN_INSERT));\nif (!VibratorUtils.getInstance(context).hasVibrator()) {\ngeneralSettings.removePreference(findPreference(PREF_VIBRATE_ON));\nif (null!= advancedSettings) { // Theoretically advancedSettings cannot be null\nadvancedSettings.removePreference(findPreference(PREF_VIBRATION_DURATION_SETTINGS));\n}\n}\nfinal boolean showPopupOption = res.getBoolean(\n                R.bool.config_enable_show_popup_on_keypress_option);\nif (!showPopupOption) {\ngeneralSettings.removePreference(findPreference(PREF_POPUP_ON));\n}\nfinal boolean showBigramSuggestionsOption = res.getBoolean(\n                R.bool.config_enable_next_word_suggestions_option);\nif (!showBigramSuggestionsOption) {\ntextCorrectionGroup.removePreference(mBigramSuggestion);\nif (null!= mBigramPrediction) {\ntextCorrectionGroup.removePreference(mBigramPrediction);\n}\n}\nfinal CheckBoxPreference includeOtherImesInLanguageSwitchList =\n                (CheckBoxPreference)findPreference(PREF_INCLUDE_OTHER_IMES_IN_LANGUAGE_SWITCH_LIST);\nincludeOtherImesInLanguageSwitchList.setEnabled(\n               !SettingsValues.isLanguageSwitchKeySupressed(prefs));\nmKeyPreviewPopupDismissDelay =\n(ListPreference)findPreference(PREF_KEY_PREVIEW_POPUP_DISMISS_DELAY);\nfinal String[] entries = new String[] {\n                res.getString(R.string.key_preview_popup_dismiss_no_delay),\n                res.getString(R.string.key_preview_popup_dismiss_default_delay),\n        };\nfinal String popupDismissDelayDefaultValue = Integer.toString(res.getInteger(\n                R.integer.config_key_preview_linger_timeout));\nmKeyPreviewPopupDismissDelay.setEntries(entries);\nmKeyPreviewPopupDismissDelay.setEntryValues(\n                new String[] { \"0\", popupDismissDelayDefaultValue });\nif (null == mKeyPreviewPopupDismissDelay.getValue()) {", "4067": "private void setOutputProductsGridContent(final ViewDefinitionState viewDefinitionState, final Entity order) {\nGridComponent outputProducts = (GridComponent) viewDefinitionState.getComponentByReference(\"outputProductsGrid\");\nList<Entity> outputProductsList = new ArrayList<Entity>();\nfor (Entity productionRecord : order.getHasManyField(\"productionRecords\")) {\noutputProductsList.addAll(productionRecord.getHasManyField(\"recordOperationProductOutComponents\"));\n}\nCollections.sort(outputProductsList, new EntityProductInOutComparator());\noutputProducts.setEntities(outputProductsList);\noutputProducts.setVisible(true);\noutputProducts.setGroupByAnki(true);\n}", "4070": "@Override\npublic void processResult(int i, String s, Object o, String s1) {\nKeeperException.Code returnCode =  KeeperException.Code.get(i);\nZkLocalStatusAndEndpoints statusAndEndpoints =  (ZkLocalStatusAndEndpoints) o;\nlog.info(\"Claim callback \" + returnCode.name() + \" \" + s);\nswitch (returnCode) {\ncase OK:\nsynchronized (this) {\nstorage = Storage.DIRTY;\n}\ntry {\nstatusAndEndpoints.writeStatusEndpoint();\nsynchronized (statusAndEndpoints) {\nstatusAndEndpoints.storage = Storage.SYNCED;\n}\n} catch (CoordinateMissingException e) {\nlog.info(\"Problems writing config, coordinate missing\");\nstatusAndEndpoints.updateCoordinateListenersAndTakeAction(\n                                CoordinateListener.Event.NOT_OWNER,\n                                \"Can not write config: \" + returnCode.name() + \" \" + s);\nbreak;\n} catch (CloudnameException e) {\nlog.info(\"Problems writing config.\" + e.getMessage());\nstatusAndEndpoints.updateCoordinateListenersAndTakeAction(\n                                    CoordinateListener.Event.LOST_CONNECTION_TO_STORAGE,\n                                    \"Can not write config after claim: \" + returnCode.name() + \" \" + s);\nbreak;\n}\nstatusAndEndpoints.updateCoordinateListenersAndTakeAction(\n                            CoordinateListener.Event.COORDINATE_OK, \"synced on recovery\");\nbreak;\ncase NODEEXISTS:\nsynchronized (statusAndEndpoints) {\nif (statusAndEndpoints.storage == Storage.DIRTY ||\nstatusAndEndpoints.storage == Storage.SYNCED ) {\nbreak;\n}\n}\n//  synchronized (this) {\n//   storage = Storage.UNCLAIMED;\n//  }\nstatusAndEndpoints.updateCoordinateListenersAndTakeAction(\n                            CoordinateListener.Event.NOT_OWNER,\n                            \"Node already exists.\");\nbreak;\ncase NONODE:\n// synchronized (this) {\n//storage = Storage.UNCLAIMED;\n// }\nstatusAndEndpoints.updateCoordinateListenersAndTakeAction(\n                            CoordinateListener.Event.NOT_OWNER,\n                            \"No node on claiming coordinate: \" + returnCode.name() + \" \" + s);\nbreak;\ndefault:\n//synchronized (this) {\n//   storage = Storage.UNCLAIMED;\n//}\nstatusAndEndpoints.updateCoordinateListenersAndTakeAction(\n                             CoordinateListener.Event.LOST_CONNECTION_TO_STORAGE,\n                             \"Could not reclaim coordinate. Return code: \" + returnCode.name() + \" \" + s);\n}\n}", "4071": "public void setRefersToFormula(String formulaText) {\nXSSFEvaluationWorkbook fpb = XSSFEvaluationWorkbook.create(workbook);\nPtg[] ptgs;\ntry {\nptgs = FormulaParser.parse(formulaText, fpb, FormulaType.NAMEDRANGE);\n} catch (RuntimeException e) {\nif (e.getClass().getName().startsWith(FormulaParser.class.getName())) {\nthrow new IllegalArgumentException(\"Unparsable formula '\" + formulaText + \"'\", e);\n}\nthrow e;\n}\nctName.setStringValue(formulaText);\n}", "4074": "private void makeLocalToolBar() {\nIActionBars bars = getViewSite().getActionBars();\nIToolBarManager manager = bars.getToolBarManager();\nfDrillDownManager.addNavigationActions(manager);\nmanager.add(new Separator());\nmanager.add(fActionPinContent);\nmanager.add(new Separator());\nmanager.add(fActionLayout);\nfinal IMenuManager menuManager = bars.getMenuManager();\nIMenuManager depthMenuManager = new MenuManager(Messages.ZestView_3);\nmenuManager.add(depthMenuManager);\n// Depth Actions\nfDepthActions = new Action[6];\nfor(int i = 0; i < fDepthActions.length; i++) {\nfDepthActions[i] = createDepthAction(i, i + 1);\ndepthMenuManager.add(fDepthActions[i]);\n}\n// Set depth from prefs\nint depth = ArchiZestPlugin.INSTANCE.getPreferenceStore().getInt(IPreferenceConstants.VISUALISER_DEPTH);\ngetContentProvider().setDepth(depth);\nfDepthActions[depth].setChecked(true);\n// Set filter based on Viewpoint\nIMenuManager viewpointMenuManager = new MenuManager(Messages.ZestView_5);\nmenuManager.add(viewpointMenuManager);\n// Get viewpoint from prefs\nString viewpointID = ArchiZestPlugin.INSTANCE.getPreferenceStore().getString(IPreferenceConstants.VISUALISER_VIEWPOINT);\ngetContentProvider().setViewpointFilter(ViewpointManager.INSTANCE.getViewpoint(viewpointID));\n// Viewpoint actions\nfViewpointActions = new ArrayList<IAction>();\nfor(IViewpoint vp : ViewpointManager.INSTANCE.getAllViewpoints()) {\nIAction action = createViewpointMenuAction(vp);\nfViewpointActions.add(action);\nviewpointMenuManager.add(action);\n// Set checked\nif(vp.getID().equals(viewpointID)) {\naction.setChecked(true);\n}\n}\n// Set filter based on Relationship\nIMenuManager relationshipMenuManager = new MenuManager(Messages.ZestView_6);\nmenuManager.add(relationshipMenuManager);\n// Get relationship from prefs\nString relationshipID = ArchiZestPlugin.INSTANCE.getPreferenceStore().getString(IPreferenceConstants.VISUALISER_RELATIONSHIP);\nEClass eClass = (EClass)IArchimatePackage.eINSTANCE.getEClassifier(relationshipID);\ngetContentProvider().setRelationshipFilter(eClass);\n// Relationship actions, first the \"None\" relationship\nfRelationshipActions = new ArrayList<IAction>();\nIAction action = createRelationshipMenuAction(null);\nif(eClass == null) {\naction.setChecked(true);\n}\nfRelationshipActions.add(action);\nrelationshipMenuManager.add(action);\n// Then get all relationships and sort them\nArrayList<EClass> actionList = new ArrayList<EClass>(Arrays.asList(ArchimateModelUtils.getRelationsClasses()));\nactionList.sort((o1, o2) -> o1.getName().compareTo(o2.getName()));\nfor(EClass rel : actionList) {\naction = createRelationshipMenuAction(rel);\nfRelationshipActions.add(action);\nrelationshipMenuManager.add(action);\n// Set checked\nif(eClass!= null && rel.getName().equals(eClass.getName())) {\naction.setChecked(true);\n}\n}\n// Orientation\nIMenuManager orientationMenuManager = new MenuManager(Messages.ZestView_32);\nmenuManager.add(orientationMenuManager);\n// Direction\nfDirectionActions = new Action[3];\nfDirectionActions[0] = createOrientationMenuAction(0, Messages.ZestView_33, ZestViewerContentProvider.DIR_BOTH);\norientationMenuManager.add(fDirectionActions[0]);\nfDirectionActions[1] = createOrientationMenuAction(1, Messages.ZestView_34, ZestViewerContentProvider.DIR_IN);\norientationMenuManager.add(fDirectionActions[1]);\nfDirectionActions[2] = createOrientationMenuAction(2, Messages.ZestView_35, ZestViewerContentProvider.DIR_OUT);\norientationMenuManager.add(fDirectionActions[2]);\n// Set direction from prefs\nint direction = ArchiZestPlugin.INSTANCE.getPreferenceStore().getInt(IPreferenceConstants.VISUALISER_DIRECTION);\ngetContentProvider().setDirection(direction);\nfDirectionActions[direction", "4076": "public void removeUserFromGroup(A_CmsUser currentUser, A_CmsProject currentProject, \n\t\t\t\t\t\t\t\t\tString username, String groupname)\nthrows CmsException {\nif (!currentUser.hasPermission(CmsPermission.DELETE_USER_FROM_GROUP)) {\nthrow new CmsException(\"You don't have permission to delete this user from group!\");\n}\ncurrentUser.removeUserFromGroup(currentProject, username, groupname);\n}", "4077": "@Override\npublic void writeTo(SearchResponse searchResponse, Class<?> type, Type genericType, Annotation[] annotations,\n            MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream)\nthrows IOException, WebApplicationException {\nfinal CSVWriter csvWriter = new CSVWriter(new OutputStreamWriter(entityStream));\nfinal ImmutableSortedSet<String> sortedFields = ImmutableSortedSet.copyOf(searchResponse.fields);\n// write field headers\ncsvWriter.writeNext(sortedFields.toArray(new String[sortedFields.size()]));\n// write result set in same order as the header row\nfinal String[] fieldValues = new String[sortedFields.size()];\nfor (ResultMessage message : searchResponse.messages) {\nint idx = 0;\n// first collect all values from the current message\nfor (String fieldName : sortedFields) {\nfinal Object val = message.message.get(fieldName);\nfieldValues[idx++] = firstNonNull(val, \"\").toString();\n}\n// write the complete line, some fields might not be present in the message, so there might be null values\ncsvWriter.writeNext(fieldValues);\n}\nif (csvWriter.checkError()) {\nlog.error(\"Encountered unspecified error when writing message result as CSV, result is likely malformed.\");\n}\ncsvWriter.close();\n}", "4078": "@Override\npublic void execute(final AsyncCallback<List<SocketBinding>> callback) {\n// /socket-binding-group=standard-sockets:read-resource(recursive=true)\nModelNode operation = new ModelNode();\noperation.get(ADDRESS).add(\"socket-binding-group\", groupName);\noperation.get(OP).set(READ_RESOURCE_OPERATION);\noperation.get(RECURSIVE).set(true);\ndispatcher.execute(new DMRAction(operation), new SimpleCallback<DMRResponse>() {\n\n            @Override\npublic void onSuccess(DMRResponse result) {\nModelNode response = ModelNode.fromBase64(result.getResponseText());\nModelNode payload = response.get(\"result\").asObject();\nList<ModelNode> socketDescriptions= payload.get(\"socket-binding\").asList();\nList<SocketBinding> bindings = new ArrayList<SocketBinding>();\nfor(ModelNode socket : socketDescriptions)\n{\nModelNode value = socket.asProperty().getValue();\nSocketBinding sb = factory.socketBinding().as();\nsb.setName(value.get(\"name\").asString());\nsb.setGroup(groupName);\nsb.setPort(value.get(\"port\").asInt());\nString interfaceValue = value.get(\"interface\").isDefined()?\nvalue.get(\"interface\").asString() : \"not set\";\nsb.setInterface(interfaceValue);\nsb.setMultiCastAddress(value.get(\"multicast-address\").asString());\nsb.setMultiCastPort(value.get(\"multicast-port\").asInt());\nbindings.add(sb);\n}\ncallback.onSuccess(bindings);\n}\n        });\n}", "4079": "public void handleEvent(final ConnectedMessageChannel channel) {\nfinal Pooled<ByteBuffer> pooledBuffer = connection.allocate();\ntry {\nfinal ByteBuffer buffer = pooledBuffer.getResource();\nfinal int res;\ntry {\nres = channel.receive(buffer);\n} catch (IOException e) {\nconnection.handleException(e);\nreturn;\n}\nif (res == 0) {\nreturn;\n}\nif (res == -1) {\nconnection.handleException(client.abruptClose(connection));\nreturn;\n}\nbuffer.flip();\nfinal byte msgType = buffer.get();\nswitch (msgType) {\ncase Protocol.CONNECTION_ALIVE: {\nclient.trace(\"Client received connection alive\");\nconnection.sendAliveResponse();\nreturn;\n}\ncase Protocol.CONNECTION_ALIVE_ACK: {\nclient.trace(\"Client received connection alive ack\");\nreturn;\n}\ncase Protocol.CONNECTION_CLOSE: {\nclient.trace(\"Client received connection close request\");\nconnection.handlePreAuthCloseRequest();\nreturn;\n}\ncase Protocol.AUTH_CHALLENGE: {\nclient.trace(\"Client received authentication challenge\");\nconnection.getChannel().suspendReads();\nconnection.getExecutor().execute(new Runnable() {\n                            public void run() {\nfinal boolean clientComplete = saslClient.isComplete();\nif (clientComplete) {\nconnection.handleException(new SaslException(\"Received extra auth message after completion\"));\nreturn;\n}\nfinal byte[] response;\nfinal byte[] challenge = Buffers.take(buffer, buffer.remaining());\ntry {\nresponse = saslClient.evaluateChallenge(challenge);\nif (msgType == Protocol.AUTH_COMPLETE && response!= null && response.length > 0) {\nconnection.handleException(new SaslException(\"Received extra auth message after completion\"));\nreturn;\n}\n} catch (Exception e) {\nclient.tracef(\"Client authentication failed: %s\", e);\nfailedMechs.add(saslClient.getMechanismName());\nsendCapRequest(serverName);\nreturn;\n}\nclient.trace(\"Client sending authentication response\");\nfinal Pooled<ByteBuffer> pooled = connection.allocate();\nfinal ByteBuffer sendBuffer = pooled.getResource();\nsendBuffer.put(Protocol.AUTH_RESPONSE);\nsendBuffer.put(response);\nsendBuffer.flip();\nconnection.send(pooled);\nconnection.getChannel().resumeReads();\nreturn;\n}\n                        });\nreturn;\n}\ncase Protocol.AUTH_COMPLETE: {\nclient.trace(\"Client received authentication complete\");\nconnection.getChannel().suspendReads();\nconnection.getExecutor().execute(new Runnable() {\n                            public void run() {\nfinal boolean clientComplete = saslClient.isComplete();\nfinal byte[] challenge = Buffers.take(buffer, buffer.remaining());\nif (!clientComplete) try {\nfinal byte[] response = saslClient.evaluateChallenge(challenge);\nif (response!= null && response.length > 0) {\nconnection.handleException(new SaslException(\"Received extra auth message after completion\"));\nreturn;\n}\nif (!saslClient.isComplete()) {\nconnection.handleException(new SaslException(\"Client not complete after processing auth complete message\"));\nreturn;\n}\n} catch (SaslException e) {\nclient.trace(\"Client authentication failed: %s\", e);\nfailedMechs.add(saslClient.getMechanismName());\nsendCapRequest(serverName);\nreturn;\n}\nfinal Object qop = saslClient.getNegotiatedProperty(Sasl.QOP);\nif (\"auth-int\".equals(qop) || \"auth-conf\".equals(qop)) {\nconnection.setSaslWrapper(SaslWrapper.create(saslClient));\n}\n// auth complete.\nfinal ConnectionHandlerFactory connectionHandlerFactory = new ConnectionHandlerFactory() {\n                                    public ConnectionHandler createInstance(final ConnectionHandlerContext connectionContext) {\n// this happens immediately.\nfinal RemoteConnectionHandler connectionHandler = new RemoteConnectionHandler(connectionContext, connection, authorizationID, remoteEndpointName);\nconnection.setReadListener(new RemoteReadListener(connectionHandler, connection));\nreturn connectionHandler;\n}\n                                };\nconnection.getResult().setResult(connectionHandlerFactory);\nconnection.getChannel().resumeReads();\nreturn;\n}\ncase Protocol.AUTH_REJECTED: {\nclient.trace(\"Client received authentication rejected\");\nfailedMechs.add(saslClient.getMechanismName());", "4080": "public void process(final Exchange exchange) throws Exception {\nfinal Processor output = getProcessor();\nif (output == null) {\n// no output then return\nreturn;\n}\n// use a new copy of the exchange to route async\nfinal Exchange copy = exchange.newCopy();\n// let it execute async and return the Future\nCallable<Exchange> task = new Callable<Exchange>() {\n            public Exchange call() throws Exception {\n// must use a copy of the original exchange for processing async\noutput.process(copy);\nreturn copy;\n}\n        };\n// sumbit the task\nFuture<Exchange> future = getExecutorService().submit(task);\n// if we are out capable then set the response on the original exchange\nif (ExchangeHelper.isOutCapable(exchange)) {\nExchangeHelper.copyResults(exchange, future);\n}\n}", "4081": "@Override\npublic void remove(IdentityType value) throws IdentityManagementException {\nif (value == null) {\nthrow new IllegalArgumentException(\"IdentityType must not be null\");\n}\nif (identityTypes.containsKey(value)) {\nidentityTypes.remove(value);\n}\n}", "4082": "public static void saveProjects()\n{\nProjectsHandler projectsHandler = Activator.getDefault().getProjectsHandler();\nFile projectsFile = getProjectsFile();\ntry\n        {\nBufferedWriter buffWriter = new BufferedWriter( new FileWriter( projectsFile ) );\nbuffWriter.write( ProjectsExporter.toXml( projectsHandler.getProjects().toArray( new Project[0] ) ) );\nbuffWriter.close();\n}\ncatch ( IOException e )\n{\nLog.log( e );\n}\n}", "4085": "@Override\npublic void run(final Server server, final CommandSender sender, final String commandLabel, final String[] args) throws Exception\n{\nif (args.length < 2)\n{\nthrow new NotEnoughArgumentsException();\n}\nfinal ItemStack stack = ess.getItemDb().get(args[1]);\nfinal String itemname = stack.getType().toString().toLowerCase(Locale.ENGLISH).replace(\"_\", \"\");\nif (sender instanceof Player\n&& (ess.getSettings().permissionBasedItemSpawn()\n\t\t\t\t? (!ess.getUser(sender).isAuthorized(\"essentials.give.item-all\")\n&&!ess.getUser(sender).isAuthorized(\"essentials.give.item-\" + itemname)\n&&!ess.getUser(sender).isAuthorized(\"essentials.give.item-\" + stack.getTypeId()))\n: (!ess.getUser(sender).isAuthorized(\"essentials.itemspawn.exempt\")\n&&!ess.getUser(sender).canSpawnItem(stack.getTypeId()))))\n{\nthrow new Exception(_(\"cantSpawnItem\", itemname));\n}\nfinal User giveTo = getPlayer(server, args, 0);\nif (args.length > 3 && Util.isInt(args[2]) && Util.isInt(args[3]))\n{\nstack.setAmount(Integer.parseInt(args[2]));\nstack.setDurability(Short.parseShort(args[3]));\n}\nelse if (args.length > 2 && Integer.parseInt(args[2]) > 0)\n{\nstack.setAmount(Integer.parseInt(args[2]));\n}\nelse if (ess.getSettings().getDefaultStackSize() > 0)\n{\nstack.setAmount(ess.getSettings().getDefaultStackSize());\n}\nelse if (ess.getSettings().getOversizedStackSize() > 0 && giveTo.isAuthorized(\"essentials.oversizedstacks\"))\n{\nstack.setAmount(ess.getSettings().getOversizedStackSize());\n}\nif (args.length > 3)\n{\nfor (int i = Util.isInt(args[3])? 4 : 3; i < args.length; i++)\n{\nfinal String[] split = args[i].split(\"[:+',;.]\", 2);\nif (split.length < 1)\n{\ncontinue;\n}\nfinal Enchantment enchantment = Commandenchant.getEnchantment(split[0], sender instanceof Player? ess.getUser(sender) : null);\nint level;\nif (split.length > 1)\n{\nlevel = Integer.parseInt(split[1]);\n}\nelse\n\t\t\t\t{\nlevel = enchantment.getMaxLevel();\n}\nstack.addEnchantment(enchantment, level);\n}\n}\nif (stack.getType() == Material.AIR)\n{\nthrow new Exception(_(\"cantSpawnItem\", \"Air\"));\n}\nfinal String itemName = stack.getType().toString().toLowerCase(Locale.ENGLISH).replace('_','');\nsender.sendMessage(ChatColor.BLUE + \"Giving \" + stack.getAmount() + \" of \" + itemName + \" to \" + giveTo.getDisplayName() + \".\");\nif (giveTo.isAuthorized(\"essentials.oversizedstacks\"))\n{\nInventoryWorkaround.addItem(giveTo.getInventory(), true, ess.getSettings().getOversizedStackSize(), stack);\n}\nelse\n\t\t{\nInventoryWorkaround.addItem(giveTo.getInventory(), true, stack);\n}\ngiveTo.updateInventory();\n}", "4086": "@Override\npublic void setConf(Configuration conf) {\nthis.conf = conf;\nint numRows = conf.getInt(L3Tool.CONFNAME_L3_NUM_ROWS, -1);\nbinningGrid = new IsinBinningGrid(numRows);\n}", "4088": "public void rename( NextInterceptor next, RenameOperationContext opContext ) throws NamingException\n{\nLdapDN name = opContext.getDn();\nString newRdn = opContext.getNewRdn();\nboolean deleteOldRn = opContext.getDelOldDn();\nAttributes entry = nexus.lookup( new LookupOperationContext( name ) );\nif ( name.startsWith( schemaBaseDN ) )\n{\nif (!opContext.getDelOldDn() )\n{\nschemaManager.modifyRn( name, newRdn, deleteOldRn, entry, false );\n}\nelse\n            {\nschemaManager.modifyRn( name, newRdn, deleteOldRn, entry, true );\n}\n}\nnext.rename( opContext );\n}", "4099": "@Override\nprotected void runInternal() {\nContainerHandler containerHandler = beanFactory.getBean(ContainerHandler.class);\ntry {\nObject result = containerHandler.handle(this);\nlog.info(\"Result from container handle: \" + result);\n} catch (Exception e) {\nlog.error(\"Error handling container\", e);\n}\n}", "4100": "public void transformPom(MavenCoordinates coreCoordinates) throws PomTransformationException{\nFile pom = new File(rootDir.getAbsolutePath()+\"/\"+pomFileName);\nFile backupedPom = new File(rootDir.getAbsolutePath()+\"/\"+pomFileName+\".backup\");\ntry {\nFileUtils.rename(pom, backupedPom);\nSource xmlSource = new StreamSource(backupedPom);\nResult result = new StreamResult(pom);\nTransformerFactory factory = TransformerFactory.newInstance();\nTransformer transformer = factory.newTransformer(new DOMSource(xmlSource));\ntransformer.setParameter(\"parentArtifactId\", coreCoordinates.artifactId);\ntransformer.setParameter(\"parentGroupId\", coreCoordinates.groupId);\ntransformer.setParameter(\"parentVersion\", coreCoordinates.version);\ntransformer.transform(xmlSource, result);\n} catch (Exception e) {\nthrow new PomTransformationException(\"Error while transforming pom : \"+pom.getAbsolutePath(), e);\n}\n}", "4101": "public void indexingAddresses(final IProgress progress){\nFile file = new File(Environment.getExternalStorageDirectory(), ADDRESS_PATH);\ncloseAddresses();\nif (file.exists() && file.canRead()) {\nfor (File f : file.listFiles()) {\nif (f.getName().endsWith(IndexConstants.ADDRESS_INDEX_EXT)) {\nAddress address = AddressIndex.loadAddress(f);\nif (address!= null) {\naddressIndex.addAddress(address);\n}\n}\n}\n}\n}", "4105": "protected void init(){\ncom.redhat.ceylon.compiler.typechecker.model.ClassOrInterface declaration = (com.redhat.ceylon.compiler.typechecker.model.ClassOrInterface) this.declaration;\nProducedType superType = declaration.getExtendedType();\nif(superType!= null)\nthis.superclass = (ceylon.language.metamodel.untyped.ParameterisedType<ceylon.language.metamodel.untyped.Class>) Metamodel.getMetamodel(superType);\nList<ProducedType> satisfiedTypes = declaration.getSatisfiedTypes();\nceylon.language.metamodel.untyped.ParameterisedType<ceylon.language.metamodel.untyped.Interface>[] interfaces = new ceylon.language.metamodel.untyped.ParameterisedType[satisfiedTypes.size()];\nint i=0;\nfor(ProducedType pt : satisfiedTypes){\ninterfaces[i++] = (ceylon.language.metamodel.untyped.ParameterisedType<ceylon.language.metamodel.untyped.Interface>) Metamodel.getMetamodel(pt);\n}\nthis.interfaces = (Sequential)Util.sequentialInstance($InterfacesTypeDescriptor, interfaces);\nList<com.redhat.ceylon.compiler.typechecker.model.TypeParameter> typeParameters = declaration.getTypeParameters();\nceylon.language.metamodel.untyped.TypeParameter[] typeParametersArray = new ceylon.language.metamodel.untyped.TypeParameter[typeParameters.size()];\ni=0;\nfor(com.redhat.ceylon.compiler.typechecker.model.TypeParameter tp : typeParameters){\ntypeParametersArray[i++] = new com.redhat.ceylon.compiler.java.runtime.metamodel.FreeTypeParameter(tp);\n}\nthis.typeParameters = (Sequential)Util.sequentialInstance(ceylon.language.metamodel.untyped.TypeParameter.$TypeDescriptor, typeParametersArray);\nList<com.redhat.ceylon.compiler.typechecker.model.Declaration> memberModelDeclarations = declaration.getMembers();\ni=0;\nList<ceylon.language.metamodel.untyped.Member<FreeFunction>> functions = new LinkedList<ceylon.language.metamodel.untyped.Member<FreeFunction>>();\nList<ceylon.language.metamodel.untyped.Member<FreeValue>> values = new LinkedList<ceylon.language.metamodel.untyped.Member<FreeValue>>();\nList<ceylon.language.metamodel.untyped.Member<FreeClassOrInterface>> types = new LinkedList<ceylon.language.metamodel.untyped.Member<FreeClassOrInterface>>();\nfor(com.redhat.ceylon.compiler.typechecker.model.Declaration memberModelDeclaration : memberModelDeclarations){\nif(memberModelDeclaration instanceof Method){\nfunctions.add(new FreeMember(this, new FreeFunction((Method) memberModelDeclaration)));\n}else if(memberModelDeclaration instanceof com.redhat.ceylon.compiler.typechecker.model.Value){\nvalues.add(new FreeMember(this, new FreeValue((MethodOrValue) memberModelDeclaration)));\n}else if(memberModelDeclaration instanceof com.redhat.ceylon.compiler.typechecker.model.ClassOrInterface){\ntypes.add(new FreeMember(this, Metamodel.getOrCreateMetamodel(memberModelDeclaration)));\n}\n}\nTypeDescriptor functionMemberTD = TypeDescriptor.klass(ceylon.language.metamodel.untyped.Member.class, $FunctionTypeDescriptor);\nthis.functions = (Sequential)Util.sequentialInstance(functionMemberTD, functions.toArray(new ceylon.language.metamodel.untyped.Member[functions.size()]));\nTypeDescriptor valueMemberTD = TypeDescriptor.klass(ceylon.language.metamodel.untyped.Member.class, $ValueTypeDescriptor);\nthis.values = (Sequential)Util.sequentialInstance(valueMemberTD, values.toArray(new ceylon.language.metamodel.untyped.Member[values.size()]));\nTypeDescriptor typesMemberTD = TypeDescriptor.klass(ceylon.language.metamodel.untyped.Member.class, $ClassOrInterfaceTypeDescriptor);\nthis.types = (Sequential)Util.sequentialInstance(typesMemberTD, types.toArray(new ceylon.language.metamodel.untyped.Member[types.size()]));\n}", "4106": "private void resolve(final IPackageFragmentRoot packageRoot) {\nif (packageRoot instanceof JarPackageFragmentRoot) {\nfinal String name = packageRoot.getPath().lastSegment();\nif (name.matches(\"org\\\\.eclipse\\\\..+\")) {\ncallsModelIndex.setResolved(packageRoot, new LibraryIdentifier(\"org.eclipse\", Version.create(3, 6)));\nreturn;\n}\n}\ncallsModelIndex.setResolved(packageRoot, LibraryIdentifier.UNKNOWN);\n}", "4107": "private void createProfilesSection(FormToolkit toolkit, Composite body) {\nSection profilesSection = toolkit.createSection(body, Section.TITLE_BAR);\nprofilesSection.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false, 1, 3));\nprofilesSection.setText(\"Profiles\");\nprofilesEditor = new ListEditorComposite<Profile>(profilesSection, SWT.NONE);\nprofilesSection.setClient(profilesEditor);\ntoolkit.adapt(profilesEditor);\ntoolkit.paintBordersFor(profilesEditor);\nprofilesEditor.setContentProvider(new ListEditorContentProvider<Profile>());\nprofilesEditor.setLabelProvider(new LabelProvider() {\n      public String getText(Object element) {\nif(element instanceof Profile) {\nString profileId = ((Profile) element).getId();\nreturn profileId==null || profileId.length()==0? \"[unknown]\" : profileId;\n}\nreturn super.getText(element);\n}\npublic Image getImage(Object element) {\nreturn MavenEditorImages.IMG_PROFILE;\n}\n    });\nprofilesEditor.addSelectionListener(new ISelectionChangedListener() {\n      public void selectionChanged(SelectionChangedEvent event) {\nList<Profile> selection = profilesEditor.getSelection();\nupdateProfileDetails(selection.size()==1? selection.get(0) : null);\n}\n    });\nprofilesEditor.setReadOnly(pomEditor.isReadOnly());\n}", "4110": "public void deleteProfile(int profileId) {\nRulesProfile profile = getSession().getEntity(RulesProfile.class, profileId);\nif (profile!= null &&!profile.getProvided()) {\nString hql = \"UPDATE \" + ResourceModel.class.getSimpleName() + \" o SET o.rulesProfile=null WHERE o.rulesProfile=:rulesProfile\";\ngetSession().createQuery(hql).setParameter(\"rulesProfile\", profile).executeUpdate();\ngetSession().remove(profile);\ngetSession().commit();\n}\n}", "4113": "@EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)\npublic void payForAction(FactionsEventMembershipChange event)\n{\nDouble cost = null;\nString desc = null;\nif (event.getReason() == MembershipChangeReason.JOIN)\n{\ncost = UConf.get(event.getSender()).econCostJoin;\ndesc = \"join a faction\";\n}\nelse if (event.getReason() == MembershipChangeReason.LEAVE)\n{\ncost = UConf.get(event.getSender()).econCostLeave;\ndesc = \"leave a faction\";\n}\nelse if (event.getReason() == MembershipChangeReason.KICK)\n{\ncost = UConf.get(event.getSender()).econCostKick;\ndesc = \"kick someone from a faction\";\n}\nelse\n\t\t{\nreturn;\n}\npayForAction(event, cost, desc);\n}", "4114": "@Override\npublic void addGenotypeCall(GenotypeCall locus) {\nif (locus.getGenotype().equals(getGenotype())) {\ngetGenotype().addCall(locus);\n}\n}", "4117": "public static CommandSpec getOptionCommand(PermissionsEx pex) {\nreturn CommandSpec.builder()\n.setAliases(\"options\", \"option\", \"opt\", \"o\")\n.setArguments(seq(string(_(\"key\")), optional(string(_(\"val\")))))\n.setExecutor(new PermissionsExExecutor(pex) {\n                    @Override\npublic <TextType> void execute(Commander<TextType> src, CommandContext args) throws CommandException {\nMap.Entry<String, String> subject = subjectOrSelf(src, args);\ncheckSubjectPermission(src, subject, \"permissionsex.option.set\");\nSet<Map.Entry<String, String>> contexts = ImmutableSet.copyOf(args.<Set<Map.Entry<String, String>>>getAll(\"context\"));\nSubjectCache dataCache = args.hasAny(\"transient\")? pex.getTransientSubjects(subject.getKey()) : pex.getSubjects(subject.getKey());\nImmutableOptionSubjectData data = getSubjectData(dataCache, subject.getValue());\nfinal String key = args.getOne(\"key\");\nfinal String value = args.getOne(\"value\");\nif (value == null) {\nmessageSubjectOnFuture(\n                                    dataCache.update(subject.getValue(), data.unsetOption(contexts, key, null)), src,\n                                    _(\"Unset option '%s' for subject %s in %s context\", key, src.fmt().hl(src.fmt().subject(subject)), formatContexts(src, contexts)));\n} else {\nmessageSubjectOnFuture(\n                                    dataCache.update(subject.getValue(), data.setOption(contexts, key, value)), src,\n                                    _(\"Set option %s for subject %s in %s context\", src.fmt().option(key, value), src.fmt().hl(src.fmt().subject(subject)), formatContexts(src, contexts)));\n}\n}\n                })\n.build();\n}", "4121": "private void createQueue(final Shell parent)\n{\nfinal Shell shell = ViewUtility.createModalDialogShell(parent, \"Create Queue\");\nComposite nameComposite = _toolkit.createComposite(shell, SWT.NONE);\nnameComposite.setBackground(shell.getBackground());\nnameComposite.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));\nnameComposite.setLayout(new GridLayout(2,false));\n_toolkit.createLabel(nameComposite,\"Name:\").setBackground(shell.getBackground());\nfinal Text nameText = new Text(nameComposite, SWT.BORDER);\nnameText.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));\nComposite ownerComposite = _toolkit.createComposite(shell, SWT.NONE);\nownerComposite.setBackground(shell.getBackground());\nownerComposite.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));\nownerComposite.setLayout(new GridLayout(2,false));\n_toolkit.createLabel(ownerComposite,\"Owner (optional):\").setBackground(shell.getBackground());\nfinal Text ownerText = new Text(ownerComposite, SWT.BORDER);\nownerText.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));\nComposite durableComposite = _toolkit.createComposite(shell, SWT.NONE);\ndurableComposite.setBackground(shell.getBackground());\nGridData gridData = new GridData(SWT.FILL, SWT.TOP, true, false);\ngridData.minimumWidth = 220;\ndurableComposite.setLayoutData(gridData);\ndurableComposite.setLayout(new GridLayout(2,false));\n_toolkit.createLabel(durableComposite,\"Durable:\").setBackground(shell.getBackground());\nfinal Button durableButton = new Button(durableComposite, SWT.CHECK);\ndurableButton.setLayoutData(new GridData(SWT.LEFT, SWT.TOP, true, false));\nComposite okCancelButtonsComp = _toolkit.createComposite(shell);\nokCancelButtonsComp.setBackground(shell.getBackground());\nokCancelButtonsComp.setLayoutData(new GridData(SWT.RIGHT, SWT.FILL, true, true));\nokCancelButtonsComp.setLayout(new GridLayout(2,false));\nButton okButton = _toolkit.createButton(okCancelButtonsComp, \"OK\", SWT.PUSH);\nokButton.setLayoutData(new GridData(SWT.RIGHT, SWT.TOP, false, false));\nButton cancelButton = _toolkit.createButton(okCancelButtonsComp, \"Cancel\", SWT.PUSH);\ncancelButton.setLayoutData(new GridData(SWT.RIGHT, SWT.TOP, false, false));\nokButton.addSelectionListener(new SelectionAdapter()\n{\n            public void widgetSelected(SelectionEvent e)\n{\nString name = nameText.getText();\nif (name == null || name.length() == 0)\n{\nViewUtility.popupErrorMessage(\"Create Queue\", \"Please enter a valid name\");\nreturn;\n}\nString owner = ownerText.getText();\nboolean durable = durableButton.getSelection();\nshell.dispose();\ntry\n                {\n_vhmb.createNewQueue(name, owner, durable);\n}\ncatch(Exception e5)\n{\nMBeanUtility.handleException(_mbean, e5);\n}\nrefresh(_mbean);\n}\n        });\ncancelButton.addSelectionListener(new SelectionAdapter()\n{\n            public void widgetSelected(SelectionEvent e)\n{\nshell.dispose();\n}\n        });\nshell.setDefaultButton(okButton);\nshell.pack();\nshell.open();\n}", "4122": "public void testFilterWithData() {\nfinal JobConfigHistory jch = hudson.getPlugin(JobConfigHistory.class);\njch.setSaveSystemConfiguration(true);\n//create some config history data\ntry {\nfinal FreeStyleProject project = createFreeStyleProject(\"Test1\");\nThread.sleep(SLEEP_TIME);\nproject.disable();\nThread.sleep(SLEEP_TIME);\nhudson.setSystemMessage(\"Testmessage\");\nThread.sleep(SLEEP_TIME);\nfinal FreeStyleProject secondProject = createFreeStyleProject(\"Test2\");\nThread.sleep(SLEEP_TIME);\nsecondProject.delete();\n} catch (Exception ex) {\nfail(\"Unable to prepare Hudson instance: \" + ex);\n}\ntry {\ncheckSystemPage(webClient.goTo(JobConfigHistoryConsts.URLNAME));\ncheckSystemPage(webClient.goTo(JobConfigHistoryConsts.URLNAME + \"/?filter=system\"));\nfinal HtmlPage htmlPageJobs = webClient.goTo(JobConfigHistoryConsts.URLNAME + \"/?filter=jobs\");\nassertTrue(\"Verify history entry for job is listed.\", htmlPageJobs.getAnchorByText(\"Test1\")!= null);\nassertTrue(\"Verify history entry for deleted job is listed.\",\n                    htmlPageJobs.asText().contains(JobConfigHistoryConsts.DELETED_MARKER));\nassertFalse(\"Verify that no history entry for system change is listed.\",\n                    htmlPageJobs.asText().contains(\"config (system)\"));\nassertTrue(\"Check link to job page.\", htmlPageJobs.asXml().contains(\"job/Test1/\" + JobConfigHistoryConsts.URLNAME));\nfinal HtmlPage htmlPageDeleted = webClient.goTo(\"jobConfigHistory/?filter=deleted\");\nfinal String page = htmlPageDeleted.asXml();\nassertTrue(\"Verify history entry for deleted job is listed.\", page.contains(JobConfigHistoryConsts.DELETED_MARKER));\nassertFalse(\"Verify no history entry for job is listed.\", page.contains(\"Test1\"));\nassertFalse(\"Verify no history entry for system change is listed.\", page.contains(\"(system)\"));\nassertTrue(\"Check link to historypage exists.\", page.contains(\"history?name\"));\nassertFalse(\"Verify that only \\'Deleted\\' entries are listed.\", page.contains(\"Created\") || page.contains(\"Changed\"));\n} catch (Exception ex) {\nfail(\"Unable to complete testFilterWithData: \" + ex);\n}\n}", "4123": "void addGadgetView(int gadgetId, GadgetInfo gadget) {\n// Inflate the gadget's RemoteViews\nGadgetHostView view = mHost.createView(this, gadgetId, gadget);\n// Add it to the list\nLinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                65, // LinearLayout.LayoutParams.WRAP_CONTENT,\nLinearLayout.LayoutParams.WRAP_CONTENT);\nmGadgetContainer.addView(view, layoutParams);\n}", "4127": "private void send(final Datacenter datacenter, final DatacenterTasks tasks,\n        final EventType event)\n{\nTarantinoRequestProducer producer = new TarantinoRequestProducer(datacenter.getName(),\n                tasks.getUuid());\ntry\n        {\nproducer.openChannel();\nproducer.publish(tasks);\n}\ncatch (Exception ex)\n{\ntracer.log(SeverityType.CRITICAL, ComponentType.VIRTUAL_MACHINE, event,\n                APIError.GENERIC_OPERATION_ERROR.getMessage());\ntracer.systemError(SeverityType.CRITICAL, ComponentType.VIRTUAL_MACHINE, event,\n                \"Failed to enqueue task in Tarantino. Rabbitmq might be \"\n+ \"down or not configured. The error message was \" + ex.getMessage(), ex);\naddNotFoundErrors(APIError.GENERIC_OPERATION_ERROR);\nflushErrors();\n}\nfinally\n        {\ncloseProducerChannel(producer, event);\n}\ntracer.log(SeverityType.INFO, ComponentType.VIRTUAL_MACHINE, event,\n            \"Task enqueued successfully to Tarantinio\");\n}", "4128": "protected <T> void printOnTraversalDone(final String type, T sum) {\nprintProgress(true, type, null);\nSystem.out.println(\"Traversal reduce result is \" + sum);\nfinal long curTime = System.currentTimeMillis();\nfinal double elapsed = (curTime - startTime) / 1000.0;\nlogger.info(String.format(\"Total runtime %.2f secs, %.2f min, %.2f hours%n\", elapsed, elapsed / 60, elapsed / 3600));\nlogger.info(String.format(\"Traversal skipped %d reads out of %d total (%.2f%%)\", nSkippedReads, nReads, (nSkippedReads * 100.0) / nReads));\nlogger.info(String.format(\"  -> %d unmapped reads\", nUnmappedReads));\nlogger.info(String.format(\"  -> %d non-primary reads\", nNotPrimary));\nlogger.info(String.format(\"  -> %d reads with bad alignments\", nBadAlignments));\nlogger.info(String.format(\"  -> %d reads with indels\", nSkippedIndels));\n}", "4134": "public void storeArtifact( GAVRequest gavRequest, InputStream is )\nthrows UnsupportedStorageOperationException,\n            NoSuchResourceStoreException,\n            RepositoryNotAvailableException,\n            StorageException,\n            AccessDeniedException\n{\ncheckRequest( gavRequest );\nGav gav = new Gav( gavRequest.getGroupId(), gavRequest.getArtifactId(), gavRequest.getVersion(), gavRequest\n.getClassifier(), gavRequest.getPackaging(), gavRequest.getExtension(), null, null, null, RepositoryPolicy.SNAPSHOT.equals( repository\n.getRepositoryPolicy() ), false, null );\nDefaultStorageFileItem file = new DefaultStorageFileItem( repository, repository.getGavCalculator().gavToPath(\n            gav ), true, true, new PreparedContentLocator( is ) );\nstoreItemWithChecksums( file );\n}", "4137": "public void postMessage()\n{\nStreamScope scope = postToPanel.getPostScope();\nif (scope!= null)\n{\nif (scope.getScopeType().equals(ScopeType.PERSON))\n{\nrecipientType = EntityType.PERSON;\n}\nelse\n            {\nrecipientType = EntityType.GROUP;\n}\nactionKeys.put(EntityType.GROUP, \"postGroupActivityServiceActionTaskHandler\");\nactionKeys.put(EntityType.PERSON, \"postPersonActivityServiceActionTaskHandler\");\nActivityDTOPopulatorStrategy objectStrat = new NotePopulator();\nif (attachment!= null)\n{\nobjectStrat = attachment.getPopulator();\n}\nPostActivityRequest postRequest = new PostActivityRequest(\n                    activityPopulator\n.getActivityDTO(message, recipientType, scope\n.getUniqueKey(), new PostPopulator(), objectStrat));\nprocessor.makeRequest(new ActionRequestImpl<Integer>(actionKeys\n.get(recipientType), postRequest),\n                    new AsyncCallback<ActivityDTO>()\n{\n                        /* implement the async call back methods */\npublic void onFailure(final Throwable caught)\n{\nMessageStreamAppendEvent msgEvent = new MessageStreamAppendEvent(\n                                    result);\neventBus.notifyObservers(msgEvent);\n}\npublic void onSuccess(final ActivityDTO result)\n{\nMessageStreamAppendEvent msgEvent = new MessageStreamAppendEvent(\n                                    result);\neventBus.notifyObservers(msgEvent);\n}\n                    });\n}\nelse\n        {\nErrorPostingMessageToNullScopeEvent error = new ErrorPostingMessageToNullScopeEvent();\nerror\n.setErrorMsg(\"The stream name you entered could not be found\");\neventBus.notifyObservers(error);\n}\n}", "4140": "@Handler\nvoid onBackToPreviousLocation()\n{\nif (!sourceNavigations_.empty())\n{\n// get the navigation and doc-id\nSourceNavigation navigation = sourceNavigations_.pop();\nString docId = navigation.getDocumentId();\n// search for a document with this id\nfor (EditingTarget editingTarget : editors_)\n{\nif (editingTarget.getId().equals(docId))\n{\nnavigateTo(navigation);\nbreak;\n}\n}\nmanageBackToPreviousLocationCommand();\n}\n}", "4141": "@Override\npublic void actionPerformed(AnActionEvent event) {\ntry {\nbrowserPanel.loadView(null);\n} catch (Exception ex) {\nbrowserPanel.notifyErrorJenkinsToolWindow(\"Unable to refresh: \" + ex.getMessage());\n}\n}", "4142": "@Override\npublic final void onStartScreen() {\nLOGGER.fine(\"starting chat screen\");\ntextControl = this.element.findNiftyControl(CHAT_TEXT_INPUT, TextField.class);\ntextControl.addInputHandler(this);\n}", "4143": "private static void iterateFonts(ProjectFileContext c, NodeList fntList, ResNode node) throws IOException,GmFormatException, SAXException\n{\nProjectFile f = c.f;\nfor (int i = 0; i < fntList.getLength(); i++) {\nNode cNode = fntList.item(i);\nString cname = cNode.getNodeName();\nif (cname.equals(\"#text\")) {\ncontinue;\n}\nResNode rnode = null;\nif (cname.equals(\"fonts\")) {\nrnode = new ResNode(cNode.getAttributes().item(0).getTextContent(), ResNode.STATUS_GROUP, Font.class, null);\nnode.add(rnode);\niterateFonts(c, cNode.getChildNodes(), rnode);\n} else if (cname.equals(\"font\")){\nFont fnt = f.resMap.getList(Font.class).add();\nf.resMap.getList(Font.class).lastId++;\nString fileName = new File(getUnixPath(cNode.getTextContent())).getName();\nfnt.setName(fileName);\nfnt.setNode(rnode);\nrnode = new ResNode(fnt.getName(), ResNode.STATUS_SECONDARY, Font.class, fnt.reference);\nnode.add(rnode);\nString path = f.getPath();\npath = path.substring(0, path.lastIndexOf('/')+1) + getUnixPath(cNode.getTextContent());\nDocument fntdoc = documentBuilder.parse(path + \".font.gmx\");\nfnt.put(PFont.FONT_NAME, fntdoc.getElementsByTagName(\"name\").item(0).getTextContent());\nfnt.put(PFont.SIZE, Integer.parseInt(fntdoc.getElementsByTagName(\"size\").item(0).getTextContent()));\nfnt.put(PFont.BOLD, Integer.parseInt(fntdoc.getElementsByTagName(\"bold\").item(0).getTextContent()) < 0);\nfnt.put(PFont.ITALIC, Integer.parseInt(fntdoc.getElementsByTagName(\"italic\").item(0).getTextContent()) < 0);\nfnt.put(PFont.CHARSET, Integer.parseInt(fntdoc.getElementsByTagName(\"charset\").item(0).getTextContent()));\nfnt.put(PFont.ANTIALIAS, Integer.parseInt(fntdoc.getElementsByTagName(\"aa\").item(0).getTextContent()));\nString[] range = fntdoc.getElementsByTagName(\"range0\").item(0).getTextContent().split(\",\");\nfnt.put(PFont.RANGE_MIN, Integer.parseInt(range[0]));\nfnt.put(PFont.RANGE_MAX, Integer.parseInt(range[1]));\n}\n}\n}", "4147": "protected void doProcessParallel(final Exchange original, final AtomicExchange result, final Iterable<ProcessorExchangePair> pairs,\n                                     final boolean streaming, final AsyncCallback callback) throws InterruptedException, ExecutionException {\nfinal CompletionService<Exchange> completion;\nfinal AtomicBoolean running = new AtomicBoolean(true);\nif (streaming) {\n// execute tasks in parallel+streaming and aggregate in the order they are finished (out of order sequence)\ncompletion = new ExecutorCompletionService<Exchange>(executorService);\n} else {\n// execute tasks in parallel and aggregate in the order the tasks are submitted (in order sequence)\ncompletion = new SubmitOrderedCompletionService<Exchange>(executorService);\n}\nfinal AtomicInteger total = new AtomicInteger(0);\nfinal Iterator<ProcessorExchangePair> it = pairs.iterator();\nwhile (it.hasNext()) {\nfinal ProcessorExchangePair pair = it.next();\nfinal Exchange subExchange = pair.getExchange();\nupdateNewExchange(subExchange, total.intValue(), pairs, it);\ncompletion.submit(new Callable<Exchange>() {\n                public Exchange call() throws Exception {\nif (!running.get()) {\n// do not start processing the task if we are not running\nreturn subExchange;\n}\ntry {\ndoProcessParallel(pair);\n} catch (Throwable e) {\nsubExchange.setException(e);\n}\n// Decide whether to continue with the multicast or not; similar logic to the Pipeline\nInteger number = getExchangeIndex(subExchange);\nboolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\nif (stopOnException &&!continueProcessing) {\n// signal to stop running\nrunning.set(false);\n// throw caused exception\nif (subExchange.getException()!= null) {\n// wrap in exception to explain where it failed\nthrow new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n}\n}\nif (LOG.isTraceEnabled()) {\nLOG.trace(\"Parallel processing complete for exchange: \" + subExchange);\n}\nreturn subExchange;\n}\n            });\ntotal.incrementAndGet();\n}\n// in streaming mode we need to aggregate on-the-fly\n// its to hard to do parallel async routing so we let the caller thread be synchronously\n// and have it pickup the replies and do the aggregation\nboolean timedOut = false;\nboolean stoppedOnException = false;\nfinal StopWatch watch = new StopWatch();\nfor (int i = 0; i < total.intValue(); i++) {\nFuture<Exchange> future;\nif (timedOut) {\n// we are timed out but try to grab if some tasks has been completed\n// poll will return null if no tasks is present\nfuture = completion.poll();\n} else if (timeout > 0) {\nlong left = timeout - watch.taken();\nif (left < 0) {\nleft = 0;\n}\nif (LOG.isTraceEnabled()) {\nLOG.trace(\"Polling completion task #\" + i + \" using timeout \" + left + \" millis.\");\n}\nfuture = completion.poll(left, TimeUnit.MILLISECONDS);\n} else {\n// take will wait until the task is complete\nif (LOG.isTraceEnabled()) {\nLOG.trace(\"Polling completion task #\" + i);\n}\nfuture = completion.take();\n}\nif (future == null && timedOut) {\n// we are timed out and no more tasks complete so break out\nbreak;\n} else if (future == null) {\n// timeout occurred\nAggregationStrategy strategy = getAggregationStrategy(null);\nif (strategy instanceof TimeoutAwareAggregationStrategy) {\n// notify the strategy we timed out\nExchange oldExchange = result.get();\nif (oldExchange == null) {\n// if they all timed out the result may not have been set yet, so use the original exchange\noldExchange = original;\n}\n((TimeoutAwareAggregationStrategy) strategy).timeout(oldExchange, i, total.intValue(), timeout);\n} else {\n// log a WARN we timed out since it will not be aggregated and the Exchange will be lost\nLOG.warn(\"Parallel processing timed out after \" + timeout + \" millis for number \" + i + \". This task will be cancelled and will not be aggregated.\");\n}\ntimedOut = true;\n} else {\n// there is a result to aggregate\nExchange subExchange = future.get();\n// Decide whether to continue with the multicast or not; similar logic to the Pipeline\nboolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\nif", "4149": "protected void didInvokeUnit (Unit unit, long start)\n{\n// track some performance metrics\nif (PERF_TRACK) {\nlong duration = System.currentTimeMillis() - start;\nObject key = unit.getClass();\nrecordMetrics(key, duration);\n// report long runners\nlong thresh = unit.getLongThreshold();\nif (thresh == 0) {\nthresh = (_longThreshold == 0)\n                   ? _defaultLongThreshold\n: _longThreshold;\n}\nif (duration > thresh) {\nStringBuilder msg = new StringBuilder();\nmsg.append((duration >= 10*thresh)? \"Really long\" : \"Long\");\nmsg.append(\" invoker unit [unit=\").append(unit);\nmsg.append(\" (\").append(key).append(\"), time=\").append(duration).append(\"ms\");\nif (unit.getDetail()!= null) {\nmsg.append(\", detail=\").append(unit.getDetail());\n}\nlog.warning(msg.append(\"].\").toString());\n}\n}\n}", "4152": "@Test\n@IgnoreBrowsers({\n    @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1146\"),\n    @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1177\")\n    })\npublic void testLinkToSpaceIndexWhenSpecialCharacterInSpaceName()\n{\nString spaceName = getTestClassName() + \"&\";\n// Make sure the space WebHome page doesn't exist.\ngetUtil().deletePage(spaceName, \"WebHome\");\n// Create Space with a URL-reserved character in the Space name.\nWikiEditPage editPage = WikiEditPage.gotoPage(spaceName, \"WebHome\");\neditPage.setContent(\"Content\");\neditPage.clickSaveAndView();\n// Navigate to the Home Page and click on the SpaceIndex.\nHomePage homePage = HomePage.gotoPage();\nhomePage.getSpacesPane().clickSpaceIndex(spaceName);\n// Check the link to the SpaceIndex page.\nAssert.assertEquals(getUtil().getURL(\"Main\", \"SpaceIndex\", \"view\", \"space=\" + getUtil().escapeURL(spaceName)),\n            getDriver().getCurrentUrl());\n}", "4155": "public void processEndOfRound() {\n// process all gameobjects\nInternalObject[] gameObjects = new InternalObject[gameObjectsByID.size()];\ngameObjects = gameObjectsByID.values().toArray(gameObjects);\nfor (int i = 0; i < gameObjects.length; i++) {\ngameObjects[i].processEndOfRound();\n}\nremoveDead();\nupdateRevealedRobots();\n// update neutrals\ngameMap.getNeutralsMap().next(gameObjects);\naddSignal(new FluxChangeSignal(teamResources));\naddSignal(new ResearchChangeSignal(research));\naddSignal(new NeutralsDensitySignal(gameMap.getNeutralsMap()));\nif (timeLimitReached() && winner == null) {\n//        \ttime limit damage to HQs\n//for (InternalRobot r : baseHQs.values()) {\n//r.takeDamage(GameConstants.TIME_LIMIT_DAMAGE);\n//}\n//removeDead();\n//        \tif both are killed by time limit damage in the same round, then more tie breakers\nif (baseHQs.get(Team.A).getEnergonLevel() <= 0.0 && baseHQs.get(Team.B).getEnergonLevel() <= 0.0 || true) {\n// main tie breaker = milk\nInternalRobot HQA = baseHQs.get(Team.A);\nInternalRobot HQB = baseHQs.get(Team.B);\nif (!(setWinnerIfNonzero(teamResources[Team.A.ordinal()] - teamResources[Team.B.ordinal()], DominationFactor.BARELY_BEAT)))\n{\nif (HQA.getID() < HQB.getID())\nsetWinner(Team.B, DominationFactor.WON_BY_DUBIOUS_REASONS);\nelse\nsetWinner(Team.A, DominationFactor.WON_BY_DUBIOUS_REASONS);\n}\ndouble diff = HQA.getEnergonLevel() - HQB.getEnergonLevel();\ndouble campdiff = getEncampmentsByTeam(Team.A).size() - getEncampmentsByTeam(Team.B).size();\nif (!(\n// first tie breaker - encampment count\nsetWinnerIfNonzero(campdiff, DominationFactor.BARELY_BEAT)\n// second tie breaker - total energon difference\n|| setWinnerIfNonzero(getEnergonDifference(), DominationFactor.BARELY_BEAT)\n// third tie breaker - mine count\n|| setWinnerIfNonzero(getMineDifference(), DominationFactor.BARELY_BEAT)\n))\n{\n// fourth tie breaker - power difference\nif (!(setWinnerIfNonzero(teamResources[Team.A.ordinal()] - teamResources[Team.B.ordinal()], DominationFactor.BARELY_BEAT)))\n{\nif (HQA.getID() < HQB.getID())\nsetWinner(Team.B, DominationFactor.WON_BY_DUBIOUS_REASONS);\nelse\nsetWinner(Team.A, DominationFactor.WON_BY_DUBIOUS_REASONS);\n}\n}\n}\n}\nif (winner!= null) {\nrunning = false;\nfor (InternalObject o : gameObjectsByID.values()) {\nif (o instanceof InternalRobot)\nRobotMonitor.killRobot(o.getID());\n}\n}\nlong aPoints = Math.round(teamRoundResources[Team.A.ordinal()] * 100), bPoints = Math.round(teamRoundResources[Team.B.ordinal()] * 100);\nroundStats = new RoundStats(teamResources[0] * 100, teamResources[1] * 100, teamRoundResources[0] * 100, teamRoundResources[1] * 100);\n// MILK\nteamResources[Team.A.ordinal()] += gameMap.getNeutralsMap().getScoreChange(Team.A, gameObjects);\nteamResources[Team.B.ordinal()] += gameMap.getNeutralsMap().getScoreChange(Team.B, gameObjects);\nif (teamResources[Team.A.ordinal()] < teamResources[Team.B.ordinal()])\naddSignal(new NeutralsDamageSignal", "4161": "public void testMaxErrors() throws ReedSolomonException {\nint[] received = new int[DM_CODE_TEST_WITH_EC.length];\nRandom random = new Random(0xDEADBEEFL);\nfor (int i = 0; i < DM_CODE_TEST.length; i++) { // # iterations is kind of arbitrary\nSystem.arraycopy(DM_CODE_TEST_WITH_EC, 0, received, 0, received.length);\ncorrupt(received, DM_CODE_CORRECTABLE - 1, random);\ncheckQRRSDecode(received);\n}\n}", "4162": "void addContactListContent(ContactList list) {\nString selection = Imps.ContactList.NAME + \"=? AND \" + Imps.ContactList.PROVIDER\n+ \"=? AND \" + Imps.ContactList.ACCOUNT + \"=?\";\nString[] selectionArgs = { list.getName(), Long.toString(mProviderId),\n                                  Long.toString(mAccountId) };\nCursor cursor = mResolver.query(Imps.ContactList.CONTENT_URI, CONTACT_LIST_ID_PROJECTION,\n                selection, selectionArgs, null); // no sort order\nlong listId = 0;\nUri uri = null;\ntry {\nif (cursor.moveToFirst()) {\nlistId = cursor.getLong(0);\nuri = ContentUris.withAppendedId(Imps.ContactList.CONTENT_URI, listId);\n}\n} finally {\ncursor.close();\n}\nif (uri == null) {\nContentValues contactListValues = new ContentValues(3);\ncontactListValues.put(Imps.ContactList.NAME, list.getName());\ncontactListValues.put(Imps.ContactList.PROVIDER, mProviderId);\ncontactListValues.put(Imps.ContactList.ACCOUNT, mAccountId);\nuri = mResolver.insert(Imps.ContactList.CONTENT_URI, contactListValues);\nlistId = ContentUris.parseId(uri);\n}\nmValidatedContactLists.add(list.getName());\nsynchronized (mContactLists) {\nmContactLists.put(list.getAddress(), new ContactListAdapter(list, listId));\n}\nCursor contactCursor = mResolver.query(mContactUrl, new String[] { Imps.Contacts.USERNAME },\n                Imps.Contacts.CONTACTLIST + \"=?\", new String[] { \"\" + listId }, null);\nSet<String> existingUsernames = new HashSet<String>();\nwhile (contactCursor.moveToNext())\nexistingUsernames.add(contactCursor.getString(0));\ncontactCursor.close();\nCollection<Contact> contacts = list.getContacts();\nif (contacts == null || contacts.size() == 0) {\nreturn;\n}\nIterator<Contact> iter = contacts.iterator();\nwhile (iter.hasNext()) {\nContact c = iter.next();\nString address = c.getAddress().getAddress();\nif (isTemporary(address)) {\nif (!existingUsernames.contains(address)) {\nmoveTemporaryContactToList(address, listId);\n}\niter.remove();\n}\nmValidatedContacts.add(address);\n}\nArrayList<String> usernames = new ArrayList<String>();\nArrayList<String> nicknames = new ArrayList<String>();\nArrayList<String> contactTypeArray = new ArrayList<String>();\nfor (Contact c : contacts) {\nString username = c.getAddress().getAddress();\nString nickname = c.getName();\nif (existingUsernames.contains(username))\ncontinue;\nint type = Imps.Contacts.TYPE_NORMAL;\nif (isTemporary(username)) {\ntype = Imps.Contacts.TYPE_TEMPORARY;\n}\nif (isBlocked(username)) {\ntype = Imps.Contacts.TYPE_BLOCKED;\n}\nusernames.add(username);\nnicknames.add(nickname);\ncontactTypeArray.add(String.valueOf(type));\n}\nContentValues values = new ContentValues(6);\nvalues.put(Imps.Contacts.PROVIDER, mProviderId);\nvalues.put(Imps.Contacts.ACCOUNT, mAccountId);\nvalues.put(Imps.Contacts.CONTACTLIST, listId);\nputStringArrayList(values, Imps.Contacts.USERNAME, usernames);\nputStringArrayList(values, Imps.Contacts.NICKNAME, nicknames);\nputStringArrayList(values, Imps.Contacts.TYPE, contactTypeArray);\nmResolver.insert(Imps.Contacts.BULK_CONTENT_URI, values);\n}", "4163": "@Override\npublic void performAction(ActionEvent event) {\n// guess node connection\nDBConnectionInfo nodeInfo = preferredDataSource();\nString nodeKey = preferredDataSourceLabel(nodeInfo);\n// connect\nConnectionWizard connectWizard = new ConnectionWizard(\n                getProjectController(),\n                \"Reengineer DB Schema: Connect to Database\",\n                nodeKey,\n                nodeInfo);\nif (!connectWizard.startupAction()) {\n// canceled\nreturn;\n}\nConnection connection = connectWizard.getConnection();\nDbAdapter adapter = connectWizard.getAdapter();\nDBConnectionInfo dataSourceInfo = connectWizard.getConnectionInfo();\n// from here pass control to DbLoaderHelper, running it from a thread separate\n// from EventDispatch\nfinal DbLoaderHelper helper = new DbLoaderHelper(\n                getProjectController(),\n                connection,\n                adapter,\n                dataSourceInfo);\nThread th = new Thread(new Runnable() {\n\n            public void run() {\nhelper.execute();\nSwingUtilities.invokeLater(new Runnable() {\n\n                    public void run() {\napplication.getUndoManager().discardAllEdits();\n}\n                });\n}\n        });\nth.start();\n}", "4164": "@Override\npublic void set(JSONObject properties) {\nif (MPConfig.DEBUG) Log.d(LOGTAG, \"set \" + properties.toString());\nif (this.peopleDistinctId == null) {\nreturn; // events should be queued until identify is called\n}\ntry {\nJSONObject message = stdPeopleMessage(\"$set\", properties);\nmMessages.peopleMessage(message);\n} catch (JSONException e) {\nLog.e(LOGTAG, \"Exception setting people properties\");\n}\n}", "4166": "final synchronized void put(final IPageMapEntry entry)\n{\nif (!(entry instanceof Inspector))\n{\n// Entry has been accessed\nsession.access(entry);\n// Store entry in session\nsession.setAttribute(attributeForId(entry.getNumericId()), entry);\nsize++;\n// Evict any page(s) as need be\nsession.getApplication().getSettings().getPageMapEvictionStrategy().evict(this);\n}\n}", "4168": "private void readVP8Extended(BufferedImage destination, ImageReadParam param, long streamEnd) throws IOException {\nwhile (imageInput.getStreamPosition() < streamEnd) {\nint nextChunk = imageInput.readInt();\nlong chunkLength = imageInput.readUnsignedInt();\nlong chunkStart = imageInput.getStreamPosition();\nif (DEBUG) {\nSystem.out.printf(\"chunk: '%s'\\n\", fourCC(nextChunk));\nSystem.out.println(\"chunkLength: \" + chunkLength);\nSystem.out.println(\"chunkStart: \" + chunkStart);\n}\nswitch (nextChunk) {\ncase WebP.CHUNK_ALPH:\nint reserved = (int) imageInput.readBits(2);\nif (reserved!= 0) {\n// Spec says SHOULD be 0\nprocessWarningOccurred(String.format(\"Unexpected 'ALPH' chunk reserved value, expected 0: %d\", reserved));\n}\nint preProcessing = (int) imageInput.readBits(2);\nint filtering = (int) imageInput.readBits(2);\nint compression = (int) imageInput.readBits(2);\nif (DEBUG) {\nSystem.out.println(\"preProcessing: \" + preProcessing);\nSystem.out.println(\"filtering: \" + filtering);\nSystem.out.println(\"compression: \" + compression);\n}\nswitch (compression) {\ncase 0:\nreadUncompressedAlpha(destination.getAlphaRaster());\nbreak;\ncase 1:\nopaqueAlpha(destination.getAlphaRaster());\nreadVP8Lossless(destination.getAlphaRaster(), param);\nbreak;\ndefault:\nprocessWarningOccurred(\"Unknown WebP alpha compression: \" + compression);\nopaqueAlpha(destination.getAlphaRaster());\nbreak;\n}\nbreak;\ncase WebP.CHUNK_VP8_:\nreadVP8(RasterUtils.asByteRaster(destination.getRaster())\n.createWritableChild(0, 0, destination.getWidth(), destination.getHeight(), 0, 0, new int[]{ 0, 1, 2}), param);\nbreak;\ncase WebP.CHUNK_VP8L:\nreadVP8Lossless(RasterUtils.asByteRaster(destination.getRaster()), param);\nbreak;\ncase WebP.CHUNK_ANIM:\ncase WebP.CHUNK_ANMF:\nif (!header.containsANIM) {\nprocessWarningOccurred(\"Ignoring unsupported chunk: \" + fourCC(nextChunk));\n}\ncase WebP.CHUNK_ICCP:\n// Ignore, we already read this\ncase WebP.CHUNK_EXIF:\ncase WebP.CHUNK_XMP_:\n// Ignore, we'll read these later\nbreak;\ndefault:\nprocessWarningOccurred(\"Ignoring unexpected chunk: \" + fourCC(nextChunk));\nbreak;\n}\nimageInput.seek(chunkStart + chunkLength + (chunkLength & 1)); // Padded to even length\n}\n}", "4170": "private void createPortsTab() {\nRowLayout rowLayout = createRowLayout();\nportsTab = new Composite(tabFolder, SWT.NONE);\nportsTab.setLayout(rowLayout);\nGridLayout groupLayout = new GridLayout();\ngroupLayout.numColumns = 2;\nGroup timingGroup = new Group(portsTab, SWT.NONE);\ntimingGroup.setText(Labels.getLabel(\"options.ports.timing\"));\ntimingGroup.setLayout(groupLayout);\nGridData gridData = new GridData();\ngridData.widthHint = 50;\nLabel label;\nlabel = new Label(timingGroup, SWT.NONE);\nlabel.setText(Labels.getLabel(\"options.ports.timing.timeout\"));\nportTimeoutText = new Text(timingGroup, SWT.BORDER);\nportTimeoutText.setLayoutData(gridData);\nGridData gridData1 = new GridData();\ngridData1.horizontalSpan = 2;\nadaptTimeoutCheckbox = new Button(timingGroup, SWT.CHECK);\nadaptTimeoutCheckbox.setText(Labels.getLabel(\"options.ports.timing.adaptTimeout\"));\nadaptTimeoutCheckbox.setLayoutData(gridData1);\nRowLayout portsLayout = new RowLayout(SWT.VERTICAL);\nportsLayout.fill = true;\nportsLayout.marginHeight = 2;\nportsLayout.marginWidth = 2;\nGroup portsGroup = new Group(portsTab, SWT.NONE);\nportsGroup.setText(Labels.getLabel(\"options.ports.ports\"));\nportsGroup.setLayout(portsLayout);\nlabel = new Label(portsGroup, SWT.WRAP);\nlabel.setText(Labels.getLabel(\"options.ports.portsDescription\"));\n//label.setLayoutData(new RowData(300, SWT.DEFAULT));\nportsText = new Text(portsGroup, SWT.MULTI | SWT.BORDER | SWT.V_SCROLL);\nportsText.setLayoutData(new RowData(SWT.DEFAULT, 60));\nportsText.addModifyListener(new ModifyListener() {\n\t\t\tpublic void modifyText(ModifyEvent e) {\nvalidatePorts();\n}\n\t\t});\n}", "4175": "private void createModulesSection(FormToolkit toolkit, Composite composite, WidthGroup widthGroup) {\nmodulesSection = toolkit.createSection(composite, Section.TITLE_BAR | Section.EXPANDED | Section.TWISTIE);\nmodulesSection.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\nmodulesSection.setText(\"Modules\");\nmodulesEditor = new ListEditorComposite<String>(modulesSection, SWT.NONE);\ntoolkit.paintBordersFor(modulesEditor);\ntoolkit.adapt(modulesEditor);\nmodulesSection.setClient(modulesEditor);\nmodulesEditor.setContentProvider(new ListEditorContentProvider<String>());\nmodulesEditor.setLabelProvider(new ModulesLabelProvider(this));\nmodulesEditor.setOpenListener(new IOpenListener() {\n      public void open(OpenEvent openevent) {\nList<String> selection = modulesEditor.getSelection();\nfor(String module : selection) {\nMavenProjectFacade projectFacade = findModuleProject(module);\nif(projectFacade!=null) {\nMavenProject mavenProject = projectFacade.getMavenProject();\nOpenPomAction.openEditor(mavenProject.getGroupId(), mavenProject.getArtifactId(), mavenProject.getVersion());\n}\n}\n}\n    });\nmodulesEditor.setAddListener(new SelectionAdapter() {\n      public void widgetSelected(SelectionEvent e) {\nIEditorInput editorInput = OverviewPage.this.pomEditor.getEditorInput();\nif(editorInput instanceof FileEditorInput) {\nMavenModuleWizard wizard = new MavenModuleWizard(true);\nwizard.init(PlatformUI.getWorkbench(), new StructuredSelection(((FileEditorInput) editorInput).getFile()));\nWizardDialog dialog = new WizardDialog(Display.getCurrent().getActiveShell(), wizard);\nint res = dialog.open();\nif(res==Window.OK) {\nEList<String> moduleList = modules.getModule();\nmoduleList.add(wizard.getModuleName());\n}\n}\n}\n    });\nmodulesEditor.setRemoveListener(new SelectionAdapter() {\n      public void widgetSelected(SelectionEvent e) {\nList<String> modules = modulesEditor.getSelection();\nfor(String module : modules) {\nif(!module.equals(wizard.getModuleName())) {\nmodules.remove(module);\n}\n}\n}\n    });\n}", "4177": "public void activate()\nthrows Exception\n{\ndependency1.type();\ndependency2.type();\ndependency3.type();\nUnitOfWork uow = uowf.newUnitOfWork();\ntry\n            {\nfor( Object[] handlingEvent : HANDLING_EVENTS )\n{\nDate completionTime = (Date) handlingEvent[ 0 ];\nDate registrationTime = (Date) handlingEvent[ 1 ];\nHandlingEvent.Type type = (HandlingEvent.Type) handlingEvent[ 2 ];\nLocation location = findLocation( (String) handlingEvent[ 3 ] );\nCarrierMovement carrierMovement = findCarrierMovement( (CarrierMovementId) handlingEvent[ 4 ] );\nCargo cargo = findCargo( (TrackingId) handlingEvent[ 5 ] );\ncreateHandlingEvent(\n                        uow, completionTime, registrationTime, type, location, carrierMovement, cargo\n                    );\n}\n}\nfinally\n            {\nuow.complete();\n}\n}", "4178": "@Override\nprotected void computeResult() {\nObject[] elements = getSelectedElements();\nif (elements.length == 1 && elements[0] instanceof ResourceItem) {\nResourceItem item = (ResourceItem)elements[0];\nmCurrentResource = mResourceType.getXmlString(item);\n}\n}", "4180": "static void showVersion()\n{\nInputStream resourceAsStream;\ntry\n        {\nProperties properties = new Properties();\nresourceAsStream = MavenCli.class.getClassLoader()\n.getResourceAsStream( \"META-INF/maven/org.apache.maven/maven-core/pom.properties\" );\nif ( resourceAsStream!= null )\n{\nproperties.load( resourceAsStream );\nif ( properties.getProperty( \"builtOn\" )!= null )\n{\nSystem.out.println( \"Maven version: \"\n+ properties.getProperty( \"version\", \"unknown\" ) + \" built on \"\n+ properties.getProperty( \"builtOn\" ) );\n}\nelse\n                {\nSystem.out.println( \"Maven version: \"\n+ properties.getProperty( \"version\", \"unknown\" ) );\n}\n}\nelse\n            {\nSystem.out.println( \"Maven version: unknown\" );\n}\nSystem.out.println( \"Java version: \"\n+ System.getProperty( \"java.version\", \"<unknown java version>\" ) );\nSystem.out.println( \"OS name: \\\"\" + Os.OS_NAME + \"\\\" version: \\\"\" + Os.OS_VERSION\n+ \"\\\" arch: \\\"\" + Os.OS_ARCH + \"\\\"\" );\n}\ncatch ( IOException e )\n{\nSystem.err.println( \"Unable determine version from JAR file: \" + e.getMessage() );\n}\n}", "4186": "private void storeTrainedModelAndDefinition(TrainedModelConfig trainedModelConfig,\n                                                ActionListener<Boolean> listener) {\nTrainedModelDefinitionDoc trainedModelDefinitionDoc;\ntry {\ntrainedModelDefinitionDoc = new TrainedModelDefinitionDoc.Builder()\n.setDocNum(0)\n.setModelId(trainedModelConfig.getModelId())\n.setCompressedString(trainedModelConfig.getCompressedDefinition())\n.setCompressionVersion(TrainedModelConfig.CURRENT_DEFINITION_COMPRESSION_VERSION)\n.setDefinitionLength(trainedModelConfig.getDefinitionLength())\n.setTotalDefinitionLength(trainedModelConfig.getTotalDefinitionLength())\n.build();\n} catch (IOException ex) {\nlistener.onFailure(ExceptionsHelper.serverError(\n                \"Unexpected IOException while serializing definition for storage for model [\" + trainedModelConfig.getModelId() + \"]\",\n                ex));\nreturn;\n}\nBulkRequest bulkRequest = client.prepareBulk(InferenceIndexConstants.LATEST_INDEX_NAME)\n.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n.add(createRequest(trainedModelConfig.getModelId(), trainedModelConfig))\n.add(createRequest(TrainedModelDefinitionDoc.docId(trainedModelConfig.getModelId(), 0), trainedModelDefinitionDoc))\n.request();\nActionListener<Boolean> wrappedListener = ActionListener.wrap(\n            listener::onResponse,\n            e -> {\nif (ExceptionsHelper.unwrapCause(e) instanceof VersionConflictEngineException) {\nlistener.onFailure(new ResourceAlreadyExistsException(\n                        Messages.getMessage(Messages.INFERENCE_TRAINED_MODEL_EXISTS, trainedModelConfig.getModelId())));\n} else {\nlistener.onFailure(\n                        new ElasticsearchStatusException(Messages.INFERENCE_FAILED_TO_STORE_MODEL,\n                            RestStatus.INTERNAL_SERVER_ERROR,\n                            e,\n                            trainedModelConfig.getModelId()));\n}\n}\n        );\nActionListener<BulkResponse> bulkResponseActionListener = ActionListener.wrap(\n            r -> {\nassert r.getItems().length == 2;\nif (r.getItems()[0].isFailed()) {\nlogger.error(new ParameterizedMessage(\n                            \"[{}] failed to store trained model config for inference\",\n                            trainedModelConfig.getModelId()),\n                        r.getItems()[0].getFailure().getCause());\nwrappedListener.onFailure(r.getItems()[0].getFailure().getCause());\nreturn;\n}\nif (r.getItems()[1].isFailed()) {\nlogger.error(new ParameterizedMessage(\n                            \"[{}] failed to store trained model definition for inference\",\n                            trainedModelConfig.getModelId()),\n                        r.getItems()[1].getFailure().getCause());\nwrappedListener.onFailure(r.getItems()[1].getFailure().getCause());\nreturn;\n}\nwrappedListener.onResponse(true);\n},\n            wrappedListener::onFailure\n        );\nexecuteAsyncWithOrigin(client, ML_ORIGIN, BulkAction.INSTANCE, bulkRequest, bulkResponseActionListener);\n}", "4187": "@PaxWebConfiguration\nprivate void performConfiguration() {\ntry {\n// Configure chained PropertyResolver to get properties from Config Admin, Bundle Context, Meta Type\n// information (in such order).\n// Properties as map will also be available in proper order\nMap<String, String> allProperties = new HashMap<>(System.getenv());\nallProperties.putAll(Utils.toMap(System.getProperties()));\nMetaTypePropertyResolver defaultResolver = new MetaTypePropertyResolver();\nallProperties.putAll(Utils.toMap(defaultResolver.getProperties()));\n// can't get all bundle context properties as map...\nPropertyResolver tmpResolver = new BundleContextPropertyResolver(bundleContext, defaultResolver);\nPropertyResolver resolver = this.configuration!= null? new DictionaryPropertyResolver(this.configuration, tmpResolver) : tmpResolver;\nallProperties.putAll(Utils.toMap(this.configuration));\n// full configuration with all required properties. That's all that is needed down the stream\nfinal Configuration configuration = ConfigurationBuilder.getConfiguration(resolver, allProperties);\nwebElementEventDispatcher = new WebElementEventDispatcher(bundleContext, configuration);\n// global, single representation of web server state. It's used\n//  - in all bundle-scoped instances of HttpServiceEnabled\n//  - also to reflect Whiteboard registrations (through pax-web-extender-whiteboard)\nfinal ServerModel serverModel = new ServerModel(runtimeExecutor, registrationThreadId);\n// create a controller object to operate on any supported web server\nserverController = serverControllerFactory.createServerController(configuration);\n// immediately add current ServerListeners.\nserverListeners.forEach(listener -> serverController.addListener(listener));\n// first step is to configure the server without actually starting it\nLOG.info(\"Configuring server controller {}\", serverController.getClass().getName());\nserverController.configure();\nLOG.info(\"Starting server controller {}\", serverController.getClass().getName());\nserverController.start();\n// this is where org.osgi.service.http.HttpService bundle-scoped service is registered in OSGi\n// this is the most fundamental operation related to Http Service specification\nDictionary<String, Object> props = determineServiceProperties(this.configuration, configuration);\nServiceFactory<StoppableHttpService> factory = new StoppableHttpServiceFactory() {\n\t\t\t\t@Override\nStoppableHttpService createService(Bundle bundle) {\nHttpServiceEnabled enabledService =\n\t\t\t\t\t\t\tnew HttpServiceEnabled(bundle, serverController, serverModel,\n\t\t\t\t\t\t\t\t\twebElementEventDispatcher, configuration);\nreturn new HttpServiceProxy(bundle, enabledService);\n}\n\t\t\t};\n// this registration is performed inside configuration thread. It may invoke service listeners\n// awaiting HttpService/WebContainer to start registering web elements, which call configuration\n// thread again - this time without waiting (same thread)\n// but this caused a problem in pax-web-extender-whiteboard which has it's own lock.\n// that's why pax-web-extender-whiteboard should not get the lock after its service listener is called\nLOG.info(\"Registering HttpService factory\");\nhttpServiceFactoryReg = bundleContext.registerService(HTTPSERVICE_REGISTRATION_NAMES, factory, props);\n// ManagedServiceFactory for org.ops4j.pax.web.context factory PID\n// we need registered WebContainer for this MSF to work\n//\t\t\tcreateManagedServiceFactory(bundleContext);\n} catch (Throwable t) {\nLOG.error(\"Unable to start Pax Web server: {}\", t.getMessage(), t);\n}\n}", "4191": "public void testInstanceQuery() throws Exception {\nfinal String[] PROJECTION = new String[] {\n                Instances.TITLE,                 // 0\nInstances.EVENT_LOCATION,        // 1\nInstances.ALL_DAY,               // 2\nInstances.COLOR,                 // 3\nInstances.EVENT_TIMEZONE,        // 4\nInstances.EVENT_ID,              // 5\nInstances.BEGIN,                 // 6\nInstances.END,                   // 7\nInstances._ID,                   // 8\nInstances.START_DAY,             // 9\nInstances.END_DAY,               // 10\nInstances.START_MINUTE,          // 11\nInstances.END_MINUTE,            // 12\nInstances.HAS_ALARM,             // 13\nInstances.RRULE,                 // 14\nInstances.RDATE,                 // 15\nInstances.SELF_ATTENDEE_STATUS,  // 16\nEvents.ORGANIZER,                // 17\nEvents.GUESTS_CAN_MODIFY,        // 18\n        };\nString orderBy = Instances.SORT_CALENDAR_VIEW;\nString where = Instances.SELF_ATTENDEE_STATUS + \"!=\" + Calendar.Attendees.ATTENDEE_STATUS_DECLINED;\nlong start = 0;\nlong end = 0;\nCursor c = Instances.query(mResolver, PROJECTION,\n                start - DateUtils.DAY_IN_MILLIS, end + DateUtils.DAY_IN_MILLIS, where, orderBy);\nassertEquals(0, c.getPosition());\nassertEquals(0, Instances.getFirstVisiblePosition(c));\nassertEquals(1, Instances.getCount(c));\nassertEquals(Instances.getItem(0), c.getPosition());\nassertEquals(Instances.getItem(0), c.getFirst();\nassertEquals(0, Instances.getLastVisiblePosition(c));\nassertEquals(1, Instances.getCount(c));\nassertEquals(Instances.getItem(1), c.getPosition());\nassertEquals(Instances.getItem(1), c.getFirst();\nassertEquals(1, Instances.getLastVisiblePosition(c));\nassertEquals(2, Instances.getCount(c));\nassertEquals(Instances.getItem(2), c.getPosition());\nassertEquals(Instances.getItem(2), c.getFirst();\nassertEquals(2, Instances.getLastVisiblePosition(c));\n}", "4195": "private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders,\n                                            TarArchiveEntry entry) {\nif (entry.getSize() > TarConstants.MAXSIZE) {\npaxHeaders.put(\"size\", String.valueOf(entry.getSize()));\n}\nif (entry.getGroupId() > TarConstants.MAXID) {\npaxHeaders.put(\"gid\", String.valueOf(entry.getGroupId()));\n}\nfinal long mtime =  entry.getModTime().getTime() / 1000;\nif (mtime < 0 || mtime > TarConstants.MAXSIZE) {\npaxHeaders.put(\"mtime\", String.valueOf(mtime));\n}\nif (entry.getUserId() > TarConstants.MAXID) {\npaxHeaders.put(\"uid\", String.valueOf(entry.getUserId()));\n}\nif (entry.getMode() > TarConstants.MAXID) {\nthrow new RuntimeException(\"mode '\" + entry.getMode()\n+ \"' is too big ( > \"\n+ TarConstants.MAXID + \" bytes)\");\n}\nif (entry.getDevMajor() > TarConstants.MAXID) {\npaxHeaders.put(\"devmajor\", String.valueOf(entry.getDevMajor()));\n}\nif (entry.getDevMinor() > TarConstants.MAXID) {\npaxHeaders.put(\"devminor\", String.valueOf(entry.getDevMinor()));\n}\n}", "4196": "public void invite(FPlayer fplayer) {\nthis.invites.add(fplayer.getName().toLowerCase());\n}", "4198": "private void addValue(Document doc, InternalValue value, Name name) throws RepositoryException {\nString fieldName = name.getLocalName();\ntry {\nfieldName = resolver.getJCRName(name);\n} catch (NamespaceException e) {\n// will never happen\n}\nswitch (value.getType()) {\ncase PropertyType.BINARY:\nif (isIndexed(name)) {\naddBinaryValue(doc, fieldName, value.getBLOBFileValue());\n}\nbreak;\ncase PropertyType.BOOLEAN:\nif (isIndexed(name)) {\naddBooleanValue(doc, fieldName, Boolean.valueOf(value.getBoolean()));\n}\nbreak;\ncase PropertyType.DATE:\nif (isIndexed(name)) {\naddCalendarValue(doc, fieldName, value.getDate());\n}\nbreak;\ncase PropertyType.DOUBLE:\nif (isIndexed(name)) {\naddDoubleValue(doc, fieldName, new Double(value.getDouble()));\n}\nbreak;\ncase PropertyType.LONG:\nif (isIndexed(name)) {\naddLongValue(doc, fieldName, new Long(value.getLong()));\n}\nbreak;\ncase PropertyType.REFERENCE:\nif (isIndexed(name)) {\naddReferenceValue(doc, fieldName, value.getUUID(), false);\n}\nbreak;\ncase PropertyType.WEAKREFERENCE:\nif (isIndexed(name)) {\naddReferenceValue(doc, fieldName, value.getUUID(), true);\n}\nbreak;\ncase PropertyType.PATH:\nif (isIndexed(name)) {\naddPathValue(doc, fieldName, value.getPath());\n}\nbreak;\ncase PropertyType.URI:\nif (isIndexed(name)) {\naddURIValue(doc, fieldName, value.getURI());\n}\nbreak;\ncase PropertyType.STRING:\nif (isIndexed(name)) {\n// never fulltext index jcr:uuid String\nif (name.equals(NameConstants.JCR_UUID)) {\naddStringValue(doc, fieldName, value.getString(),\n                                false, false, DEFAULT_BOOST);\n} else {\naddStringValue(doc, fieldName, value.getString(),\n                                true, isIncludedInNodeIndex(name),\n                                getPropertyBoost(name), useInExcerpt(name));\n}\n}\nbreak;\ncase PropertyType.NAME:\n// jcr:primaryType and jcr:mixinTypes are required for correct\n// node type resolution in queries\nif (name.equals(NameConstants.JCR_PRIMARYTYPE)\n|| name.equals(NameConstants.JCR_MIXINTYPES)\n|| isIndexed(name)) {\naddNameValue(doc, fieldName, value.getQName());\n}\nbreak;\ncase PropertyType.DECIMAL:\ncase PropertyType.NUMERIC:\ndefault:\nthrow new IllegalArgumentException(\"illegal internal value type: \" + value.getType());\n}\n// add length\nif (indexFormatVersion.getVersion() >= IndexFormatVersion.V3.getVersion()) {\naddLength(doc, fieldName, value);\n}\n}", "4200": "void parseTestResults(List<String> results) throws MojoExecutionException, MojoFailureException {\nFailureScanner failureScanner = new FailureScanner(ignoreResultFailures);\nint totalFailureCount = 0;\nboolean failed = false;\nfor (String file : results) {\ntry {\nif (failureScanner.hasTestFailed(new File(file))) {\ntotalFailureCount += failureScanner.getFailureCount();\nfailed = true;\n}\n} catch (IOException e) {\nthrow new MojoExecutionException(e.getMessage());\n}\n}\ngetLog().info(\" \");\ngetLog().info(\"Test Results:\");\ngetLog().info(\" \");\ngetLog().info(\"Tests Run: \" + results.size() + \", Failures: \" + totalFailureCount);\ngetLog().info(\" \");\nif (failed) {\nthrow new MojoFailureException(\"There were \" + totalFailureCount + \" test failures.  See the JMeter logs for details.\");\n}\n}", "4207": "@Test\nvoid testPOSModelSerializationMaxent() throws IOException {\nPOSModel posModel = POSTaggerMETest.trainPOSModel(ModelType.MAXENT);\nByteArrayOutputStream out = new ByteArrayOutputStream();\ntry {\nposModel.serialize(out);\n} finally {\nout.close();\n}\nPOSModel recreatedPosModel = new POSModel(new ByteArrayInputStream(out.toByteArray()));\nassertThat(recreatedPosModel.getModelType(), is(ModelType.MAXENT));\n}", "4209": "@Override\npublic void init(Enunciate enunciate) throws EnunciateException {\nsuper.init(enunciate);\nif (!isDisabled()) {\ncheckCSharpCompilerExists();\n}\n}", "4211": "@Override\npublic void visit(BaseMemberExpression that) {\nif (that.getErrors()!= null &&!that.getErrors().isEmpty()) {\n//Don't even bother processing a node with errors\nreturn;\n}\nDeclaration decl = that.getDeclaration();\nString name = decl.getName();\nString pkgName = decl.getUnit().getPackage().getQualifiedNameString();\n// map Ceylon true/false/null directly to JS true/false/null\nif (\"ceylon.language\".equals(pkgName)) {\nif (\"true\".equals(name) || \"false\".equals(name) || \"null\".equals(name)) {\nout(name);\nreturn;\n}\n}\nif (that.getSupertypeQualifier() == null) {\nqualify(that, decl);\n} else {\nClassOrInterface parent = (ClassOrInterface)decl.getContainer();\nout(\"this.getT$all$()['\", parent.getQualifiedNameString(), \"'].\");\nif (prototypeStyle) {\nout(\"$$.prototype.\");\n} else {\nout(\"this.getT$all$()['\", parent.getQualifiedNameString(), \"'].\");\n}\n}\nif (isNative(decl)) {\nout(decl.getName());\n} else if (accessDirectly(decl)) {\nout(names.name(decl));\n} else {\nout(names.getter(decl));\nout(\"()\");\n}\n}", "4213": "@Override\npublic void bsp(BSPPeer<VectorWritable, DoubleWritable, VectorWritable, VectorWritable, VectorWritable, VectorWritable, DoubleWritable, VectorWritable> peer) throws IOException, SyncException, InterruptedException {\nwhile (true) {\ngetTheta(peer);\n// first superstep : calculate cost function in parallel\ndouble localCost = 0d;\nint numRead = 0;\n// read an input\nKeyValuePair<VectorWritable, DoubleWritable> kvp;\nwhile ((kvp = peer.readNext())!= null) {\n// calculate cost for given input\ndouble y = kvp.getValue().get();\nDoubleVector x = kvp.getKey().getVector();\ndouble costForX = calculateCostForItem(y, x, theta);\n// adds to local cost\nlocalCost += costForX;\nnumRead++;\n}\n// cost is sent and aggregated by each\ndouble totalCost = localCost;\nfor (String peerName : peer.getAllPeerNames()) {\npeer.send(peerName, new VectorWritable(new DenseDoubleVector(new double[]{localCost, numRead})));\n}\npeer.sync();\n// second superstep : aggregate cost calculation\nVectorWritable costResult;\nwhile ((costResult = peer.getCurrentMessage())!= null) {\ntotalCost += costResult.getVector().get(0);\nnumRead += costResult.getVector().get(1);\n}\ntotalCost /= numRead;\nif (log.isInfoEnabled()) {\nlog.info(\"cost is \" + totalCost);\n}\npeer.sync();\npeer.reopenInput();\ndouble[] thetaDelta = new double[theta.getLength()];\n// third superstep : calculate partial derivatives' deltas in parallel\nwhile ((kvp = peer.readNext())!= null) {\nDoubleVector x = kvp.getKey().getVector();\ndouble y = kvp.getValue().get();\ndouble difference = applyHypothesis(theta, x) - y;\nfor (int j = 0; j < theta.getLength(); j++) {\nthetaDelta[j] += difference * x.get(j);\n}\n}\n// send thetaDelta to the each peer\nfor (String peerName : peer.getAllPeerNames()) {\npeer.send(peerName, new VectorWritable(new DenseDoubleVector(thetaDelta)));\n}\npeer.sync();\n// fourth superstep : aggregate partial derivatives\nVectorWritable thetaDeltaSlice;\nwhile ((thetaDeltaSlice = peer.getCurrentMessage())!= null) {\ndouble[] newTheta = new double[theta.getLength()];\nfor (int j = 0; j < theta.getLength(); j++) {\nnewTheta[j] += thetaDeltaSlice.getVector().get(j);\n}\nfor (int j = 0; j < theta.getLength(); j++) {\nnewTheta[j] = theta.get(j) - newTheta[j] * peer.getConfiguration().getFloat(ALPHA, 0.3f);\n}\ntheta = new DenseDoubleVector(newTheta);\nif (log.isInfoEnabled()) {\nlog.info(\"new theta for cost \" + totalCost + \" is \" + theta.toArray().toString());\n}\n// master writes down the output\nif (master) {\npeer.write(new VectorWritable(theta), new DoubleWritable(totalCost));\n}\n}\npeer.sync();\n// eventually break execution!?\nif (totalCost == 0) {\nbreak;\n}\n}\n}", "4214": "private static List<Row> fetchRows(List<ReadCommand> commands, ConsistencyLevel consistency_level) throws IOException, UnavailableException, TimeoutException\n{\nList<ReadCallback<Row>> readCallbacks = new ArrayList<ReadCallback<Row>>();\nList<List<InetAddress>> commandEndpoints = new ArrayList<List<InetAddress>>();\nList<Row> rows = new ArrayList<Row>();\nSet<ReadCommand> repairs = new HashSet<ReadCommand>();\n// send out read requests\nfor (ReadCommand command: commands)\n{\nassert!command.isDigestQuery();\nList<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.table, command.key);\nDatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getLocalAddress(), endpoints);\nReadResponseResolver resolver = new ReadResponseResolver(command.table, command.key);\nReadCallback<Row> handler = getReadCallback(resolver, command.table, consistency_level);\nhandler.assureSufficientLiveNodes(endpoints);\n// if we're not going to read repair, cut the endpoints list down to the ones required to satisfy ConsistencyLevel\nif (randomlyReadRepair(command))\n{\nif (endpoints.size() > handler.blockfor)\nrepairs.add(command);\n}\nelse\n            {\nendpoints = endpoints.subList(0, handler.blockfor);\n}\n// The data-request message is sent to dataPoint, the node that will actually get\n// the data for us. The other replicas are only sent a digest query.\nReadCommand digestCommand = null;\nif (endpoints.size() > 1)\n{\ndigestCommand = command.copy();\ndigestCommand.setDigestQuery(true);\n}\nInetAddress dataPoint = endpoints.get(0);\nif (dataPoint.equals(FBUtilities.getLocalAddress()))\n{\nif (logger.isDebugEnabled())\nlogger.debug(\"reading data for \" + command + \" locally\");\nStageManager.getStage(Stage.READ).execute(new LocalReadRunnable(command, handler));\n}\nelse\n            {\nMessage message = command.getMessage(Gossiper.instance.getVersion(dataPoint));\nif (logger.isDebugEnabled())\nlogger.debug(\"reading data for \" + command + \" from \" + dataPoint);\nMessagingService.instance().sendRR(message, dataPoint, handler);\n}\nfor (InetAddress digestPoint : endpoints.subList(1, endpoints.size()))\n{\nif (digestPoint.equals(FBUtilities.getLocalAddress()))\n{\nif (logger.isDebugEnabled())\nlogger.debug(\"reading digest for \" + command + \" locally\");\nStageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));\n}\nelse\n                {\nMessage digestMessage = digestCommand.getMessage(Gossiper.instance.getVersion(digestPoint));\nif (logger.isDebugEnabled())\nlogger.debug(\"reading digest for \" + command + \" from \" + digestPoint);\nMessagingService.instance().sendRR(digestMessage, digestPoint, handler);\n}\n}\nreadCallbacks.add(handler);\ncommandEndpoints.add(endpoints);\n}\n// read results and make a second pass for any digest mismatches\nList<RepairCallback<Row>> repairResponseHandlers = null;\nfor (int i = 0; i < commands.size(); i++)\n{\nReadCallback<Row> readCallback = readCallbacks.get(i);\nRow row;\nReadCommand command = commands.get(i);\nList<InetAddress> endpoints = commandEndpoints.get(i);\ntry\n            {\nlong startTime2 = System.currentTimeMillis();\nrow = readCallback.get(); // CL.ONE is special cased here to ignore digests even if some have arrived\nif (row!= null)\nrows.add(row);\nif (logger.isDebugEnabled())\nlogger.debug(\"Read: \" + (System.currentTimeMillis() - startTime2) + \" ms.\");\nif (repairs.contains(command))\nrepairExecutor.schedule(new RepairRunner(readCallback.resolver, command, endpoints), DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);\n}\ncatch (DigestMismatchException ex)\n{\nif (logger.isDebugEnabled())\nlogger.debug(\"Digest mismatch: \" + ex.getMessage() + \", \" + ex.getCause());\n}\ncatch (RuntimeException ex)\n{\nif (logger.isDebugEnabled())\nlogger.", "4215": "public static void writeStaticFuncs(ClassDecl classDecl, CGenerator cgen) throws IOException {\nfor (FunctionDecl decl : classDecl.getFunctions()) {\nif (!decl.isStatic() || (decl.isExtern() && decl.getExternName().length() > 0)) {\ncontinue;\n}\ncgen.current.nl();\nFunctionDeclWriter.writeFuncPrototype(decl, cgen);\ncgen.current.openBlock();\ndecl.getBody().accept(cgen);\ncgen.current.closeSpacedBlock();\n}\n}", "4217": "private void registerSagaBeanDefinitions(Configurer configurer, BeanDefinitionRegistry registry) {\nString[] sagas = beanFactory.getBeanNamesForAnnotation(Saga.class);\nfor (String saga : sagas) {\nSaga sagaAnnotation = beanFactory.findAnnotationOnBean(saga, Saga.class);\nSagaConfiguration<?> sagaConfiguration = SagaConfiguration.subscribingSagaManager(beanFactory.getType(saga));\nif (!\"\".equals(sagaAnnotation.resourceInjector())) {\nsagaConfiguration.configureResourceInjector(c -> beanFactory.getBean(sagaAnnotation.resourceInjector(), ResourceInjector.class));\n}\nconfigurer.registerModule(sagaConfiguration);\n}\n}", "4219": "public void writeSchemas()\n{\nfor (Schema schema : schemaMap.values())\n{\nSystem.out.println(schema.getPackageName() + \" (\" + schema.getNamespaces() + \")\");\nSystem.out.println(schema.getTypeReferences());\nwritePackageInfo(schema);\n}\n}", "4225": "public void updateDialog() {\n// Interval\n// Checking before setting because this causes infinite recursion\n// in afterTextWatcher\nfinal String intervalStr = Integer.toString(mInterval.getText().toString())) {\nmInterval.setText(intervalStr);\n}\nmFreqSpinner.setSelection(mModel.freq + 1); // FREQ_* starts at -1\nmWeekGroup.setVisibility(mModel.freq == Model.FREQ_WEEKLY? View.VISIBLE : View.GONE);\nmWeekGroup2.setVisibility(mModel.freq == Model.FREQ_WEEKLY? View.VISIBLE : View.GONE);\nmMonthGroup.setVisibility(mModel.freq == Model.FREQ_MONTHLY? View.VISIBLE : View.GONE);\nif (mModel.freq == Model.FREQ_NONE) {\nmIntervalGroup.setVisibility(View.INVISIBLE);\nmEndGroup.setVisibility(View.INVISIBLE);\n} else {\nmIntervalGroup.setVisibility(View.VISIBLE);\nmEndGroup.setVisibility(View.VISIBLE);\nswitch (mModel.freq) {\ncase Model.FREQ_DAILY:\nupdateIntervalText(R.string.recurrence_interval_daily);\nbreak;\ncase Model.FREQ_WEEKLY:\nupdateIntervalText(R.string.recurrence_interval_weekly);\nint count = 0;\nfor (int i = 0; i < 7; i++) {\nmWeekByDayButtons[i].setChecked(mModel.weeklyByDayOfWeek[i]);\nif (mModel.weeklyByDayOfWeek[i]) {\ncount++;\nmWeekByDayButtons[i].setTextColor(DAY_OF_WEEK_CHECKED_TEXT_COLOR);\n} else {\nmWeekByDayButtons[i].setTextColor(DAY_OF_WEEK_UNCHECKED_TEXT_COLOR);\n}\n}\nif (count == 0) {\nmModel.weeklyByDayOfWeek[mTime.weekDay] = true;\nmWeekByDayButtons[mTime.weekDay].setChecked(true);\nmWeekByDayButtons[mTime.weekDay]\n.setTextColor(DAY_OF_WEEK_CHECKED_TEXT_COLOR);\n}\nbreak;\ncase Model.FREQ_MONTHLY:\nupdateIntervalText(R.string.recurrence_interval_monthly);\nif (mModel.monthlyRepeat == Model.MONTHLY_BY_DATE) {\nmMonthRepeatByRadioGroup.check(R.id.repeatMonthlyByNthDayOfMonth);\n} else if (mModel.monthlyRepeat == Model.MONTHLY_BY_NTH_DAY_OF_WEEK) {\nmMonthRepeatByRadioGroup.check(R.id.repeatMonthlyByNthDayOfTheWeek);\n}\nif (mMonthRepeatByDayOfWeekStr == null) {\nif (mModel.monthlyByNthDayOfWeek == 0) {\nmModel.monthlyByNthDayOfWeek = (mTime.monthDay + 6) / 7;\nmModel.monthlyByDayOfWeek = mTime.weekDay;\n}\nmMonthRepeatByDayOfWeekStr = mResources.getString(\n                                R.string.recurrence_month_pattern_by_day_of_week,\n                                mOrdinalArray[mModel.monthlyByNthDayOfWeek - 1],\n                                mDayOfWeekString[mModel.monthlyByDayOfWeek]);\nmMonthRepeatByNthDayOfWeek.setText(mMonthRepeatByDayOfWeekStr);\n}\nbreak;\ncase Model.FREQ_YEARLY:\nupdateIntervalText(R.string.recurrence_interval_yearly);\nbreak;\n}\nmEndSpinner.setSelection(mModel.end);\nif (mModel.end == Model.END_BY_DATE) {\nfinal String dateStr = DateUtils.formatDateTime(getActivity(),\n                        mModel.endDate.toMillis(false), DateUtils.FORMAT_NUMERIC_DATE);\nfinal String endDateString = mResources.getString(R.string.recurrence_end_date,\n                        dateStr);\nsetEndSpinnerEndDateStr(endDateString);\n} else {\nsetEndSpinnerEndDateStr(mEndDateLabel);\nif (mModel.end == Model.END_BY_COUNT) {\n// Checking before setting because this causes infinite\n// recursion\n// in afterTextWatcher\nfinal String countStr = Integer.toString(mModel.endCount);\nif (!countStr.equals(mEndCount.getText().toString())) {\nmEndCount.", "4228": "@Override\npublic void load() {\nsuper.load();\nif (get(\"useSMPAPI\")!= null) {\nset(\"useServerMod\", get(\"useSMPAPI\"));\noptions.remove(\"useSMPAPI\");\nSystem.out.println(\"[INFO] useSMPAPI is now called useServerMod!\");\n}\nif (get(\"msgFormat\").equals(\"\")) {\nset(\"msgFormat\", defaultOptions.getProperty(\"msgFormat\"));\n}\nif (get(\"msgTitleFormat\").equals(\"\")) {\nset(\"msgTitleFormat\", defaultOptions.getProperty(\"msgTitleFormat\"));\n}\nif (getInt(\"internalPort\") == getInt(\"port\")) {\nSystem.out.println(\"OH NO! Your 'internalPort' and 'port' properties are the same! Edit simpleserver.properties and change them to different values. 'port' is recommended to be 25565, the default port of minecraft, and will be the port you actually connect to.\");\nSystem.out.println(\"Press enter to continue...\");\nScanner in = new Scanner(System.in);\nin.nextLine();\nSystem.exit(0);\n}\n}", "4230": "private void readDecimal(int start, int i) throws RepositoryException {\nchar[] chars = statementChars;\nint[] types = characterTypes;\nwhile (true) {\nint t = types[i];\nif (t!= CHAR_DECIMAL && t!= CHAR_VALUE) {\nbreak;\n}\ni++;\n}\nif (chars[i] == 'E') {\ni++;\nif (chars[i] == '+' || chars[i] == '-') {\ni++;\n}\nif (types[i]!= CHAR_VALUE) {\nthrow getSyntaxError();\n}\nwhile (types[++i] == CHAR_VALUE) {\n// go until the first non-number\n}\n}\nparseIndex = i;\nString sub = statement.substring(start, i);\nBigDecimal bd;\ntry {\nbd = new BigDecimal(sub);\n} catch (NumberFormatException e) {\nthrow new InvalidQueryException(\"Data conversion error converting \" + sub + \" to BigDecimal: \" + e);\n}\ncheckLiterals(false);\ncurrentValue = valueFactory.createValue(bd);\ncurrentTokenType = VALUE;\n}", "4232": "public void started() {\ncontrolPanel = new ControlPanel(gameView);\ngridPanel = new GridPanel(client, gameView, controlPanel, chatPanel);\nMeepleLayer meepleLayer = new MeepleLayer(gridPanel, gc);\nTilePlacementLayer tilePlacementLayer = new TilePlacementLayer(gridPanel, gc);\nTileLayer tileLayer = new TileLayer(gridPanel, gc);\ntileLayer.setTilePlacmentLayer(tilePlacementLayer);\nfarmHintLayer = new FarmHintsLayer(gridPanel, gc);\nCapabilitiesState capabs = game.getState().getCapabilities();\ngridPanel.addLayer(tilePlacementLayer, false);\ngridPanel.addLayer(tileLayer);\ngridPanel.addLayer(farmHintLayer, false);\nif (capabs.contains(CastleCapability.class)) {\ngridPanel.addLayer(new CastleLayer(gridPanel, gc));\n}\nif (capabs.contains(TowerCapability.class)) {\ngridPanel.addLayer(new TowerLayer(gridPanel, gc));\n}\ngridPanel.addLayer(meepleLayer);\nif (capabs.contains(LittleBuildingsCapability.class) ||\ncapabs.contains(TunnelCapability.class) ) {\ngridPanel.addLayer(new TokenLayer(gridPanel, gc));\n}\nif (capabs.contains(BridgeCapability.class)) {\nBridgeLayer bridgeLayer = new BridgeLayer(gridPanel, gc);\nbridgeLayer.setMeepleLayer(meepleLayer);\ngridPanel.addLayer(bridgeLayer);\n}\nif (capabs.contains(GoldminesCapability.class)) {\ngridPanel.addLayer(new GoldLayer(gridPanel, gc));\n}\ngridPanel.addLayer(new FollowerAreaLayer(gridPanel, gc, meepleLayer), false);\ngridPanel.addLayer(new FeatureAreaLayer(gridPanel, gc), false);\ngridPanel.addLayer(new TileActionLayer(gridPanel, gc), false);\nif (capabs.contains(LittleBuildingsCapability.class)) {\ngridPanel.addLayer(new LittleBuildingActionLayer(gridPanel, gc), false);\n}\ngridPanel.addLayer(new AnimationLayer(gridPanel, gc));\nplacementHistoryLayer = new PlacementHistory(gridPanel, gc);\ngridPanel.addLayer(placementHistoryLayer, false);\nadd(gridPanel);\n}", "4236": "private StreamBlock pollPersistentDeque(boolean actuallyPoll) {\nBBContainer cont = null;\ntry {\ncont = m_persistentDeque.poll();\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\nif (cont == null) {\nreturn null;\n} else {\n//If the container is not null, unpack it.\nfinal BBContainer fcont = cont;\nlong uso = cont.b.getLong();\nByteBuffer buf = cont.b.slice();\n//Pass the stream block a subset of the bytes, provide\n//a container that discards the original returned by the persistent deque\nStreamBlock block = new StreamBlock( new BBContainer(buf, 0L) {\n                    @Override\npublic void discard() {\nfcont.discard();\n}\n                },\n                uso,\n                true);\n//Optionally store a reference to the block in the in memory deque\nif (!actuallyPoll) {\nm_memoryDeque.offer(block);\n}\nreturn block;\n}\n}", "4237": "@Override\npublic void init()\n{\nif (this.inited()) return;\nif (this.supportsPusher())\n{\nthis.getPusher().init();\n}\nthis.initLoadAllFromRemote();\n// this.syncAll();\nname2instance.put(this.getName(), this);\n}", "4239": "public void updateEpisodeDetails(DataResponse<Episode> response,\n\t\t\tEpisode episode, Context context) {\nresponse.value = episode;\nonFinish(response);\n}", "4243": "private void attack(Player player, HumanNPC npc) {\nplayer.sendMessage(\"Guardin'!\");\nnpc.sendMessage(\"You're not in the \" + npc.getName() + \" list!\");\n}", "4244": "private void createButtons( final Composite buttonsComp ) {\nString sAdd = UITexts.cabalImplsBlock_btnAdd;\nbtnAdd = SWTUtil.createPushButton( buttonsComp, sAdd );\nbtnAdd.addListener( SWT.Selection, new Listener() {\n      public void handleEvent( final Event evt ) {\naddCabalImplementation();\n}\n    } );\nString sEdit = UITexts.implementationsBlock_btnEdit;\nbtnEdit = SWTUtil.createPushButton( buttonsComp, sEdit );\nbtnEdit.addListener( SWT.Selection, new Listener() {\n      public void handleEvent( final Event evt ) {\neditCabalImplementation();\n}\n    } );\nString sRemove = UITexts.cabalImplsBlock_btnRemove;\nbtnRemove = SWTUtil.createPushButton( buttonsComp, sRemove );\nbtnRemove.addListener( SWT.Selection, new Listener() {\n      public void handleEvent( final Event evt ) {\nremoveCabalImplementation();\n}\n    } );\nString sDetect = UITexts.cabalImplsBlock_btnAutoDetect;\nbtnAutoDetect = SWTUtil.createPushButton( buttonsComp, sDetect );\nbtnAutoDetect.addListener( SWT.Selection, new Listener() {\n      public void handleEvent (final Event ev) {\nautoDetectCabalImpls();\n}\n    });\n}", "4245": "@Override\npublic void handleMessage(Message msg) {\nBluetoothAudioGateway.IncomingConnectionInfo info =\n                    (BluetoothAudioGateway.IncomingConnectionInfo)msg.obj;\nint type = BluetoothHandsfree.TYPE_UNKNOWN;\nswitch(msg.what) {\ncase BluetoothAudioGateway.MSG_INCOMING_HEADSET_CONNECTION:\ntype = BluetoothHandsfree.TYPE_HEADSET;\nbreak;\ncase BluetoothAudioGateway.MSG_INCOMING_HANDSFREE_CONNECTION:\ntype = BluetoothHandsfree.TYPE_HANDSFREE;\nbreak;\n}\nLog.i(TAG, \"Incoming rfcomm (\" + BluetoothHandsfree.typeToString(type) +\n\") connection from \" + info.mRemoteDevice + \"on channel \" + info.mRfcommChan);\nint priority = BluetoothHeadset.PRIORITY_OFF;\nHeadsetBase headset;\ntry {\npriority = mBinder.getPriority(info.mRemoteDevice);\n} catch (RemoteException e) {}\nif (priority <= BluetoothHeadset.PRIORITY_OFF) {\nLog.i(TAG, \"Rejecting incoming connection because priority = \" + priority);\nheadset = new HeadsetBase(mPowerManager, mAdapter, info.mRemoteDevice,\n                        info.mSocketFd, info.mRfcommChan, null);\nheadset.disconnect();\nreturn;\n}\nswitch (mState) {\ncase BluetoothHeadset.STATE_DISCONNECTED:\n// headset connecting us, lets join\nmRemoteDevice = info.mRemoteDevice;\nsetState(BluetoothHeadset.STATE_CONNECTING);\nheadset = new HeadsetBase(mPowerManager, mAdapter, mRemoteDevice, info.mSocketFd,\n                        info.mRfcommChan, mConnectedStatusHandler);\nmHeadsetType = type;\nmConnectingStatusHandler.obtainMessage(RFCOMM_CONNECTED, headset).sendToTarget();\nbreak;\ncase BluetoothHeadset.STATE_CONNECTING:\nif (!info.mRemoteDevice.equals(mRemoteDevice)) {\n// different headset, ignoring\nLog.i(TAG, \"Already attempting connect to \" + mRemoteDevice +\n\", disconnecting \" + info.mRemoteDevice);\nheadset = new HeadsetBase(mPowerManager, mAdapter, info.mRemoteDevice,\n                            info.mSocketFd, info.mRfcommChan, null);\nheadset.disconnect();\n}\n// If we are here, we are in danger of a race condition\n// incoming rfcomm connection, but we are also attempting an\n// outgoing connection. Lets try and interrupt the outgoing\n// connection.\nLog.i(TAG, \"Incoming and outgoing connections to \" + info.mRemoteDevice +\n\". Cancel outgoing connection.\");\nif (mConnectThread!= null) {\nmConnectThread.interrupt();\n}\n// Now continue with new connection, including calling callback\nmHeadset = new HeadsetBase(mPowerManager, mAdapter, mRemoteDevice,\n                        info.mSocketFd, info.mRfcommChan, mConnectedStatusHandler);\nmHeadsetType = type;\nsetState(BluetoothHeadset.STATE_CONNECTED, BluetoothHeadset.RESULT_SUCCESS);\nmBtHandsfree.connectHeadset(mHeadset, mHeadsetType);\n// Make sure that old outgoing connect thread is dead.\nif (mConnectThread!= null) {\ntry {\nmConnectThread.join();\n} catch (InterruptedException e) {\nLog.e(TAG, \"Connection cancelled twice eh?\", e);\n}\nmConnectThread = null;\n}\nif (DBG) log(\"Successfully used incoming connection, and cancelled outgoing \" +\n\" connection\");\nbreak;\ncase BluetoothHeadset.STATE_CONNECTED:\nLog.i(TAG, \"Already connected to \" + mRemoteDevice + \", disconnecting \" +\ninfo.mRemoteDevice);\nheadset = new HeadsetBase(mPowerManager, mAdapter, info.mRemoteDevice,\n                        info.mSocketFd, info.mRfcommChan, null);\nheadset.disconnect();\nbreak;\n}\n}", "4246": "public void setProviders(List newList) {\ncheckIfValidList(newList);\nIterator iter = newList.iterator();\nwhile (iter.hasNext()) {\nObject currentObject = iter.next();\nAuthenticationProvider attemptToCast = (AuthenticationProvider) currentObject;\ntry {\ncurrentObject = attemptToCast.getClass().newInstance();\n} catch (InstantiationException ie) {\nthrow new IllegalArgumentException(\"AuthenticationProvider \" + currentObject.getClass().getName()\n+ \" must be an instance of \" + AuthenticationProvider.class.getName());\n} catch (IllegalAccessException iae) {\nthrow new IllegalArgumentException(\"AuthenticationProvider \" + currentObject.getClass().getName()\n+ \" must be an instance of \" + AuthenticationProvider.class.getName());\n}\ncurrentObject.setAuthenticationProvider(attemptToCast);\n}\nthis.providers = newList;\n}", "4250": "@Test(testName = \"GET /vApp/{id}/screen/action/acquireTicket\", dependsOnMethods = { \"testGetVApp\" })\npublic void testGetScreenTicket() {\n// The method under test\nbyte[] image = vAppClient.getScreenImage(vApp.getHref());\nassertThat(image).isNotNull();\n}", "4252": "@Override\npublic void giveItem(int type, int amt) {\nplayer.getWorld().dropItem(player.getLocation(), new ItemStack(type, amt));\n}", "4253": "public void maybeUpdate(){\nsynchronized(this) {\ntry{\nif(isFetching || (!isRunning) || (!isUpdatable())) return;\n}catch (PrivkeyHasBeenBlownException e){\n// Handled in blow().\nisRunning=false;\nreturn;\n}\nisRunning=false;\n}\nLogger.normal(this,\"Starting the update process\");\nSystem.err.println(\"Starting the update process: found the update, now fetching it.\");\n//\t\tWe fetch it\ntry{\nif(cg==null||cg.isCancelled()){\ncg = new ClientGetter(this, node.chkFetchScheduler, node.sskFetchScheduler, \n\t\t\t\t\t\tURI.setSuggestedEdition(availableVersion), ctx, RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS, \n\t\t\t\t\t\tthis, new ArrayBucket());\n}\ncg.start();\nisFetching = true;\nqueueFetchRevocation(0);\n}catch (Exception e) {\nLogger.error(this, \"Error while starting the fetching: \"+e, e);\n}\n}", "4256": "@Test(testName = \"PUT /admin/catalog/{id}/owner\",\n         dependsOnMethods = { \"testGetCatalog\" })\npublic void updateCatalogOwner() {\nOwner oldOwner = owner;\nOwner newOwner = Owner.builder()\n.type(\"application/vnd.vmware.vcloud.owner+xml\")\n.user(Reference.builder()\n.type(\"application/vnd.vmware.admin.user+xml\")\n.name(\"adk@cloudsoftcorp.com\")\n.href(URI.create(\"https://vcloudbeta.bluelock.com/api/admin/user/e9eb1b29-0404-4c5e-8ef7-e584acc51da9\"))\n.build())\n.build();\ntry {\ncatalogClient.setOwner(catalog.getHref(), newOwner);\nowner = catalogClient.getOwner(catalog.getHref());\nChecks.checkOwner(owner);\nassertTrue(equal(owner, newOwner), String.format(OBJ_FIELD_UPDATABLE, CATALOG, \"owner\"));\n} finally {\ncatalogClient.setOwner(catalog.getHref(), oldOwner);\nowner = catalogClient.getOwner(catalog.getHref());\n}\n}", "4258": "public void doAfterCommand() {\ntry {\nselenium.waitForCondition(waitRequestChange, Wait.DEFAULT_TIMEOUT);\n} catch (SeleniumException e) {\n// ignore the timeout exception\n}\nRequestType requestDone = getRequestDone();\nif (requestDone!= requestExpected) {\nthrow new RequestGuardException(requestExpected, requestDone);\n}\n}", "4260": "private static void warn(@Nonnull Class<?> c, String kind) {\nString name = c.getName();\nString codeSource = codeSource(c);\n// Need to be very defensive about calling anything while holding this lock, lest we trigger class loading-related deadlocks.\nboolean doWarn;\nsynchronized (checked) {\ndoWarn = checked.put(c, true) == null;\n}\nif (doWarn) {\nif (codeSource == null) {\nLOGGER.warning(\"JENKINS-49795: attempt to (de-)serialize \" + kind + \" class \" + name);\n} else {\n// most easily tracked back to source using javap -classpath <location> -l '<name>'\nLOGGER.warning(\"JENKINS-49795: attempt to (de-)serialize \" + kind + \" class \" + name + \" in \" + codeSource);\n}\n}\n}", "4261": "@Test\npublic void updateStatus_withImage_DEPRECATED() {\nmockServer.expect(requestTo(\"https://api.twitter.com/1.1/statuses/update_with_media.json\"))\n.andExpect(method(POST))\n.andRespond(withSuccess(jsonResource(\"status\"), APPLICATION_JSON));\nResource photo = getUploadResource(\"photo.jpg\", \"PHOTO DATA\");\nTweet tweet = twitter.timelineOperations().updateStatus(\"Test Message\", photo);\nassertSingleTweet(tweet);\nmockServer.verify();\n}", "4269": "private void createHandleForActiveNode() {\nNode activeNode = getActiveNode();\nif (activeNode!= null) {\nHandle handle = null;\nif (getFunctionRepository().hasFunction(activeNode.getHandle())) {\nFunction handleFunction = getFunctionRepository().getFunction(activeNode.getHandle());\ntry {\nhandle = (Handle) handleFunction.invoke();\n} catch (Exception e) {\nhandle = new ErrorHandle(e);\nhandle.setHandleDelegate(this);\nhandle.update();\nviewerPane.setHandle(handle);\n}\n}\nif (handle!= null) {\nhandle.setHandleDelegate(this);\nhandle.update();\nviewerPane.setHandle(handle);\n} else {\nviewerPane.setHandle(null);\n}\n}\n}", "4272": "public synchronized void remove(int[] indices) {\nfor (int i = 0; i < indices.length; i++) {\nscanningResults.remove(i);\n}\n}", "4277": "public void testRenderFolderTree() {\ntry {\nfinal List<Folder> folders = createTestNodes(Folder.class, 7);\nfinal List<File> files = createTestNodes(File.class, 7);\nfinal Page doc = (Page)getDocument();\nassertEquals(7, folders.size());\nFolder rootNode = folders.get(0); rootNode.setName(\"rootNode\");\nFolder folderA = folders.get(1); folderA.setName(\"folderA\");\nFolder folderB = folders.get(2); folderB.setName(\"folderB\");\nFolder folderC = folders.get(3); folderC.setName(\"folderC\");\nFolder folderD = folders.get(4); folderD.setName(\"folderD\");\nFolder folderE = folders.get(5); folderE.setName(\"folderE\");\nFolder folderF = folders.get(6); folderF.setName(\"folderF\");\nFile file1 = files.get(0); file1.setName(\"file1\");\nFile file2 = files.get(1); file2.setName(\"file2\");\nFile file3 = files.get(2); file3.setName(\"file3\");\nFile file4 = files.get(3); file4.setName(\"file4\");\nFile file5 = files.get(4); file5.setName(\"file5\");\nFile file6 = files.get(5); file6.setName(\"file6\");\nFile file7 = files.get(6); file7.setName(\"file7\");\nrootNode.treeAppendChild(RelType.CONTAINS, folderA);\nrootNode.treeAppendChild(RelType.CONTAINS, folderB);\nrootNode.treeAppendChild(RelType.CONTAINS, file1);\nrootNode.treeAppendChild(RelType.CONTAINS, file2);\nfolderA.treeAppendChild(RelType.CONTAINS, folderC);\nfolderA.treeAppendChild(RelType.CONTAINS, folderD);\nfolderA.treeAppendChild(RelType.CONTAINS, file3);\nfolderA.treeAppendChild(RelType.CONTAINS, file4);\nfolderB.treeAppendChild(RelType.CONTAINS, folderE);\nfolderB.treeAppendChild(RelType.CONTAINS, folderF);\nfolderB.treeAppendChild(RelType.CONTAINS, file5);\nfolderB.treeAppendChild(RelType.CONTAINS, file6);\n// create dom tree\nElement html = doc.createElement(\"html\"); doc.appendChild(html);\nElement body = doc.createElement(\"body\"); html.appendChild(body);\nElement div = doc.createElement(\"div\"); body.appendChild(div);\ndiv.appendChild(doc.createTextNode(\"${root.name}\"));\nElement ul1 = doc.createElement(\"ul\"); div.appendChild(ul1);\nElement li1 = doc.createElement(\"li\"); ul1.appendChild(li1);\nli1.appendChild(doc.createTextNode(\"${folders.name}\"));\nElement li2 = doc.createElement(\"li\"); ul1.appendChild(li2);\nli2.appendChild(doc.createTextNode(\"${files.name}\"));\nElement ul2 = doc.createElement(\"ul\"); li1.appendChild(ul2);\nElement li3 = doc.createElement(\"li\"); ul2.appendChild(li3);\nli3.appendChild(doc.createTextNode(\"${files.name}\"));\nElement li4 = doc.createElement(\"li\"); ul2.appendChild(li4);\nli4.appendChild(doc.createTextNode(\"${folders.name}\"));\n// create RENDER_NODE relationship between first ul and rootNode\nPropertyMap properties = new PropertyMap();\n//properties.put(LinkedListNode.keyProperty, key);\nServices.command(securityContext, CreateRelationshipCommand.class).execute((DOMElement)div, rootNode, RelType.RENDER_NODE, properties, false);\n((DOMElement) div).setProperty(DOMElement.dataKey, \"root\");\n((DOMElement) li1).setProperty(DOMElement.dataKey, \"folders\");\n((DOMElement) li2).setProperty(DOMElement.dataKey, \"files\");\n((DOMElement) li3).setProperty(DOMElement.dataKey, \"files\");\n((DOMElement) li4).setProperty(DOMElement.dataKey, \"folders\");\nRenderContext ctx = new RenderContext(null, null, false, Locale.GERMAN);\ndoc.render(securityContext, ctx, 0);\nSystem.out.println(ctx.", "4281": "@Command(\n        aliases = { \"/sel\", \";\" },\n        usage = \"[cuboid|extend|poly|ellipsoid|sphere|cyl|convex]\",\n        desc = \"Choose a region selector\",\n        min = 0,\n        max = 1\n    )\npublic void select(CommandContext args, LocalSession session, LocalPlayer player,\n            EditSession editSession) throws WorldEditException {\nfinal LocalWorld world = player.getWorld();\nif (args.argsLength() == 0) {\nsession.getRegionSelector(world).clear();\nsession.dispatchCUISelection(player);\nplayer.print(\"Selection cleared.\");\nreturn;\n}\nfinal String typeName = args.getString(0);\nfinal RegionSelector oldSelector = session.getRegionSelector(world);\nfinal RegionSelector selector;\nif (typeName.equalsIgnoreCase(\"cuboid\")) {\nselector = new CuboidRegionSelector(oldSelector);\nplayer.print(\"Cuboid: left click for point 1, right click for point 2\");\n} else if (typeName.equalsIgnoreCase(\"extend\")) {\nselector = new ExtendingCuboidRegionSelector(oldSelector);\nplayer.print(\"Cuboid: left click for a starting point, right click to extend\");\n} else if (typeName.equalsIgnoreCase(\"poly\")) {\nint maxPoints = we.getMaximumPolygonalPoints(player);\nselector = new Polygonal2DRegionSelector(oldSelector, maxPoints);\nplayer.print(\"2D polygon selector: Left/right click to add a point.\");\nif (maxPoints > -1) {\nplayer.print(maxPoints + \" points maximum.\");\n}\n} else if (typeName.equalsIgnoreCase(\"ellipsoid\")) {\nselector = new EllipsoidRegionSelector(oldSelector);\nplayer.print(\"Ellipsoid selector: left click=center, right click to extend\");\n} else if (typeName.equalsIgnoreCase(\"sphere\")) {\nselector = new SphereRegionSelector(oldSelector);\nplayer.print(\"Sphere selector: left click=center, right click to extend\");\n} else if (typeName.equalsIgnoreCase(\"cyl\")) {\nselector = new CylinderRegionSelector(oldSelector);\nplayer.print(\"Cylindrical selector: Left click=center, right click to extend.\");\n} else if (typeName.equalsIgnoreCase(\"convex\") || typeName.equalsIgnoreCase(\"hull\") || typeName.equalsIgnoreCase(\"polyhedron\")) {\nint maxVertices = we.getMaximumPolygonalPoints(player);\nselector = new ConvexPolyhedralRegionSelector(oldSelector, maxVertices);\nplayer.print(\"Convex polyhedral selector: Left click=First vertex, right click to add more.\");\n} else {\nplayer.printError(\"Only cuboid|extend|poly|ellipsoid|sphere|cyl|convex are accepted.\");\nreturn;\n}\nsession.setRegionSelector(world, selector);\nsession.dispatchCUISelection(player);\n}", "4283": "public void updateActiveName(PlayerSpells playerSpells) {\nPlayer player = playerSpells.getPlayer();\nSpell spell = playerSpells.getMaster().getActiveSpell(player);\nItemStack activeMaterial = player.getInventory().getItem(8);\nString name = getName();\nint endOfWand = name.indexOf(\"(\");\nif (endOfWand > 0) {\nname = name.substring(0, endOfWand - 1);\n}\nString materialName = \"\";\nif (spell!= null && activeMaterial!= null && activeMaterial.getType()!= Material.AIR &&!isSpell(activeMaterial)) {\nmaterialName = activeMaterial.getType() == Wand.EraseMaterial? \"erase\" : activeMaterial.getType().name().toLowerCase();\nmaterialName = \" : \" + materialName;\n}\nsetName(name + \" (\" + spell.getName() + materialName + \")\");\n}", "4287": "@Test\npublic void offlineNoLocalCache() throws Exception {\ndelete(getLocalRepositoryLocation());\ncontext.setOffline(true);\ntry {\nresolveFromHttp(context, impl, servedUrl);\nAssert.fail();\n} catch (Exception e) {\nassertThat(e.getMessage(), is(\"No local cache found for url \" + servedUrl));\n}\n}", "4288": "private void createResourceSection(SashForm verticalSash) {\nSection resourcesSection = toolkit.createSection(verticalSash, Section.TITLE_BAR);\nresourcesSection.setText(\"Resources\");\nresourcesEditor = new ListEditorComposite<Resource>(resourcesSection, SWT.NONE);\nresourcesSection.setClient(resourcesEditor);\ntoolkit.adapt(resourcesEditor);\ntoolkit.paintBordersFor(resourcesEditor);\nresourcesEditor.setContentProvider(new ListEditorContentProvider<Resource>());\nresourcesEditor.setLabelProvider(new ResourceLabelProvider());\nresourcesEditor.addSelectionListener(new ISelectionChangedListener() {\n      public void selectionChanged(SelectionChangedEvent event) {\nList<Resource> selection = resourcesEditor.getSelection();\nloadResourceDetails(selection.size()==1? selection.get(0) : null);\n}\n    });\nresourcesEditor.addActionListener(new IActionListener() {\n      public void actionPerformed(ActionEvent event) {\nResource resource = resourcesEditor.getSelectedItem();\nloadResourceDetails(resource);\n}\n    });\n}", "4289": "@Test\npublic void testSkipOnReadNotDoubleCounted() throws Exception {\nreader = new SkipReaderStub(StringUtils.commaDelimitedListToStringArray(\"1,2,3,4,5,6\"), Arrays\n.asList(StringUtils.commaDelimitedListToStringArray(\"2,3,5\")));\nfactory.setSkipLimit(4);\nfactory.setItemReader(reader);\nStep step = (Step) factory.getObject();\nStepExecution stepExecution = jobExecution.createStepExecution(step);\nstep.execute(stepExecution);\nassertEquals(4, stepExecution.getSkipCount());\nassertEquals(3, stepExecution.getReadSkipCount());\nassertEquals(1, stepExecution.getWriteSkipCount());\n// skipped 2,3,4,5\nList<String> expectedOutput =\n Arrays.asList(StringUtils.commaDelimitedListToStringArray(\"1,6\"));\nassertEquals(expectedOutput, writer.written);\n}", "4291": "public void stop() {\nLOG.info(\"Stopping the Deposit Supervisor\");\ndepositWorkerPool.togglePause(true);\nif (timer!= null) {\nthis.timer.cancel();\nthis.timer.purge();\nthis.timer = null;\n}\nLOG.info(\"Stopped the Deposit Supervisor\");\n}", "4292": "public void execute()\nthrows MojoExecutionException\n{\nm_skippedProjects = new ArrayList();\nm_buildScript = new PaxScriptImpl();\nfor( Iterator i = m_reactorProjects.iterator(); i.hasNext(); )\n{\nMavenProject project = (MavenProject) i.next();\nString packaging = project.getPackaging();\nif( \"bundle\".equals( packaging ) )\n{\nhandleBundle( project );\n}\nelse if(!\"pom\".equals( packaging ) )\n{\nhandleModule( project );\n}\n}\nFile nixScript = new File( m_tempdir, \"pax-clone-\" + m_rootId );\nFile winScript = new File( m_tempdir, \"pax-clone-\" + m_rootId + \".bat\" );\ntry\n        {\ngetLog().info( \"Saving UNIX shell script \" + nixScript );\nm_buildScript.write( nixScript, \"\" );\n}\ncatch( IOException e )\n{\ngetLog().warn( \"Unable to write \" + nixScript );\n}\ntry\n        {\ngetLog().info( \"Saving Windows batch file \" + winScript );\nm_buildScript.write( winScript, \"call \" );\n}\ncatch( IOException e )\n{\ngetLog().warn( \"Unable to write \" + winScript );\n}\n}", "4297": "private void objectDefinition(ObjectDefinition that) {\ncomment(that);\nValue d = that.getDeclarationModel();\nboolean addToPrototype = opts.isOptimize() && d.isClassOrInterfaceMember();\nClass c = (Class) d.getTypeDeclaration();\nout(function, names.name(c));\nMap<TypeParameter, ProducedType> targs=new HashMap<TypeParameter, ProducedType>();\nif (that.getSatisfiedTypes()!= null) {\nfor (StaticType st : that.getSatisfiedTypes().getTypes()) {\nMap<TypeParameter, ProducedType> stargs = st.getTypeModel().getTypeArguments();\nif (stargs!= null &&!stargs.isEmpty()) {\ntargs.putAll(stargs);\n}\n}\n}\nout(targs.isEmpty()?\"()\":\"($$targs$$)\");\nbeginBlock();\ninstantiateSelf(c);\nreferenceOuter(c);\nfinal List<Declaration> superDecs = new ArrayList<Declaration>();\nif (!opts.isOptimize()) {\nnew SuperVisitor(superDecs).visit(that.getClassBody());\n}\nif (!targs.isEmpty()) {\nself(c); out(\".$$targs$$=$$targs$$;\"); endLine();\n}\ncallSuperclass(that.getExtendedType(), c, that, superDecs);\ncallInterfaces(that.getSatisfiedTypes(), c, that, superDecs);\nthat.getClassBody().visit(this);\nreturnSelf(c);\nindentLevel--;\nendLine();\nout(\"}\");\nendLine();\ntypeInitialization(that);\naddToPrototype(that, c, that.getClassBody().getStatements());\nif (!addToPrototype) {\nout(\"var \", names.name(d), \"=\", names.name(c), \"(\");\nif (!targs.isEmpty()) {\nTypeUtils.printTypeArguments(that, targs, this);\n}\nout(\");\");\nendLine();\n}\nif (!defineAsProperty(d)) {\nout(\"var \", names.getter(d), \"=function()\");\nbeginBlock();\nout(\"return \");\nif (addToPrototype) {\nout(\"this.\");\n}\nout(names.name(d), \";\");\nendBlockNewLine();\nif (addToPrototype || d.isShared()) {\nouterSelf(d);\nout(\".\", names.getter(d), \"=\", names.getter(d), \";\");\nendLine();\nouterSelf(d);\nout(\".\", names.getter(d), \".$$metamodel$$=\");\nTypeUtils.encodeForRuntime(d, that.getAnnotationList(), this);\nendLine(true);\n}\n}\nelse {\nout(clAlias, \"defineAttr(\");\nouterSelf(d);\nout(\",'\", names.name(d), \"',function(){return \");\nif (addToPrototype) {\nout(\"this.\", names.privateName(d));\n} else {\nout(names.name(d));\n}\nout(\";},undefined,\");\nTypeUtils.encodeForRuntime(d, that.getAnnotationList(), this);\nout(\");\");\nendLine();\nthat.getProperty().visit(this);\n}\n}", "4298": "private void finallySaveClicked() {\ntry {\n// Send all information needed to service to edit key in other thread\nIntent intent = new Intent(this, KeychainIntentService.class);\nintent.setAction(KeychainIntentService.ACTION_SAVE_KEYRING);\nSaveKeyringParcel saveParams = new SaveKeyringParcel();\nsaveParams.userIDs = getUserIds(mUserIdsView);\nsaveParams.originalIDs = mUserIdsView.getOriginalIDs();\nsaveParams.deletedIDs = mUserIdsView.getDeletedIDs();\nsaveParams.primaryIDChanged = mUserIdsView.primaryChanged();\nsaveParams.moddedKeys = toPrimitiveArray(mKeysView.getNeedsSavingArray());\nsaveParams.deletedKeys = mKeysView.getDeletedKeys();\nsaveParams.keysExpiryDates = getKeysExpiryDates(mKeysView);\nsaveParams.keysUsages = getKeysUsages(mKeysView);\nsaveParams.newPassPhrase = mNewPassPhrase;\nsaveParams.oldPassPhrase = mCurrentPassphrase;\nsaveParams.newKeys = toPrimitiveArray(mKeysView.getNewKeysArray());\nsaveParams.keys = getKeys(mKeysView);\nsaveParams.originalPrimaryID = mUserIdsView.getOriginalPrimaryID();\n// fill values for this action\nBundle data = new Bundle();\ndata.putBoolean(KeychainIntentService.SAVE_KEYRING_CAN_SIGN, mMasterCanSign);\ndata.putParcelable(KeychainIntentService.SAVE_KEYRING_PARCEL, saveParams);\nintent.putExtra(KeychainIntentService.EXTRA_DATA, data);\n// Message is received after saving is done in KeychainIntentService\nKeychainIntentServiceHandler saveHandler = new KeychainIntentServiceHandler(this,\n                    getString(R.string.progress_saving), ProgressDialog.STYLE_HORIZONTAL) {\n                public void handleMessage(Message message) {\n// handle messages by standard KeychainIntentServiceHandler first\nsuper.handleMessage(message);\nif (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {\nIntent data = new Intent();\ndata.putExtra(RESULT_EXTRA_MASTER_KEY_ID, getMasterKeyId());\n// return uri pointing to new created key\nUri uri = KeychainContract.KeyRings.buildPublicKeyRingsByKeyIdUri(\n                                String.valueOf(getMasterKeyId()));\ndata.setData(uri);\nArrayList<String> userIds = null;\ntry {\nuserIds = getUserIds(mUserIdsView);\n} catch (PgpGeneralException e) {\nLog.e(Constants.TAG, \"exception while getting user ids\", e);\n}\ndata.putExtra(RESULT_EXTRA_USER_ID, userIds.get(0));\nsetResult(RESULT_OK, data);\nfinish();\n}\n}\n            };\n// Create a new Messenger for the communication back\nMessenger messenger = new Messenger(saveHandler);\nintent.putExtra(KeychainIntentService.EXTRA_MESSENGER, messenger);\nsaveHandler.showProgressDialog(this);\n// start service with intent\nstartService(intent);\n} catch (PgpGeneralException e) {\nLog.e(Constants.TAG, getString(R.string.error_message, e.getMessage()));\nToast.makeText(this, getString(R.string.error_message, e.getMessage()),\n                    Toast.LENGTH_SHORT).show();\n}\n}", "4302": "public void setFieldValue(WebElement fieldElement, String value)\n{\nif (\"checkbox\".equals(fieldElement.getAttribute(\"type\"))) {\nsetCheckBox(fieldElement, value.equals(\"true\"));\n} else if (\"select\".equals(fieldElement.getTagName())) {\nList<WebElement> allOptions = fieldElement.findElements(By.tagName(\"option\"));\nfor (WebElement option : allOptions) {\nif (value.equals(option.getValue())) {\noption.setSelected();\n}\n}\n} else {\nfieldElement.clear();\nfieldElement.sendKeys(value);\n}\n}", "4304": "@Test\npublic void testServiceInterfaces() throws Exception {\nlog.info(\"randomTestPort=\" + randomTestPort);\nassertNotNull(mindAppmasterService);\nassertNotNull(mindAppmasterServiceClient);\nassertThat(mindAppmasterService.getPort(), greaterThan(0));\nSimpleTestRequest request = new SimpleTestRequest();\nBaseResponseObject response = mindAppmasterServiceClient.doMindRequest(request);\nassertNotNull(response);\n}", "4305": "public void loadConvertersFromForm(Map<String,String[]> form) {\nfor(String name : extractSelectedConverters(form)) {\nconverters.add(new Converter(Converter.Type.valueOf(name.toUpperCase()), new HashMap<String, Object>()));\n}\n}", "4307": "@Override\nprotected void onShare(final ActivityDTO inMsg)\n{\nfinal ShareDialog shareDialog = new ShareDialog(this, inMsg);\nshareDialog.show();\n}", "4310": "@Override\npublic void dropItem(Vector pt, BaseItemStack item) {\nWorld world = getWorld();\nItemStack bukkitItem = new ItemStack(item.getLegacyId(), item.getAmount());\nworld.dropItemNaturally(BukkitUtil.toLocation(world, pt), bukkitItem);\n}", "4313": "private void attemptSourceNavigation(final SourceNavigation navigation,\n                                        final AppCommand retryCommand)\n{\n// see if we can navigate by id\nString docId = navigation.getDocumentId();\nfinal EditingTarget target = getEditingTargetForId(docId);\nif (target!= null)\n{\n// check for navigation to the current position -- in this\n// case execute the retry command\nif ( (target == activeEditor_) &&\ntarget.isAtSourceRow(navigation.getPosition()))\n{\nif (retryCommand.isEnabled())\nretryCommand.execute();\n}\nelse\n         {\nsuspendSourceNavigationAdding_ = true;\ntry\n            {\nview_.selectTab(target.asWidget());\ntarget.restorePosition(navigation.getPosition());\n}\nfinally\n            {\nsuspendSourceNavigationAdding_ = false;\n}\n}\n}\n// check for code browser navigation\nelse if ((navigation.getPath()!= null) &&\nnavigation.getPath().equals(CodeBrowserEditingTarget.PATH))\n{\nCodeBrowserItem item = CodeBrowserItem.createItem(navigation.getPath());\nview_.openItem(item);\n}\n// check for file path navigation\nelse if ((navigation.getPath()!= null) &&\n!navigation.getPath().startsWith(DataItem.URI_PREFIX))\n{\nFileSystemItem file = FileSystemItem.createFile(navigation.getPath());\nTextFileType fileType = fileTypeRegistry_.getTextTypeForFile(file);\nsuspendSourceNavigationAdding_ = true;\nopenFile(file,\n                  fileType,\n                  new ResultCallback<EditingTarget, ServerError>() {\n                     public void onSuccess(final EditingTarget target)\n{\nScheduler.get().scheduleDeferred(new ScheduledCommand()\n{\n                           @Override\npublic void execute()\n{\ntry\n                              {\ntarget.restorePosition(navigation.getPosition());\n}\nfinally\n                              {\nsuspendSourceNavigationAdding_ = false;\n}\n}\n                        });\n}\n@Override\npublic void onFailure(ServerError info)\n{\nsuspendSourceNavigationAdding_ = false;\nif (retryCommand.isEnabled())\nretryCommand.execute();\n}\n@Override\npublic void onCancelled()\n{\nsuspendSourceNavigationAdding_ = false;\n}\n                  });\n}\nelse\n      {\n// couldn't navigate to this item, retry\nif (retryCommand.isEnabled())\nretryCommand.execute();\n}\n}", "4315": "@Test\npublic void testStartProcessFromJmsAfterApplicationStart() throws Exception {\nassertSuccess(client.createContainer(CONTAINER_ID, new KieContainerResource(CONTAINER_ID, RELEASE_ID)));\n// Custom client with reduced timeout\nKieServicesConfiguration customConfig = configuration.clone();\ncustomConfig.setTimeout(3000);\nKieServicesClient customClient = KieServicesFactory.newKieServicesClient(customConfig);\nProcessServicesClient customProcessClient = customClient.getServicesClient(ProcessServicesClient.class);\ncontainerRemoteController.undeployWarFile(TestConfig.getKieServerContext(), TestConfig.getKieServerWarPath());\ntry {\ncustomProcessClient.startProcess(CONTAINER_ID, PROCESS_ID_USERTASK);\nfail(\"Should throw exception about Kie server being unavailable.\");\n} catch (Exception e) {\nassertTrue(e instanceof KieServicesException);\nassertEquals(\"Response is empty\", ((KieServicesException) e).getMessage());\n} finally {\ncontainerRemoteController.deployWarFile(TestConfig.getKieServerContext(), TestConfig.getKieServerWarPath());\n}\n// Process should be deployed.\nList<ProcessInstance> processInstances = queryClient.findProcessInstances(0, 100);\nassertEquals(1, processInstances.size());\nProcessInstance pi = processInstances.get(0);\nassertEquals(org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE, pi.getState().intValue());\nprocessClient.abortProcessInstance(CONTAINER_ID, pi.getId());\n}", "4316": "@UnsafeMethod\npublic synchronized void enablePlugin(Plugin paramPlugin) {\nif (!CommonPlugin.class.isAssignableFrom(paramPlugin.getClass())) {\nthrow new IllegalArgumentException(\"Cannot enable plugin with this PluginLoader as it is of the wrong type!\");\n}\nif (!paramPlugin.isEnabled()) {\nCommonPlugin cp = (CommonPlugin) paramPlugin;\nString name = cp.getDescription().getName();\nif (!loaders.containsKey(name)) {\nloaders.put(name, (CommonClassLoader) cp.getClassLoader());\n}\ntry {\ncp.setEnabled(true);\ncp.onEnable();\n} catch (Throwable e) {\nengine.getLogger().log(Level.SEVERE, new StringBuilder().append(\"An error occured when enabling '\").append(paramPlugin.getDescription().getFullName()).append(\"': \").append(e.getMessage()).toString(), e);\n}\nPluginEnableEvent.fire(cp, paramPlugin);\n}\n}", "4318": "@Override\npublic void addAdditionalTemplateData(ICharacterGenerics characterGenerics) {\nIEquipmentTemplateProvider equipmentDatabase = new IEquipmentTemplateProvider() {\n\n      public String[] getAllAvailableTemplateIds() {\nreturn new String[0];\n}\npublic IEquipmentTemplate loadTemplate(String templateId) {\nreturn null;\n}\n    };\ncharacterGenerics.getAdditionalModelFactoryRegistry().register(\n        EquipmentAdditonalModelTemplate.ID,\n        new EquipmentAdditionalModelFactory(equipmentDatabase));\ncharacterGenerics.getAdditonalPersisterFactoryRegistry().register(\n        EquipmentAdditonalModelTemplate.ID,\n        new EquipmentAdditionalPersisterFactory());\ncharacterGenerics.getAdditionalViewFactoryRegistry().register(\n        EquipmentAdditonalModelTemplate.ID,\n        new EquipmentAdditionalViewFactory());\ncharacterGenerics.getGlobalAdditionalTemplateRegistry().add(new EquipmentAdditonalModelTemplate());\n}", "4319": "@Override\npublic void setPosition(Vector pos, float pitch, float yaw) {\norg.spongepowered.api.world.Location<World> loc = new org.spongepowered.api.world.Location<World>(\n                this.player.getWorld(), pos.getX(), pos.getY(), pos.getZ()\n        );\nthis.player.setLocation(loc);\n}", "4322": "@Override\npublic final void run(Context context) throws IOException, InterruptedException {\nthis.resources = new RuntimeResourceManager(context.getConfiguration());\nresources.setup();\ntry {\nrunInternal(context);\n} catch (Throwable t) {\noombuf = null;\ntry {\nTraceDriver.error(t);\n} catch (Throwable e) {\n// ignored errors during error tracking\ne.printStackTrace();\n}\nif (t instanceof Error) {\nthrow (Error) t;\n} else if (t instanceof RuntimeException) {\nthrow (RuntimeException) t;\n} else if (t instanceof IOException) {\nthrow (IOException) t;\n} else if (t instanceof InterruptedException) {\nthrow (InterruptedException) t;\n} else {\nthrow new AssertionError(t);\n}\n} finally {\nthis.resources.cleanup();\n}\n}", "4324": "private void doTest(MessageCount level, Concurrency concurrency, TransactionMode transactionMode) throws Exception {\nint messageCount = level.value();\nint concurrentConsumers = concurrency.value();\nboolean transactional = transactionMode.isTransactional();\ncreateTemplate(concurrentConsumers);\nCountDownLatch latch = new CountDownLatch(messageCount);\nfor (int i = 0; i < messageCount; i++) {\ntemplate.convertAndSend(queue.getName(), i + \"foo\");\n}\nSimpleMessageListenerContainer container = new SimpleMessageListenerContainer(template.getConnectionFactory());\nPojoListener listener = new PojoListener(latch);\ncontainer.setMessageListener(new MessageListenerAdapter(listener));\ncontainer.setChannelTransacted(transactional);\ncontainer.setConcurrentConsumers(concurrentConsumers);\ncontainer.setPrefetchCount(10);\ncontainer.setTxSize(5);\ncontainer.setConsumerQueueCapacity(10);\ncontainer.setQueueName(queue.getName());\ncontainer.afterPropertiesSet();\ncontainer.start();\ntry {\nboolean waited = latch.await(50, TimeUnit.MILLISECONDS);\nlogger.info(\"All messages received before stop: \" + waited);\nif (messageCount > 1) {\nassertFalse(\"Expected not to receive all messages before stop\", waited);\n}\ncontainer.stop();\nThread.sleep(500L);\nif (!transactional) {\nint messagesReceivedAfterStop = listener.getCount();\nwaited = latch.await(500, TimeUnit.MILLISECONDS);\nlogger.info(\"All messages received after stop: \" + waited);\nif (messageCount < 100) {\nassertTrue(\"Expected to receive all messages after stop\", waited);\n}\nassertEquals(\"Unexpected additional messages received after stop\", messagesReceivedAfterStop,\n\t\t\t\t\t\tlistener.getCount());\nfor (int i = 0; i < messageCount; i++) {\ntemplate.convertAndSend(queue.getName(), i + \"bar\");\n}\nlatch = new CountDownLatch(messageCount);\nlistener.reset(latch);\n}\nint messagesReceivedBeforeStart = listener.getCount();\ncontainer.start();\nint timeout = Math.min(1 + messageCount / (4 * concurrentConsumers), 30);\nlogger.debug(\"Waiting for messages with timeout = \" + timeout + \" (s)\");\nwaited = latch.await(timeout, TimeUnit.SECONDS);\nlogger.info(\"All messages received after start: \" + waited);\nif (transactional) {\nassertTrue(\"Timed out waiting for message\", waited);\n} else {\nint count = listener.getCount();\nassertTrue(\"Expected additional messages received after start: \" + messagesReceivedBeforeStart + \">=\"\n+ count, messagesReceivedBeforeStart < count);\nassertNull(\"Messages still available\", template.receive(queue.getName()));\n}\n} finally {\n// Wait for broker communication to finish before trying to stop\n// container\nThread.sleep(300L);\ncontainer.shutdown();\n}\nassertNull(template.receiveAndConvert(queue.getName()));\n}", "4327": "public void exceptionOccurred(Throwable e) {\nSystem.err.println(\"SlimResponder.exceptionOcurred:\" + e.getMessage());\n}", "4328": "private void onException(Exception e) {\nif (logger.isTraceEnabled()) {\nlogger.trace(() -> new ParameterizedMessage(\n                    \"[{}][{}] Got exception on recovery\", request.shardId().getIndex().getName(),\n                    request.shardId().id()), e);\n}\nThrowable cause = ExceptionsHelper.unwrapCause(e);\nif (cause instanceof CancellableThreads.ExecutionCancelledException) {\n// this can also come from the source wrapped in a RemoteTransportException\nonGoingRecoveries.failRecovery(recoveryId, new RecoveryFailedException(request,\n                    \"source has canceled the recovery\", cause), false);\nreturn;\n}\nif (cause instanceof RecoveryEngineException) {\n// unwrap an exception that was thrown as part of the recovery\ncause = cause.getCause();\n}\n// do it twice, in case we have double transport exception\ncause = ExceptionsHelper.unwrapCause(cause);\nif (cause instanceof RecoveryEngineException) {\n// unwrap an exception that was thrown as part of the recovery\ncause = cause.getCause();\n}\n// here, we would add checks against exception that need to be retried (and not removeAndClean in this case)\nif (cause instanceof IllegalIndexShardStateException || cause instanceof IndexNotFoundException ||\ncause instanceof ShardNotFoundException) {\n// if the target is not ready yet, retry\nretryRecovery(\n                    recoveryId,\n                    \"remote shard not ready\",\n                    recoverySettings.retryDelayStateSync(),\n                    recoverySettings.activityTimeout());\nreturn;\n}\n// PeerRecoveryNotFound is returned when the source node cannot find the recovery requested by\n// the REESTABLISH_RECOVERY request. In this case, we delay and then attempt to restart.\nif (cause instanceof DelayRecoveryException || cause instanceof PeerRecoveryNotFound) {\nretryRecovery(recoveryId, cause, recoverySettings.retryDelayStateSync(),\n                    recoverySettings.activityTimeout());\nreturn;\n}\nif (cause instanceof ConnectTransportException) {\nlogger.debug(\"delaying recovery of {} for [{}] due to networking error [{}]\", request.shardId(),\n                    recoverySettings.retryDelayNetwork(), cause.getMessage());\nreestablishRecovery(request, cause.getMessage(), recoverySettings.retryDelayNetwork());\n} else {\nretryRecovery(recoveryId, cause.getMessage(), recoverySettings.retryDelayNetwork(),\n                        recoverySettings.activityTimeout());\n}\nreturn;\n}\nif (cause instanceof AlreadyClosedException) {\nonGoingRecoveries.failRecovery(recoveryId,\n                    new RecoveryFailedException(request, \"source shard is closed\", cause), false);\nreturn;\n}\nonGoingRecoveries.failRecovery(recoveryId, new RecoveryFailedException(request, e), true);\n}", "4331": "private static HadoopKryo createKryo() {\nHadoopKryo kryo = new HadoopKryo();\nString version = System.getProperty(\"java.version\");\nchar minor = version.charAt(2);\nif (minor >= '8') {\ntry {\nkryo.register(Class.forName(\"java.lang.invoke.SerializedLambda\"));\nkryo.register(Class.forName(\"com.esotericsoftware.kryo.Kryo$Closure\"),\n            new ClosureSerializer());\n} catch (ClassNotFoundException e) {\nthrow new IllegalStateException(\n            \"Trying to use Kryo on >= Java 8 (\" + version +\n\"), but unable to find needed classes\", e);\n}\n}\nkryo.register(Arrays.asList().getClass(), new ArraysAsListSerializer());\nkryo.register(Collections.nCopies(1, new Object()).getClass(),\n        new CollectionsNCopiesSerializer());\nImmutableListSerializer.registerSerializers(kryo);\nkryo.register(ImmutableList.class, new ArrayListSerializer());\nkryo.register(ImmutableMap.class, new HashMapSerializer());\nkryo.register(ImmutableSet.class, new HashSetSerializer());\nkryo.register(ImmutableSortedMap.class, new TreeMapSerializer());\nkryo.register(ImmutableList.class, new ArrayListSerializer());\nkryo.register(ImmutableCollection.class, new ArrayListSerializer());\nkryo.register(ImmutableList.class, new ArrayListSerializer());\nkryo.register(ImmutableMap.class, new HashMapSerializer());\nkryo.setInstantiatorStrategy(new DefaultInstantiatorStrategy(\n        new StdInstantiatorStrategy()));\nkryo.setDefaultSerializer(new SerializerFactory() {\n      @SuppressWarnings(\"rawtypes\")\n@Override\npublic Serializer makeSerializer(Kryo kryo, final Class<?> type) {\nfor (final Entry<Class<?>, String> entry :\n            NON_SERIALIZABLE.entrySet()) {\nif (entry.getKey().isAssignableFrom(type)) {\n// Allow Class object to be serialized, but not a live instance.\nreturn new Serializer() {\n              @Override\npublic Object read(Kryo kryo, Input input, Class type) {\nthrow new RuntimeException(\"Cannot serialize \" + type +\n\". Objects being serialized cannot capture \" +\nentry.getKey() + \" because \" + entry.getValue() +\n\". Either remove field in question\" +\n\", or make it transient (so that it isn't serialized)\");\n}\n@Override\npublic void write(Kryo kryo, Output output, Object object) {\nthrow new RuntimeException(\"Cannot serialize \" + type +\n\". Objects being serialized cannot capture \" +\nentry.getKey() + \" because \" + entry.getValue() +\n\". Either remove field in question\" +\n\", or make it transient (so that it isn't serialized)\");\n}\n            };\n}\n}\nif (Writable.class.isAssignableFrom(type) &&\n!KryoIgnoreWritable.class.isAssignableFrom(type) &&\n// remove BasicSet, BasicArrayList and Basic2ObjectMap temporarily,\n// for lack of constructors\n!BasicSet.class.isAssignableFrom(type) &&\n!BasicArrayList.class.isAssignableFrom(type) &&\n!Basic2ObjectMap.class.isAssignableFrom(type)) {\n// use the Writable method defined by the type\nDirectWritableSerializer serializer = new DirectWritableSerializer();\nreturn serializer;\n} else {\nFieldSerializer serializer = new FieldSerializer<>(kryo, type);\nserializer.setIgnoreSyntheticFields(false);\nreturn serializer;\n}\n}\n    });\nreturn kryo;\n}", "4332": "private void btProfileSettingsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btProfileSettingsActionPerformed\nPlfPart p = VisicutModel.getInstance().getSelectedPart();\nif (p == null || p.getMapping() == null || p.getMapping().isEmpty()) { return; }\nif (p.getMapping().size() > 1)\n{\nMainView.getInstance().showLaserProfileDialog(p.getMapping().get(0).getProfile(), p);\nreturn;\n}\nLaserProfile profile = MainView.getInstance().editLaserProfile(p.getMapping().get(0).getProfile());\nif (profile!= null)\n{\np.getMapping().get(0).setProfile(profile);\nVisicutModel.getInstance().firePartUpdated(p);\n}\n}", "4334": "public static void checkProductSectionList(ProductSectionList val) {\nassertNotNull(val, String.format(NOT_NULL_OBJECT_FMT, \"ProductSectionList\", \"\"));\nfor (ProductSection productSection : val.getProductSections()) {\ncheckOvfProductSection(productSection);\n}\ncheckResourceType(val);\n}", "4336": "private void setDisplayMode(FolderMode newMode)\n{\nmAccount.setFolderDisplayMode(newMode);\nmAccount.save(Preferences.getPreferences(this));\nMailService.actionReschedule(this, null);\nonRefresh(false);\n}", "4340": "public void copyFile(String source, String destination)\nthrows CmsException {\nFile destinationFile = new File(destination);\nif (!destinationFile.exists()) {\ndestinationFile.mkdirs();\n}\nInputStream sourceStream = new FileInputStream(source);\nOutputStream destinationStream = new FileOutputStream(destinationFile);\nIOUtils.copy(sourceStream, destinationStream);\nsourceStream.close();\ndestinationStream.close();\n}", "4341": "@Override\npublic void defineQualifier()\n{\nif(isDefaultMetaDataProvider())\n{\nDefinitionUtil.defineQualifiers(this.bean, this.beanAnnotations);\n}\nelse\n        {\nDefinitionUtil.defineQualifiers(this.bean, this.beanAnnotations, this.propertyAnnotations);\n}\n}", "4342": "@Override\nprotected void runTest() throws Throwable {\nint endpointCount = channels.length;\nint expectedConcurrency = endpointCount * messages;\nfinal CountDownLatch shutdownLatch = new CountDownLatch(1);\nfinal CountDownLatch concurrencyReachedLatch = new CountDownLatch(expectedConcurrency);\nMessageReceiver messageReceiver = new MessageReceiver() {\n            public void receive(MessageContext msgContext) throws AxisFault {\nconcurrencyReachedLatch.countDown();\ntry {\nshutdownLatch.await();\n} catch (InterruptedException ex) {\n}\n}\n        };\nTestResourceSet[] resourceSets = new TestResourceSet[endpointCount];\nEndpoint[] endpoints = new Endpoint[endpointCount];\ntry {\nfor (int i=0; i<endpointCount; i++) {\nTestResourceSet resources = new TestResourceSet(getResourceSet());\nAsyncChannel channel = channels[i];\nresources.addResource(channel);\nAxisAsyncTestClient client = new AxisAsyncTestClient();\nresources.addResource(client);\nresources.setUp();\nresourceSets[i] = resources;\nif (!preloadMessages) {\nendpoints[i] = server.createAsyncEndpoint(channel, messageReceiver, null);\n}\nfor (int j=0; j<messages; j++) {\nClientOptions options = new ClientOptions(\"UTF-8\");\nAxisMessage message = new AxisMessage();\nmessage.setMessageType(SOAP11Constants.SOAP_11_CONTENT_TYPE);\nSOAPFactory factory = OMAbstractFactory.getSOAP11Factory();\nSOAPEnvelope envelope = factory.getDefaultEnvelope();\nmessage.setEnvelope(envelope);\nclient.sendMessage(options, message);\n}\nif (preloadMessages) {\nendpoints[i] = server.createAsyncEndpoint(channel, messageReceiver, null);\n}\n}\nif (!concurrencyReachedLatch.await(5, TimeUnit.SECONDS)) {\nfail(\"Concurrency reached is \" + (expectedConcurrency -\nconcurrencyReachedLatch.getCount()) + \", but expected \" +\nexpectedConcurrency);\n}\n} finally {\nshutdownLatch.countDown();\nfor (int i=0; i<endpointCount; i++) {\nif (endpoints[i]!= null) {\nendpoints[i].remove();\n}\nif (resourceSets[i]!= null) {\nresourceSets[i].tearDown();\n}\n}\n}\n}", "4352": "@Override\npublic void onActivityResumed(final Activity activity) {\ndispatchOnConversationQueue(new DispatchTask() {\n\t\t\t@Override\nprotected void execute() {\nApptentiveInternal.getInstance().onActivityResumed(activity);\nNotificationManager notificationManager = (NotificationManager) App.getAppComponent().getSystemService(Context.NOTIFICATION_SERVICE);\nnotificationManager.notify(activity.getString(R.string.notification_title), activity.getString(R.string.notification_message), NotificationManager.TYPE_SIMPLE);\n}\n\t\t});\n}", "4355": "public void run(String format, String[] args) {\nsuper.run(format, args);\nmlParams = CmdLineUtil.loadTrainingParameters(params.getParams(), true);\nif (mlParams!= null) {\nif (!TrainerFactory.isValid(mlParams.getSettings(\"build\"))) {\nthrow new TerminateToolException(1, \"Build training parameters are invalid!\");\n}\nif (!TrainerFactory.isValid(mlParams.getSettings(\"check\"))) {\nthrow new TerminateToolException(1, \"Check training parameters are invalid!\");\n}\nif (!TrainerFactory.isValid(mlParams.getSettings(\"attach\"))) {\nthrow new TerminateToolException(1, \"Attach training parameters are invalid!\");\n}\nif (!TrainerFactory.isValid(mlParams.getSettings(\"tagger\"))) {\nthrow new TerminateToolException(1, \"Tagger training parameters are invalid!\");\n}\nif (!TrainerFactory.isValid(mlParams.getSettings(\"chunker\"))) {\nthrow new TerminateToolException(1, \"Chunker training parameters are invalid!\");\n}\n}\nif(mlParams == null) {\nmlParams = ModelUtil.createDefaultTrainingParameters();\n}\nFile modelOutFile = params.getModel();\nCmdLineUtil.checkOutputFile(\"parser model\", modelOutFile);\nParserModel model;\ntry {\nHeadRules rules = new opennlp.tools.parser.lang.en.HeadRules(\n          new InputStreamReader(new FileInputStream(params.getHeadRules()),\n              params.getEncoding()));\nParserType type = parseParserType(params.getParserType());\nif(params.getFun()){\nParse.useFunctionTags(true);\n}\nif (ParserType.CHUNKING.equals(type)) {\nmodel = opennlp.tools.parser.chunking.Parser.train(\n            params.getLang(), sampleStream, rules,\n            mlParams);\n}\nelse if (ParserType.TREEINSERT.equals(type)) {\nmodel = opennlp.tools.parser.treeinsert.Parser.train(params.getLang(), sampleStream, rules,\n            mlParams);\n}\nelse {\nthrow new IllegalStateException();\n}\n}\ncatch (IOException e) {\nthrow new TerminateToolException(-1, \"IO error while reading training data or indexing data: \"\n+ e.getMessage(), e);\n}\nfinally {\ntry {\nsampleStream.close();\n} catch (IOException e) {\n// sorry that this can fail\n}\n}\nCmdLineUtil.writeModel(\"parser\", modelOutFile, model);\n}", "4356": "@Test\npublic void testPassingCreateAsElementNameReturnsTrue()\n{\nIQ iq = new IQ(stanza.getChildElement());\nassertTrue(nodeCreate.accept(iq.getChildElement()));\n}", "4359": "public void deserialize(DataInput in) throws IOException {\nthis.sizeInBits = in.readInt();\nint sizeInWords = in.readInt();\nthis.buffer.clear();\nthis.buffer.ensureCapacity(sizeInWords);\nfor(int i = 0; i < sizeInWords; ++i) {\nthis.buffer.push_back(in.readLong());\n}\nthis.rlw = new RunningLengthWord(this.buffer, in.readInt());\n}", "4360": "@Override\nprotected void drawImpl(final GL2ES2 gl, final RegionRenderer renderer, final int[/*1*/] sampleCount) {\nfinal int renderModes = getRenderModes();\nuseShaderProgram(gl, renderer, renderModes, getQuality());\nif( 0 >= indicesBuffer.getElementCount() ) {\nif(DEBUG_INSTANCE) {\nSystem.err.printf(\"VBORegionSPES2.drawImpl: Empty%n\");\n}\nreturn; // empty!\n}\ngca_VerticesAttr.enableBuffer(gl, true);\ngca_CurveParamsAttr.enableBuffer(gl, true);\nif( null!= gca_ColorsAttr ) {\ngca_ColorsAttr.enableBuffer(gl, true);\n}\nindicesBuffer.bindBuffer(gl, true); // keeps VBO binding\nif( renderer.getRenderState().isHintMaskSet(RenderState.BITHINT_BLENDING_ENABLED) ) {\ngl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA);\n}\nif( null!= gcu_ColorTexUnit && colorTexSeq.isTextureAvailable() ) {\nfinal TextureSequence.TextureFrame frame = colorTexSeq.getNextTexture(gl);\ngl.glActiveTexture(GL.GL_TEXTURE0 + colorTexSeq.getTextureUnit());\nfinal Texture tex = frame.getTexture();\ntex.bind(gl);\ntex.enable(gl); // nop on core\nfinal int colorTexUnit = colorTexSeq.getTextureUnit();\nif( colorTexUnit!= gcu_ColorTexUnit.intValue() ) {\ngcu_ColorTexUnit.setData(colorTexUnit);\ngl.glUniform(gcu_ColorTexUnit);\n}\ngl.glUniform(gcu_ColorTexBBox);\ngl.glDrawElements(GL2ES2.GL_TRIANGLES, indicesBuffer.getElementCount() * indicesBuffer.getComponentCount(), GL2ES2.GL_UNSIGNED_SHORT, 0);\ntex.disable(gl); // nop on core\n} else {\ngl.glDrawElements(GL2ES2.GL_TRIANGLES, indicesBuffer.getElementCount() * indicesBuffer.getComponentCount(), GL2ES2.GL_UNSIGNED_SHORT, 0);\n}\nindicesBuffer.bindBuffer(gl, false);\nif( null!= gca_ColorsAttr ) {\ngca_ColorsAttr.enableBuffer(gl, false);\n}\ngca_CurveParamsAttr.enableBuffer(gl, false);\ngca_VerticesAttr.enableBuffer(gl, false);\n}", "4362": "private void deleteCurrent(){\nif(currentCard!= null){\nnew AlertDialog.Builder(EditScreen.this)\n.setTitle(getString(R.string.detail_delete))\n.setMessage(getString(R.string.delete_warning))\n.setPositiveButton(getString(R.string.yes_text),\n                    new DialogInterface.OnClickListener() {\n                        public void onClick(DialogInterface arg0, int arg1) {\ncurrentItem = itemManager.deleteItem(currentItem);\nrestartActivity();\n}\n                    })\n.setNegativeButton(getString(R.string.no_text), null)\n.create()\n.show();\n}\n}", "4363": "private void processFunctionParameters(@NotNull GoScopeProcessorBase processor) {\nGoFunctionOrMethodDeclaration function = PsiTreeUtil.getParentOfType(myElement, GoFunctionOrMethodDeclaration.class);\nGoSignature signature = function!= null? function.getSignature() : null;\nGoParameters parameters;\nif (signature!= null) {\nparameters = signature.getParameters();\nparameters.processDeclarations(processor, ResolveState.initial(), null, myElement);\nGoResult result = signature.getResult();\nGoParameters resultParameters = result!= null? result.getParameters() : null;\nif (resultParameters!= null) resultParameters.processDeclarations(processor, ResolveState.initial(), null, myElement);\n}\n}", "4364": "private void updateAttributeType( AttributeTypeLiteral atl )\n{\nmodifiedAttributeType.setCollective( atl.isCollective() );\nmodifiedAttributeType.setDescription( atl.getDescription() );\nmodifiedAttributeType.setEquality( atl.getEquality() );\nmodifiedAttributeType.setNames( atl.getNames() );\nmodifiedAttributeType.setNoUserModification( atl.isNoUserModification() );\nmodifiedAttributeType.setObsolete( atl.isObsolete() );\nmodifiedAttributeType.setShared( atl.isShared() );\nmodifiedAttributeType.setOrdering( atl.getOrdering() );\nmodifiedAttributeType.setSingleValue( atl.isSingleValue() );\nmodifiedAttributeType.setSubstr( atl.getSubstr() );\nmodifiedAttributeType.setSuperior( atl.getSuperior() );\nmodifiedAttributeType.setSyntax( atl.getSyntax() );\nmodifiedAttributeType.setUsage( atl.getUsage() );\n}", "4365": "@Override\npublic void updateState(Preference preference) {\nif (mAppRow!= null && mChannel!= null) {\npreference.setEnabled(mAdmin == null &&!mChannel.isImportanceLockedByOEM());\nImportancePreference pref = (ImportancePreference) preference;\npref.setConfigurable(!mChannel.isImportanceLockedByOEM());\npref.setImportance(mChannel.getImportance());\npref.setDisplayInStatusBar(mBackend.showSilentInStatusBar(mContext.getPackageName()));\npref.setLockScreen(mChannel.isImportanceLockedByOEM());\n}\n}", "4371": "void initStateIfNecessary() throws IOException {\nif (this.readSelectorState == null) {\nthis.readSelectorState = new SelectorHolder(Selector.open());\nthis.writeSelectorState = new SelectorHolder(Selector.open());\nstartIoLoops();\n}\n}", "4372": "private void clearSchema() throws SQLException\n{\nConnection connection = this._state.connection( ).get( );\nString schemaName = this._state.schemaName( ).get( );\nDatabaseMetaData metaData = connection.getMetaData( );\nStatement stmt = connection.createStatement( );\ntry\n       {\nthis.dropTablesIfExist( metaData, schemaName, null, stmt );\n} finally\n       {\nstmt.close( );\n}\n}", "4374": "@Test\npublic void testExistingFilePattern() throws Exception\n{\nOptions options = PatternOptionBuilder.parsePattern(\"f<\");\nCommandLineParser parser = new PosixParser();\nCommandLine line = parser.parse(options, new String[] { \"-f\", \"test.properties\" });\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\nassertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));", "4376": "private void updateAttendees(View view) {\nTextView tv = mAttendees;\nSpannableStringBuilder sb = new SpannableStringBuilder();\nformatAttendees(mAcceptedAttendees, sb, Attendees.ATTENDEE_STATUS_ACCEPTED);\nformatAttendees(mDeclinedAttendees, sb, Attendees.ATTENDEE_STATUS_DECLINED);\nformatAttendees(mTentativeAttendees, sb, Attendees.ATTENDEE_STATUS_TENTATIVE);\nformatAttendees(mNoResponseAttendees, sb, Attendees.ATTENDEE_STATUS_NONE);\nif (sb.length() > 0) {\n// Add the label after the attendees are formatted because\n// formatAttendees would prepend \", \" if sb.length!= 0\nString label = getActivity().getResources().getString(R.string.attendees_label);\nsb.insert(0, label);\nsb.insert(label.length(), \" \");\nsb.setSpan(new StyleSpan(Typeface.BOLD), 0, label.length(),\n                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\ntv.setText(sb);\n}\n((AttendeesView)mLongAttendees).addAttendees(mAcceptedAttendees);\n((AttendeesView)mLongAttendees).addAttendees(mDeclinedAttendees);\n((AttendeesView)mLongAttendees).addAttendees(mTentativeAttendees);\n((AttendeesView)mLongAttendees).addAttendees(mNoResponseAttendees);\nmLongAttendees.setEnabled(false);\n}", "4377": "protected void rememberIdentity(Account account) {\nString cookieValue = getRememberMeSerializer().serialize(account.getPrincipals());\nCookie principalsCookie = new Cookie(getPrincipalCookieName(), cookieValue);\nprincipalsCookie.setMaxAge(getRememberMeMaxAge());\ngetCookieStore().setCookie(principalsCookie);\n}", "4380": "private void showFragment(FragmentTransaction ft, int viewId, Fragment fragment){\nFragment f = mFragmentManager.findFragmentById(fragment.getId());\nif( f!= null){\nft.remove(f);\n}\nft.replace(viewId, fragment, fragment.getClass().getSimpleName());\n}", "4383": "public void renderDocument( Writer writer, Renderer renderer, SiteRenderingContext siteRenderingContext )\nthrows RendererException, FileNotFoundException\n{\nLocale locale = siteRenderingContext.getLocale();\nString localReportName = report.getName( locale );\nlog.info( \"Generating \\\"\" + localReportName + \"\\\" report.\" );\nMySinkFactory sf = new MySinkFactory( renderingContext );\nSiteRendererSink sink = new SiteRendererSink( renderingContext );\nsink.enableLogging( new MojoLogWrapper( log ) );\ntry\n        {\nif ( report instanceof MavenMultiPageReport )\n{\n( (MavenMultiPageReport) report ).generate( sink, sf, locale );\n}\nelse\n            {\ntry\n                {\nreport.generate( sink, locale );\n}\ncatch ( NoSuchMethodError e )\n{\nthrow new RendererException( \"No method on \" + report.getClass(), e );\n}\n}\n}\ncatch ( MavenReportException e )\n{\nthrow new RendererException( \"Error rendering Maven report: \" + e.getMessage(), e );\n}\nfinally\n        {\nsink.close();\n}\nif (!report.isExternalReport() )\n{\ntry\n            {\nList<MySink> sinks = sf.sinks();\nlog.debug( \"Multipage report: \" + sinks.size() + \" subreports\" );\nfor ( MySink mySink : sinks )\n{\nmySink.enableLogging( new MojoLogWrapper( log ) );\nlog.debug( \"  Rendering \" + mySink.getOutputName() );\nWriter out = new FileWriter( new File( mySink.getOutputDir(), mySink.getOutputName() ) );\ntry\n                        {\nrenderer.generateDocument( out, mySink, siteRenderingContext );\n}\nfinally\n                        {\nmySink.close();\n}\n}\n}\ncatch ( IOException e )\n{\nthrow new RendererException( \"Cannot create writer\", e );\n}\nrenderer.generateDocument( writer, sink, siteRenderingContext );\n}\n}", "4385": "protected void runJob(final Job job) {\nfinal Scheduler.JobInfo jobInfo = new Scheduler.JobInfo(job.jobId, job.detail, 0);\ntry {\n_jobProcessor.onScheduledJob(jobInfo);\n} catch (Exception ex) {\n__log.error(\"Error in scheduler processor.\", ex);\n}\n}", "4386": "public void waitForCommands() {\nboolean reset = false;\nboolean executing = false;\nThrowable error = null;\ntry {\nlogger.info(\"Gateway Connection ready to receive messages\");\nString commandLine = null;\ndo {\ncommandLine = reader.readLine();\nexecuting = true;\nlogger.fine(\"Received command: \" + commandLine);\nCommand command = commands.get(commandLine);\nif (command!= null) {\nif (authCommand!= null &&!authCommand.isAuthenticated()) {\ntry {\nauthCommand.execute(commandLine, reader, writer);\n} catch (Py4JException pe) {\nlogger.log(Level.INFO, \"Authentication error.\", pe);\nreset = true;\nreturn;\n}\n} else {\ncommand.execute(commandLine, reader, writer);\n}\nexecuting = false;\n} else {\nlogger.log(Level.WARNING, \"Unknown command \" + commandLine);\nerror = new Py4JException(\"Unknown command \" + commandLine);\nerror.setStackTrace(new StackTraceElement[] {});\nsendError(error);\n}\n} while (commandLine!= null &&!commandLine.equals(\"q\"));\n} catch (SocketTimeoutException ste) {\nlogger.log(Level.WARNING, \"Timeout occurred while waiting for a command.\", ste);\nreset = true;\nerror = ste;\n} catch (Exception e) {\nlogger.log(Level.WARNING, \"Error occurred while waiting for a command.\", e);\nerror = e;\n} finally {\nif (error!= null && executing && writer!= null) {\nquietSendFatalError(writer, error);\n}\nshutdown(reset);\n}\n}", "4390": "private void handleAssociationMethodCallExpression(BlockStatement newCode, MethodCallExpression methodCall, List<String> propertyNames) {\nExpression method = methodCall.getMethod();\nString methodName = method.getText();\nArgumentListExpression arguments = methodCall.getArguments() instanceof ArgumentListExpression? (ArgumentListExpression) methodCall.getArguments() : null;\nif(isAssociationMethodCall(propertyNames, methodName, arguments)) {\nClosureAndArguments closureAndArguments = new ClosureAndArguments();\nClosureExpression associationQuery = (ClosureExpression) arguments.getExpression(0);\nBlockStatement currentBody = closureAndArguments.getCurrentBody();\nArgumentListExpression argList = closureAndArguments.getArguments();\nnewCode.addStatement(new ExpressionStatement(new MethodCallExpression(THIS_EXPRESSION, methodName, argList)));\nStatement associationCode = associationQuery.getCode();\nif(associationCode instanceof BlockStatement) {\naddBlockStatementToNewQuery((BlockStatement) associationCode,currentBody, true, propertyNames);\n}\n}\nelse {\nthrow new CompilationException(\"Association method call failed.\", methodCall);\n}\n}", "4391": "private static List<AbstractPreferenceController> buildPreferenceControllers(Context context,\n            Activity activity, Fragment fragment, Lifecycle lifecycle) {\nfinal List<AbstractPreferenceController> controllers = new ArrayList<>();\ncontrollers.add(new PhoneNumberPreferenceController(context));\ncontrollers.add(new BrandedAccountPreferenceController(context));\ncontrollers.add(new SimStatusPreferenceController(context, fragment));\ncontrollers.add(new DeviceModelPreferenceController(context, fragment));\ncontrollers.add(new ImeiInfoPreferenceController(context, fragment));\ncontrollers.add(new FirmwareVersionPreferenceController(context, fragment));\ncontrollers.add(new ImsStatusPreferenceController(context, lifecycle));\ncontrollers.add(new IpAddressPreferenceController(context, lifecycle));\ncontrollers.add(new WifiMacAddressPreferenceController(context, lifecycle));\ncontrollers.add(new BluetoothAddressPreferenceController(context, lifecycle));\ncontrollers.add(new RegulatoryInfoPreferenceController(context));\ncontrollers.add(new SafetyInfoPreferenceController(context));\ncontrollers.add(new ManualPreferenceController(context));\ncontrollers.add(new FeedbackPreferenceController(fragment, context));\ncontrollers.add(new FccEquipmentIdPreferenceController(context));\ncontrollers.add(\n                new BuildNumberPreferenceController(context, activity, fragment, lifecycle, true));\nreturn controllers;\n}", "4397": "public void testBasicPositioning() {\nprepSession();\nAndroidBrowserRepositorySession session = getSession();\nRecord[] expected = new Record[] {\n        BookmarkHelpers.createBookmark1(),\n        BookmarkHelpers.createFolder1(),\n        BookmarkHelpers.createBookmark2()\n    };\ndoStore(session, expected);\nExpectFetchDelegate delegate = new ExpectFetchDelegate(expected);\nperformWait(fetchAllRunnable(session, delegate));\nLog.i(\"poop\", \"poo\");\n// TODO check android positions \n}", "4400": "@Test @Ignore\npublic void testUserAttributes() throws Exception {\nLDAPIdentityStore store = new LDAPIdentityStore();\nstore.setConfiguration(getConfiguration());\nDefaultIdentityManager im = new DefaultIdentityManager(\n                new DefaultIdentityStoreInvocationContextFactory(null));\nim.setIdentityStore(store);\n// Let us create an user\nUser user = im.createUser(\"Anil Saldhana\");\nassertNotNull(user);\nUser anil = im.getUser(\"Anil Saldhana\");\nassertNotNull(anil);\nassertEquals(\"Anil Saldhana\", anil.getFullName());\nassertEquals(\"Anil\", anil.getFirstName());\nassertEquals(\"Saldhana\", anil.getLastName());\n// Deal with Anil's attributes\nstore.setAttribute(null, anil, \"QuestionTotal\", new String[] { \"2\" });\nstore.setAttribute(null, anil, \"Question1\", new String[] { \"What is favorite toy?\" });\nstore.setAttribute(null, anil, \"Question1Answer\", new String[] { \"Gum\" });\nstore.setAttribute(null, anil, \"Question2\", new String[] { \"What is favorite word?\" });\nstore.setAttribute(null, anil, \"Question2Answer\", new String[] { \"Hi\" });\n// let us retrieve the attributes from ldap store and see if they are the same\nanil = im.getUser(\"Anil Saldhana\");\nMap<String, String[]> attributes = anil.getAttributes();\nassertNotNull(attributes);\nassertEquals(\"2\", attributes.get(\"QuestionTotal\")[0]);\nassertEquals(\"What is favorite toy?\", attributes.get(\"Question1\")[0]);\nassertEquals(\"Gum\", attributes.get(\"Question1Answer\")[0]);\nassertEquals(\"What is favorite word?\", attributes.get(\"Question2\")[0]);\nassertEquals(\"Hi\", attributes.get(\"Question2Answer\")[0]);\n}", "4401": "public static void LoadData(String filename, String password, String keyfile) throws InvalidCipherTextException, IOException, InvalidKeyFileException, FileNotFoundException {\nFileInputStream fis;\nfis = new FileInputStream(filename);\nImporterV3 Importer = new ImporterV3(false);\nmPM = Importer.openDatabase(fis, password, keyfile);\nif ( mPM!= null ) {\nmPM.constructTree(null);\npopulateGlobals(null);\n}\nmFilename = filename;\n}", "4407": "public void setTestFile(File value) {\nif (UtilityFunctions.isNotSet(value)) return;\nthis.testFile = value.getAbsolutePath();\nthis.argumentMap.put(JMeterCommandLineArguments.TESTFILE_OPT, true);\nthis.argumentMap.put(JMeterCommandLineArguments.RESULTSFILE_OPT, true);\nthis.argumentMap.put(JMeterCommandLineArguments.LOGFILE_OPT, true);\n}", "4412": "void updateState(int newThreadId) {\nCThread[] oldThreads = currentThreads;\n// get the new Threads.\nCThread[] newThreads = getCThreads();\n// Fire destroyedEvent for old threads.\nif (oldThreads!= null && oldThreads.length > 0) {\nList dList = new ArrayList(oldThreads.length);\nfor (int i = 0; i < oldThreads.length; i++) {\nboolean found = false;\nfor (int j = 0; j < newThreads.length; j++) {\nif (newThreads[j].getId() == ((CThread)oldThreads[i]).getId()) {\nfound = true;\nbreak;\n}\n}\nif (!found) {\ndList.add(new Integer(oldThreads[i].getId()));\n}\n}\nif (!dList.isEmpty()) {\nfor (Iterator i = dList.iterator(); i.hasNext();) {\nint id = (Integer) i.next();\nCThread thread = new Thread(id, new ThreadGroup(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id), new Thread(id),", "4414": "private void expectUnexpectedFrameError(Confuser confuser)\nthrows IOException {\n((ConfusedFrameHandler)((AMQConnection)connection).\nconfuser = confuser;\n//NB: the frame confuser relies on the encoding of the\n//method field to be at least 8 bytes long\nchannel.basicPublish(\"\", \"routing key\", null, \"Hello\".getBytes());\nexpectError(AMQP.UNEXPECTED_FRAME);\n}", "4416": "@Before\npublic void setUp() throws Exception {\nsuper.setUp();\nApptentiveInternal.setInstance(new ApptentiveInternal(InstrumentationRegistry.getTargetContext()));\nencryptionKey = generateEncryptionKey();\n}", "4420": "@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\nsuper.onOptionsItemSelected(item);\nswitch (item.getItemId()) {\ncase android.R.id.home:\nfinish();\nreturn true;\ncase R.id.menu_create_group:\nfindViewById(R.id.group_details_layout).setVisibility(View.GONE);\nfindViewById(R.id.creating_group_layout).setVisibility(View.VISIBLE);\n((TextView)findViewById(R.id.creating_group_text)).setText(\"Creating \" + groupName.getText().toString() + \"...\");\nnew AsyncTask<Void,Void,Void>() {\n\n          @Override\nprotected Void doInBackground(Void... voids) {\ntry {\nThread.sleep(5000); // todo network things\n} catch (InterruptedException e) {\nThread.currentThread().interrupt();\n}\nreturn null;\n}\n@Override\nprotected void onPostExecute(Void aVoid) {\nsuper.onPostExecute(aVoid);\nfinish();\n}\n@Override\nprotected void onProgressUpdate(Void... values) {\nsuper.onProgressUpdate(values);\n}\n        }.execute();\nreturn true;\n}\nreturn false;\n}", "4421": "public void helpOnClick(View view) {\nif (view instanceof HelpView) {\n((HelpView) view).showHelp();\n}\n}", "4426": "private void fillData() {\nUiUtils.assignTypeface(this, Gh4Application.get(this).boldCondensed, new int[] {\n            R.id.release_notes_title, R.id.downloads_title\n        });\nImageView gravatar = (ImageView) findViewById(R.id.iv_gravatar);\nGravatarHandler.assignGravatar(gravatar, mReleaser);\nString login = mReleaser!= null? mReleaser.getLogin() : mRepoOwner;\nTextView details = (TextView) findViewById(R.id.tv_releaseinfo);\ndetails.setText(getString(R.string.release_details, login,\n                Gh4Application.pt.format(mRelease.getCreatedAt())));\nTextView releaseType = (TextView) findViewById(R.id.tv_releasetype);\nif (mRelease.isDraft()) {\nreleaseType.setText(R.string.release_type_draft);\n} else if (mRelease.isPreRelease()) {\nreleaseType.setText(R.string.release_type_prerelease);\n} else {\nreleaseType.setText(R.string.release_type_final);\n}\nListView downloadsList = (ListView) findViewById(R.id.downloads);\nDownloadAdapter adapter = new DownloadAdapter(this);\nadapter.addAll(mRelease.getAssets());\ndownloadsList.setAdapter(adapter);\ndownloadsList.setOnItemClickListener(this);\n}", "4428": "private void reloadSync() throws PEBKACException, ObjectMappingException, PermissionsLoadingException {\ntry {\nrawConfig = configLoader.load();\nConfigurationNode fallbackConfig;\ntry {\nfallbackConfig = loadDefaultConfiguration();\n} catch (IOException e) {\nthrow new Error(\"PEX's default configuration could not be loaded!\", e);\n}\nrawConfig.mergeValuesFrom(fallbackConfig);\nconfig = PermissionsExConfiguration.MAPPER.bindToNew().populate(rawConfig);\nconfig.validate();\nPermissionsEx oldManager = manager;\nmanager = new PermissionsEx(config, this);\nif (oldManager!= null) {\noldManager.close();\n}\nsubjectCollections.invalidateAll();\ndefaults = (PEXSubject) getSubjects(\"default\").get().get(\"global\");\ncontextCalculator.update(config);\n} catch (IOException e) {\nthrow new PEBKACException(\"Error while loading configuration: \" + e.getLocalizedMessage());\n}\n}", "4430": "@Override\npublic void setClientInfo(String name, String value) throws SQLClientInfoException {\nif (value == null) {\nvalue = \"\";\n}\nif (value.length() > 0) {\nvalue = \"'\" + value + \"'\";\n}\ngetConnection().getMetaData().setClientInfo(name, value);\n}", "4432": "public void persisted() {\nif (removeExisting) {\n// invalidate the complete tree\ntry {\nNodeState rootState = destMgrProvider.getItemStateManager().getRootState();\nrootState.invalidate(true);\n} catch (ItemStateException e) {\nlog.error(\"Cannot invalidate root state.\", e.getMessage());\n}\n} else {\nsuper.persisted();\n}\n}", "4433": "public static void clearLog() {\nif (!StorageUtils.ENABLE_LOG_PURGING) return;\nif (true) return;\ntry {\nFile orig = new File(StorageUtils.getErrorLog());\nFile backup = new File(StorageUtils.getErrorLog() + \".bak\");\nif (orig.exists() && orig.length() > 0)\norig.renameTo(backup);\n} catch (Exception e) {\n// Ignore backup failure...\n}\nBufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(StorageUtils.getErrorLog()), \"utf8\"), 8192);\nout.write(\"\");\nout.close();\n} catch (Exception e1) {\n// do nothing - we can't log an error in the error logger. (and we don't want to FC the app)\n}\n}", "4434": "@Test\n@InSequence(1)\npublic void testRestUrlStartHumanTaskProcess() throws Exception {\n// create REST request\nString urlString = new URL(deploymentUrl, \"/arquillian-test/rest/runtime/test/process/org.jbpm.humantask/start\").toExternalForm();\nSystem.out.println( \">> \" + urlString );\nClientRequest restRequest = new ClientRequest(urlString);\n// Get and check response\nClientResponse responseObj = restRequest.post();\nassertEquals(200, responseObj.getStatus());\nurlString = deploymentUrl.toExternalForm() + \"/rest/task/query?taskOwner=salaboy\";\nrestRequest = new ClientRequest(urlString);\nresponseObj = restRequest.post();\nassertEquals(200, responseObj.getStatus());\nList<JaxbTaskSummary> list = (List<JaxbTaskSummary>) responseObj.getEntity(List.class);\nlong taskId = list.get(0).getId();\nurlString = new URL(deploymentUrl, \"/arquillian-test/rest/task/\" + taskId + \"/start?userId=salaboy\").toExternalForm();\nSystem.out.println( \">> \" + urlString );\nrestRequest = new ClientRequest(urlString);\n// Get response\nresponseObj = restRequest.post();\n// Check response\nassertEquals(200, responseObj.getStatus());\nresult = responseObj.getEntity();\nSystem.out.println(result);\n}", "4438": "public void restoreState(Element el) throws SaveException {\nif (el.getTagName().equals(\"input\")) {\nString name = el.getAttribute(\"name\");\nString value = el.getAttribute(\"value\");\nif (name.equals(\"password\")) {\nif (value == null) {\nvalue = \"\";\n}\nel.setAttribute(\"value\", value);\n} else if (name.equals(\"password-confirmation\")) {\nif (value == null) {\nvalue = \"\";\n}\nel.setAttribute(\"value\", value);\n}\n}\n}", "4439": "public void clear() {\nif (assetCache.isUnloaded()) {\nfor (Asset asset : assetCache.getUnloadedAssets()) {\nunloadAsset(asset);\n}\n}\nassetCache.clear();\n}", "4440": "private void handleInfoAction(final Context context, final Intent intent) {\nfinal ConnectorSpec specs = new ConnectorSpec(intent);\nfinal ConnectorCommand command = new ConnectorCommand(intent);\nif (specs == null) {\nreturn;\n}\ntry {\nWebSMS.addConnector(specs);\n} catch (Exception e) {\nLog.e(TAG, \"error while receiving broadcast\", e);\n}\n// save send messages\nif (command == null) {\nreturn;\n}\nif (command.getType() == ConnectorCommand.TYPE_SEND) {\nthis.handleSendCommand(specs, context, intent, command);\n}\n}", "4443": "private static String constructMessage( String message, String groupId, String artifactId, String version,\n                                            String type, List remoteRepositories, String downloadUrl )\n{\nStringBuffer sb = new StringBuffer();\nsb.append( message );\nsb.append( LS );\nsb.append( \"  \" + groupId + \":\" + artifactId + \":\" + version + \":\" + type );\nsb.append( LS );\nsb.append( LS );\nsb.append( \"from the specified remote repositories:\" );\nsb.append( LS + \"  \" );\nfor ( Iterator i = remoteRepositories.iterator(); i.hasNext(); )\n{\nArtifactRepository remoteRepository = (ArtifactRepository) i.next();\nsb.append( remoteRepository.getUrl() );\nif ( i.hasNext() )\n{\nsb.append( \", \" );\n}\n}\nsb.append( LS );\nsb.append( \"Try downloading the file manually\" );\nif ( downloadUrl!= null )\n{\nsb.append( \" from \" );\nsb.append( LS );\nsb.append( \"  \" + downloadUrl );\n}\nsb.append( LS );\nsb.append( \"and install it using the command: \" );\nsb.append( LS );\nsb.append( \"  m2 install:install-file -DgroupId=\" );\nsb.append( groupId );\nsb.append( \" -DartifactId=\" );\nsb.append( artifactId );\nsb.append( \" -Dversion=\" );\nsb.append( version );\nsb.append( \" -Dpackaging=\" );\nsb.append( type );\nsb.append( \" -Dfile=/path/to/file\" );\nreturn sb.toString();\n}", "4444": "protected void loadSpells(ConfigurationNode config)\n{\nif (config == null) return;\nList<String> spellKeys = config.getKeys();\nfor (String key : spellKeys)\n{\nConfigurationNode spellNode = config.getNode(key);\nif (!spellNode.getBoolean(\"enabled\", true)) {\ncontinue;\n}\nSpell newSpell = Spell.loadSpell(key, spellNode, this);\nif (newSpell == null)\n{\ngetLogger().warning(\"Magic: Error loading spell \" + key);\ncontinue;\n}\naddSpell(newSpell);\n}\n}", "4446": "public void testGetResultDescription() throws Exception {\n{\nFreeStyleProject project = createFreeStyleProject();\nAbstractBuild<?,?> build = project.scheduleBuild2(0).get(10, TimeUnit.SECONDS);\nassertEquals(\"SUCCESS\", BuildHelper.getResultDescription(build));\nproject.getBuildersList().add(new FailureBuilder());\nbuild = project.scheduleBuild2(0).get(10, TimeUnit.SECONDS);\nassertEquals(\"FAILURE\", BuildHelper.getResultDescription(build));\nbuild = project.scheduleBuild2(0).get(10, TimeUnit.SECONDS);\nassertEquals(\"STILL FAILING\", BuildHelper.getResultDescription(build));\nproject.getBuildersList().remove(FailureBuilder.class);\nbuild = project.scheduleBuild2(0).get(10, TimeUnit.SECONDS);\nassertEquals(\"FIXED\", BuildHelper.getResultDescription(build));\n//            project.getBuildersList().add(new UnstableBuilder());\n//            build = project.scheduleBuild2(0).get(10, TimeUnit.SECONDS);\n//            assertEquals(\"UNSTABLE\", BuildHelper.getResultDescription(build));\n//            \n//            build = project.scheduleBuild2(0).get(10, TimeUnit.SECONDS);\n//            assertEquals(\"STILL UNSTABLE\", BuildHelper.getResultDescription(build));\n//            \n//            project.getBuildersList().remove(UnstableBuilder.class);\n//            build = project.scheduleBuild2(0).get(10, TimeUnit.SECONDS);\n//            assertEquals(\"FIXED\", BuildHelper.getResultDescription(build));\n}\n// TODO: test some more\n}", "4447": "private void installCertFromSdCard() {\nstartActivity(new Intent(CertTool.ACTION_INSTALL_CERT_FROM_SDCARD));\n}", "4448": "private void addRadioButton(XMLElement spec)\n{\nVector forPacks = spec.getChildrenNamed(SELECTEDPACKS);\nVector forOs = spec.getChildrenNamed(OS);\nString variable = spec.getAttribute(VARIABLE);\nString value = null;\nXMLElement element = null;\nJLabel label;\nButtonGroup group = new ButtonGroup();\nTwoColumnConstraints constraints = new TwoColumnConstraints();\nconstraints.position = TwoColumnConstraints.BOTH;\nconstraints.indent = true;\nconstraints.stretch = true;\n// ----------------------------------------------------\n// get the description and add it to the list of UI\n// elements if it exists.\n// ----------------------------------------------------\nelement = spec.getFirstChildNamed(DESCRIPTION);\naddDescription(element, forPacks, forOs);\n// ----------------------------------------------------\n// extract the specification details\n// ----------------------------------------------------\nelement = spec.getFirstChildNamed(SPEC);\nif (element!= null)\n{\nlabel = new JLabel(getText(element));\nVector choices = element.getChildrenNamed(RADIO_CHOICE);\nif (choices == null) { return; }\n// --------------------------------------------------\n// process each choice element\n// --------------------------------------------------\nfor (int i = 0; i < choices.size(); i++)\n{\nJRadioButton choice = new JRadioButton();\nchoice.setText(getText((XMLElement) choices.elementAt(i)));\nvalue = (((XMLElement) choices.elementAt(i)).getAttribute(RADIO_VALUE));\ngroup.add(choice);\nString set = ((XMLElement) choices.elementAt(i)).getAttribute(SET);\nif (set!= null)\n{\nif (set.equals(TRUE))\n{\nchoice.setSelected(true);\n}\n}\nbuttonGroups.add(group);\nuiElements.add(new Object[] { null, RADIO_FIELD, variable, constraints, choice,\n                        forPacks, forOs, value, null, null, group});\n}\n}\n}", "4450": "@Override\npublic void endElement(String uri, String localName, String name)\nthrows SAXException {\nif (TAG_NODE.equals(name)) {\n// reduce prefix\nremoveSuffix();\n} else if (TAG_ITEMLIST.equals(name)) {\ntry {\nif (listValues.size() > 0) {\nString[] values = new String[listValues.size()];\nint i = 0;\nfor (String v : listValues) {\nvalues[i++] = v;\n}\n((ListParameter) currentParameter).fillFromStrings(values);\n}\n} catch (InvalidParameterValueException e) {\n// should not happen\ne.printStackTrace();\n}\nextractedParameters.put(currentPath + currentParameter.getKey(),\n\t\t\t\t\tcurrentParameter);\n// reset for the next iteration\ncurrentParameter = null;\n} else if (TAG_PARAMETERS.equals(name)) {\nparentHandler.setParameters(extractedParameters);\nPort[] portArray = new Port[0];\nparentHandler.setInputPorts(inputPorts.toArray(portArray));\nparentHandler.setOutputPorts(outputPorts.toArray(portArray));\nxmlReader.setContentHandler(parentHandler);\n} else if (TAG_LISTITEM.equals(name)) {\n// nothing to do here\n} else if (TAG_ITEM.equals(name)) {\n// nothing to do here\n}\n}", "4451": "public void go() throws Exception {\n// Set the executors to one and restart\nJenkins.get().setNumExecutors(1);\n// Reload the configuration\nConfiguration configuration = Jenkins.get().getConfiguration();\nconfiguration.reload();\n}", "4458": "@Test\npublic void testCompareNewWithOldAfterCopy() throws IOException {\nFile temp1 = File.createTempFile(getClass().getSimpleName(), \".txt\");\ntemp1.deleteOnExit();\nFile temp2 = File.createTempFile(getClass().getSimpleName(), \".txt\");\ntemp2.deleteOnExit();\nassertTrue(temp1.exists() && temp2.exists());\n// Need to explicitly ask not to preserve the last modified date when we\n// copy...\nFileUtils.copyFile(new File(\"pom.xml\"), temp1, false);\nassertEquals(1, comparator.compare(new FileSystemResource(temp1), new FileSystemResource(temp2)));\n}", "4462": "public void paintChildren(Context c, Box box) {\nif (box.isAnonymous()) {\nreturn;\n}\nif (LayoutUtil.isBlockLayout(box.getElement(), c)) {\nsuper.paintChildren(c, box);\n}\n}", "4463": "public void copyDBTo(File fileOrDirTo) throws Exception {\nif (DB_PATH == null) {\nthrow new IllegalStateException(\"Copy in-memory db? No way!\");\n}\nFile fileFrom = new File(DB_PATH);\nFile fileTo = fileOrDirTo.isDirectory()? new File(fileOrDirTo,\n\t\t\t\tDB_PATH.substring(DB_PATH.lastIndexOf('/', DB_PATH.length())))\n: fileOrDirTo;\nif (fileFrom.exists()) {\nFileChannel src = new FileInputStream(fileFrom).getChannel();\nFileChannel dst = new FileOutputStream(fileTo).getChannel();\ndst.transferFrom(src, 0, src.size());\nsrc.close();\ndst.close();\n}\n}", "4464": "private void openProcessInstance(IValue processInstance, IViewPart view) throws DebugException {\nString id = null;\nString processId = null;\nIVariable[] vars = processInstance.getVariables();\nfor ( int j = 0; j < vars.length; j++ ) {\nIVariable var = vars[j];\nif (\"id\".equals(var.getName())) {\nid = ((IJavaValue)var.getValue()).getValueString();\n} else if (\"process\".equals(var.getName())) {\nIJavaValue process = (IJavaValue) var.getValue();\nIVariable[] vars2 = process.getVariables();\nfor ( int k = 0; k < vars2.length; k++ ) {\nIVariable var2 = vars2[k];\nif (\"id\".equals(var2.getName())) {\nprocessId = ((IJavaValue) var2.getValue()).getValueString();\nbreak;\n}\n}\n}\n}\nList<String> nodeIds = new ArrayList<String>();\nIJavaArray nodeInstances = (IJavaArray) DebugUtil.getValueByExpression(\"return getNodeInstances().toArray();\", processInstance);\nIJavaValue[] javaVals = nodeInstances.getValues();\nfor ( int i = 0; i < javaVals.length; i++ ) {\nIJavaValue nodeInstance = javaVals[i];\nString nodeId = null;\nvars = nodeInstance.getVariables();\nfor ( int j = 0; j < vars.length; j++ ) {\nIVariable var = vars[j];\nif (\"nodeId\".equals(var.getName())) {\nnodeId = ((IJavaValue) var.getValue()).getValueString();\n}\n}\nnodeIds.add(nodeId);\n}\n((ProcessInstanceViewer) view).showProcessInstance(id, processId, nodeIds);\n}", "4465": "private void setupWorlds() {\nArrayList<World> worlds = new ArrayList<World>();\nfor (WorldConfigurationNode worldNode : VanillaConfiguration.WORLDS.getAll()) {\nif (worldNode.LOAD.getBoolean()) {\n// Obtain generator and start generating world\nString generatorName = worldNode.GENERATOR.getString();\nVanillaGenerator generator = VanillaGenerators.byName(generatorName);\nif (generator == null) {\nthrow new IllegalArgumentException(\"Invalid generator name for world '\" + worldNode.getWorldName() + \"': \" + generatorName);\n}\nWorld world = engine.loadWorld(worldNode.getWorldName(), generator);\n// Apply general settings\nworld.getDataMap().put(VanillaData.GAMEMODE, GameMode.get(worldNode.GAMEMODE.getString()));\nworld.getDataMap().put(VanillaData.DIFFICULTY, Difficulty.get(worldNode.DIFFICULTY.getString()));\nworld.getDataMap().put(VanillaData.DIMENSION, Dimension.get(worldNode.SKY_TYPE.getString()));\n// Grab safe spawn if newly created world.\nif (world.getAge() <= 0) {\nworld.setSpawnPoint(new Transform(new Point(generator.getSafeSpawn(world)), Quaternion.IDENTITY, Vector3.ONE));\n}\n// Add to worlds\nworlds.add(world);\n}\n}\nfinal int radius = VanillaConfiguration.SPAWN_RADIUS.getInt();\nfinal int protectionRadius = VanillaConfiguration.SPAWN_PROTECTION_RADIUS.getInt();\nfinal int diameter = (radius << 1) + 1;\nfinal int total = (diameter * diameter * diameter) / 6;\nfinal int progressStep = total / 10;\nfinal OutwardIterator oi = new OutwardIterator();\nSpawnLoaderThread[] loaderThreads = new SpawnLoaderThread[LOADER_THREAD_COUNT];\nif (worlds.isEmpty()) {\nreturn;\n}\n//Register protection service used for spawn protection.\nengine.getServiceManager().register(ProtectionService.class, new VanillaProtectionService(), this, ServiceManager.ServicePriority.Highest);\nfor (World world : worlds) {\n// Initialize the first chunks\nPoint point = world.getSpawnPoint().getPosition();\nint cx = point.getBlockX() >> Chunk.BLOCKS.BITS;\nint cy = point.getBlockY() >> Chunk.BLOCKS.BITS;\nint cz = point.getBlockZ() >> Chunk.BLOCKS.BITS;\n((VanillaProtectionService) engine.getServiceManager().getRegistration(ProtectionService.class).getProvider()).addProtection(new SpawnProtection(world.getName() + \" Spawn Protection\", world, point, protectionRadius));\nfinal String initChunkType = world.getAge() <= 0? \"Generating\" : \"Loading\";\nfor (int i = 0; i < LOADER_THREAD_COUNT; i++) {\nloaderThreads[i] = new SpawnLoaderThread(total, progressStep, initChunkType);\n}\noi.reset(cx, cy, cz, radius);\nwhile (oi.hasNext()) {\nIntVector3 v = oi.next();\nSpawnLoaderThread.addChunk(world, v.getX(), v.getY(), v.getZ());\n}\nfor (int i = 0; i < LOADER_THREAD_COUNT; i++) {\nloaderThreads[i].start();\n}\nfor (int i = 0; i < LOADER_THREAD_COUNT; i++) {\ntry {\nloaderThreads[i].join();\n} catch (InterruptedException ie) {\ngetLogger().info(\"Interrupted when waiting for spawn area to load\");\n}\n}\nWorldConfigurationNode worldConfig = VanillaConfiguration.WORLDS.getOrCreate(world);\n// Keep spawn loaded\nif (worldConfig.LOADED_SPAWN.getBoolean()) {\nworld.createAndSpawnEntity(point, ObserverComponent.class, LoadOption.LOAD_GEN);\n}\n}\n}", "4467": "protected void generateLifecycleEventDeliveryMethods(\n          MetaClass entityType,\n          AnonymousClassStructureBuilder classBuilder) {\nfor (Class<? extends Annotation> eventType : LIFECYCLE_EVENT_TYPES) {\nBlockBuilder<AnonymousClassStructureBuilder> methodBuilder =\n              classBuilder.publicMethod(\n                      Void.TYPE,\n                      \"deliver\" + eventType.getSimpleName(),\n                      Parameter.of(entityType, \"targetEntity\"));\nfor (MetaMethod callback : entityType.getMethodsAnnotatedWith(eventType)) {\nif (!callback.isPublic()) {\nPrivateAccessUtil.addPrivateAccessStubs(true, classBuilder, callback, new Modifier[] {});\nmethodBuilder.append(\n                  Stmt.loadVariable(\"this\")\n.invoke(PrivateAccessUtil.getPrivateMethodName(callback), Stmt.loadVariable(\"targetEntity\")));\n}\nelse {\nmethodBuilder.append(Stmt.loadVariable(\"targetEntity\").invoke(callback));\n}\n}\nmethodBuilder.finish();\n}\n}", "4474": "@Override\npublic void onBindViewHolder(final OutlineItem holder, final int position) {\nfinal int positionInItems = position - numExtraItems;\nOrgFile file = null;\ntry{\nfile = items.get(positionInItems);\n} catch(ArrayIndexOutOfBoundsException ignored){}\nfinal boolean conflict = (file!= null && file.getState() == OrgFile.State.kConflict);\nString title;\nif(position == 0) {\ntitle = activity.getResources().getString(R.string.menu_todos);\n} else if (position == 1){\ntitle = activity.getResources().getString(R.string.menu_agenda);\n} else {\ntitle = items.get(positionInItems).name;\n}\nholder.titleView.setText(title);\nTextView comment = (TextView)holder.mView.findViewById(R.id.comment);\nif (conflict) {\ncomment.setText(R.string.conflict);\ncomment.setVisibility(View.VISIBLE);\n} else {\ncomment.setVisibility(View.GONE);\n}\nholder.mView.setActivated(selectedItems.get(position, false));\nfinal long itemId = getItemId(position);\nholder.mView.setOnClickListener(new View.OnClickListener() {\n            @Override\npublic void onClick(View v) {\nif (getSelectedItemCount() > 0) {\nif(!isSelectableItem(position)) return;\ntoggleSelection(position);\n} else {\nif (mTwoPanes) {\nBundle arguments = new Bundle();\nif(position == 0){\narguments.putLong(OrgContract.NODE_ID, OrgContract.TODO_ID);\n} else if (position == 1){\narguments.putLong(OrgContract.NODE_ID, OrgContract.AGENDA_ID);\n} else {\narguments.putLong(OrgContract.NODE_ID, itemId);\n}\nOrgNodeDetailFragment fragment = new OrgNodeDetailFragment();\nfragment.setArguments(arguments);\nAppCompatActivity activity = (AppCompatActivity) v.getContext();\nactivity.getSupportFragmentManager().beginTransaction()\n.replace(R.id.orgnode_detail_container, fragment)\n.commit();\n} else {\nContext context = v.getContext();\nIntent intent;\n// Special activity for conflicted file\nif(conflict){\nintent = new Intent(context, ConflictResolverActivity.class);\n} else  {\nintent = new Intent(context, OrgNodeDetailActivity.class);\n}\nif(position == 0){\nintent.putExtra(OrgContract.NODE_ID, OrgContract.TODO_ID);\n} else if (position == 1){\nintent.putExtra(OrgContract.NODE_ID, OrgContract.AGENDA_ID);\n} else {\nintent.putExtra(OrgContract.NODE_ID, itemId);\n}\ncontext.startActivity(intent);\n}\n}\n}\n        });\nholder.mView.setOnLongClickListener(new View.OnLongClickListener() {\n            @Override\npublic boolean onLongClick(View v) {\n// Do nothing when user select Agenda.org or Todos.org\nif(!isSelectableItem(position)) return true;\ntoggleSelection(position);\nreturn true;\n}\n        });\n}", "4475": "@Test\npublic void shouldUpdateTimestamp() throws Exception {\nsleep(500);\natomEntry.updateTimestamp();\nassertTrue(calendar.getTime()!= atomEntry.getUpdated().getTime());\n}", "4477": "private void initializeWindowCache() {\nwindows = new WindowCache(256 * 1024 * 1024, 4);\n}", "4478": "protected void doPost(HttpServletRequest servletRequest,\n      HttpServletResponse servletResponse)\nthrows ServletException, IOException {\nString path = servletRequest.getPathInfo();\nlogger.finest(\"Handling restful request for \" + path);\nservletRequest.setCharacterEncoding(\"UTF-8\");\nString route = getRouteFromParameter(path);\nClass<? extends DataRequestHandler> handlerClass = handlers.get(route);\nif (handlerClass == null) {\nthrow new RuntimeException(\"No handler for route: \" + route);\n}\nDataRequestHandler handler = injector.getInstance(handlerClass);\nBeanConverter converter = getConverterForRequest(servletRequest);\nhandler.setConverter(converter);\nString method = getHttpMethodFromParameter(servletRequest.getMethod(),\n        servletRequest.getParameter(X_HTTP_METHOD_OVERRIDE));\nSecurityToken token;\ntry {\ntoken = securityTokenDecoder.createToken(servletRequest.getParameter(SECURITY_TOKEN_PARAM));\n} catch (SecurityTokenException e) {\nthrow new RuntimeException(\n          \"Implement error return for bad security token.\");\n}\nResponseItem responseItem = handler.handleMethod(\n        new RequestItem(servletRequest, token, method));\nif (responseItem.getError() == null) {\nPrintWriter writer = servletResponse.getWriter();\nwriter.write(converter.convertToString(responseItem.getResponse()));\n} else {\nservletResponse.sendError(responseItem.getError().getHttpErrorCode(),\n          responseItem.getErrorMessage());\n}\n}", "4481": "public void run() {\ntry {\nbyte[] buf = new byte[8192];\nint len;\nwhile ((len = in.read(buf)) > 0)\nout.write(buf, 0, len);\n} finally {\nin.close();\nout.close();\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n}", "4485": "public void testSendIfModifiedSince() throws Exception {\nfetcher().setSendIfModifiedSince(true);\nCrawlURI curi = makeCrawlURI(\"http://localhost:7777/\");\nfetcher().process(curi);\nassertFalse(httpRequestString(curi).toLowerCase().contains(\"if-modified-since\"));\nassertTrue(curi.getHttpResponseHeader(\"last-modified\").equals(\"Thu, 01 Jan 1970 00:00:00 GMT\"));\nrunDefaultChecks(curi);\n// logger.info(\"before FetchHistoryProcessor fetchHistory=\" + Arrays.toString(curi.getFetchHistory()));\nFetchHistoryProcessor fetchHistoryProcessor = new FetchHistoryProcessor();\nfetchHistoryProcessor.process(curi);\n// logger.info(\"after FetchHistoryProcessor fetchHistory=\" + Arrays.toString(curi.getFetchHistory()));\nfetcher().process(curi);\n// logger.info(\"\\n\" + httpRequestString(curi));\nassertTrue(httpRequestString(curi).contains(\"If-Modified-Since: Thu, 01 Jan 1970 00:00:00 GMT\\r\\n\"));\nrunDefaultChecks(curi);\nfetcher().process(curi);\nassertTrue(httpRequestString(curi).contains(\"If-Modified-Since: 0 Sat, 01 Jan 1970 00:00:00 GMT\\r\\n\"));\nrunDefaultChecks(curi);\n// send 304 not-modified and check for it here\nfetcher().process(curi);\nassertTrue(httpRequestString(curi).contains(\"If-Modified-Since: 304 Not-Modified\\r\\n\"));\nrunDefaultChecks(curi);\n}", "4486": "public static void releaseAddress( String s ) {\nAddressUtil.releaseAddress( new Address( s ) );\n}", "4490": "public void stop(BundleContext context) {\nregistration.unregister();\nsessionTracker.close();\nsessionFactoryTracker.close();\nsynchronized (servers) {\nfor (SshServer server : servers) {\ntry {\nserver.stop();\n} catch (InterruptedException e) {\nlogger.warn(e, \"Interrupted while stopping server %s\", server.getRemoteHost());\n}\n}\n}\n}", "4491": "private void updateChangeStatus() {\nfor (final Change c : submitted) {\nfinal CommitMergeStatus s = status.get(c.getId());\nif (s == null) {\n// Shouldn't ever happen, but leave the change alone. We'll pick\n// it up on the next pass.\n//\ncontinue;\n}\nswitch (s) {\ncase CLEAN_MERGE: {\nfinal String txt =\n              \"Change has been successfully merged into the git repository.\";\nsetMerged(c, message(c, txt));\nbreak;\n}\ncase ALREADY_MERGED:\nsetMerged(c, null);\nbreak;\ncase PATH_CONFLICT: {\nfinal String txt =\n              \"Your change could not been merged due to a path conflict.\\n\"\n+ \"\\n\"\n+ \"Please merge (or rebase) the change locally and upload the resolution for review.\";\nsetNew(c, message(c, txt));\nbreak;\n}\ncase MISSING_DEPENDENCY: {\ntry {\nfinal String txt =\n                \"Change could not be merged because of a missing dependency.  As soon as its dependencies are submitted, the change will be submitted.\";\nschema.changeMessages().insert(\n                Collections.singleton(message(c, txt)));\n} catch (OrmException e) {\n}\nbreak;\n}\ndefault:\nsetNew(c, message(c, \"Unspecified merge failure: \" + s.name()));\nbreak;\n}\n}\n}", "4492": "public void testReadFeatRecord() throws Exception {\nHSSFWorkbook hssf = \n\t\t\tHSSFTestDataSamples.openSampleWorkbook(\"46136-NoWarnings.xls\");\nInternalWorkbook wb = HSSFTestHelper.getWorkbookForTest(hssf);\nFeatRecord fr = null;\nFeatHdrRecord fhr = null;\nassertEquals(1, hssf.getNumberOfSheets());\n// First check it isn't on the Workbook\nint countFR = 0;\nint countFRH = 0;\nfor(Record r : wb.getRecords()) {\nif(r instanceof FeatRecord) {\nfr = (FeatRecord)r;\ncountFR++;\n} else if (r.getSid() == FeatRecord.sid) {\nfail(\"FeatRecord SID found but not created correctly!\");\n}\nif(r instanceof FeatHdrRecord) {\ncountFRH++;\n} else if (r.getSid() == FeatHdrRecord.sid) {\nfail(\"FeatHdrRecord SID found but not created correctly!\");\n}\n}\nassertEquals(0, countFR);\nassertEquals(0, countFRH);\n// Now find it on our sheet\nHSSFSheet s = hssf.getSheetAt(0);\nInternalSheet sheet = HSSFTestHelper.getSheetForTest(s);\nfor(RecordBase rb : sheet.getRecords()) {\nif(rb instanceof Record) {\nRecord r = (Record)rb;\nif(r instanceof FeatRecord) {\nfr = (FeatRecord)r;\ncountFR++;\n} else if (r.getSid() == FeatRecord.sid) {\ncountFR++;\n}\nif(r instanceof FeatHdrRecord) {\nfhr = (FeatHdrRecord)r;\ncountFRH++;\n} else if (r.getSid() == FeatHdrRecord.sid) {\ncountFRH++;\n}\n}\n}\nassertEquals(1, countFR);\nassertEquals(1, countFRH);\nassertNotNull(fr);\nassertNotNull(fhr);\n// Now check the contents are as expected\nassertEquals(\n\t\t\t\tFeatHdrRecord.SHAREDFEATURES_ISFFEC2,\n\t\t\t\tfr.getIsf_sharedFeatureType()\n\t\t);\n// Applies to one cell only\nassertEquals(1, fr.getCellRefs().length);\nassertEquals(0, fr.getCellRefs()[0].getFirstRow());\nassertEquals(0, fr.getCellRefs()[0].getLastRow());\nassertEquals(0, fr.getCellRefs()[0].getFirstColumn());\nassertEquals(0, fr.getCellRefs()[0].getLastColumn());\nassertEquals(4, fr.getCbFeatData());\nassertEquals(4, fr.getRgbFeat().length);\n}", "4494": "private void surroundLines(EditorAdaptor editorAdaptor, TextObject selection)\nthrows CommandExecutionException {\nif (indentOperation!= null) {\nindentOperation.execute(editorAdaptor, Command.NO_COUNT_GIVEN, selection);\n}\nnew ChangeDelimiterCommand(new NotYetDelimitedTextObject(selection), delimiters)\n.execute(editorAdaptor);\n}", "4497": "@Override\npublic void widgetSelected(SelectionEvent e) {\nsuper.widgetSelected(e);\nResourceType type = getSelectedResourceType();\n// We currently only support strings\nif (type == ResourceType.STRING) {\nExtractStringRefactoring ref = new ExtractStringRefactoring(true /*enforceNew*/);\nRefactoringWizard wizard = new ExtractStringWizard(ref, mProject);\nRefactoringWizardOpenOperation op = new RefactoringWizardOpenOperation(wizard);\ntry {\nIWorkbench w = PlatformUI.getWorkbench();\nop.run(w.getDisplay().getActiveShell(), wizard.getDefaultPageTitle());\n} catch (InterruptedException ex) {\n// Interrupted. Pass.\n}\n}\n}", "4499": "@OnClick(R.id.integration_web_service)\nvoid onCustomWebServiceClicked() {\nIntent intent;\nif (isCustomWebServiceClicked()) {\nintent = new Intent(getActivity(), CustomWebService.class);\nintent.putExtra(CustomWebService.EXTRA_WEB_SERVICE_TYPE, CustomWebService.TYPE_TWITTER);\ngetActivity().startActivity(intent);\n} else {\nintent = new Intent(getActivity(), CustomWebService.class);\nintent.putExtra(CustomWebService.EXTRA_WEB_SERVICE_TYPE, CustomWebService.TYPE_TWITTER_CUSTOM_SERVICE);\ngetActivity().startActivity(intent);\n}\nshowSnabackar(getView(), \"Twitter Custom Service Clicked\");\n}", "4500": "public void assertWorkingScore(Score presumedScore) {\nStatefulSession tmpWorkingMemory = ruleBase.newStatefulSession();\nScoreCalculator tmpScoreCalculator = workingScoreCalculator.clone();\ntmpWorkingMemory.setGlobal(GLOBAL_SCORE_CALCULATOR_KEY, tmpScoreCalculator);\nfor (Object fact : workingSolution.getFacts()) {\ntmpWorkingMemory.insert(fact);\n}\ntmpWorkingMemory.fireAllRules();\nScore realScore = tmpScoreCalculator.calculateScore();\ntmpWorkingMemory.dispose();\nif (!presumedScore.equals(realScore)) {\nthrow new IllegalStateException(\n                    \"The presumedScore (\" + presumedScore + \") is corrupted because it is not the realScore  (\"\n+ realScore + \").\\n\"\n+ buildConstraintOccurrenceSummary());\n}\n}", "4501": "public WroModel transform(final WroModel input) {\nfinal WroModel model = input;\nfor (final Group group : model.getGroups()) {\nfor (final Resource resource : group.getResources()) {\nLOG.debug(\"resource uri: {}\", resource.getUri());\nfinal UriLocator uriLocator = uriLocatorFactory.getInstance(resource.getUri());\nLOG.debug(\"uriLocator: {}\", uriLocator);\nif (uriLocator instanceof WildcardUriLocatorSupport) {\nfinal WildcardStreamLocator wildcardStreamLocator = ((WildcardUriLocatorSupport)uriLocator).getWildcardStreamLocator();\nif (wildcardStreamLocator.hasWildcard(resource.getUri()) && wildcardStreamLocator instanceof WildcardExpandedHandlerAware) {\nLOG.debug(\"expanding resource uri: {}\", resource.getUri());\n// force the reset of the detector to avoid situations when resources are considered duplicates in unit\n// tests.\nduplicateResourceDetector.reset();\nfinal String baseName = FilenameUtils.getBaseName(resource.getUri());\nLOG.debug(\"baseName: {}\", baseName);\nuriLocator.locate(baseName);\n((WildcardExpandedHandlerAware) wildcardStreamLocator).setWildcardExpanderHandler(createExpanderHandler(group, resource));\ntry {\n// trigger the wildcard replacement\nuriLocator.locate(resource.getUri());\n} catch (final IOException e) {\n// log only\nLOG.error(\"problem while trying to expand wildcard for the following resource uri: \" + resource.getUri());\n} finally {\n//remove the handler, it is not needed anymore\n((WildcardExpandedHandlerAware)wildcardStreamLocator).setWildcardExpanderHandler(null);\n}\n}\n}\n}\n}\nLOG.debug(\"Transformed model: {}\", model);\nreturn model;\n}", "4504": "public void execute() throws RemoteException, ApplicationException\n{\nnew AuslandsUeberweisungNew().handleAction(this.u);\n}", "4506": "public void testAddingClassSimpleAPI() throws Exception {\nManualConfiguration configuration = new ManualConfiguration()\n.addProperty( \"hibernate.search.default.directory_provider\", RAMDirectoryProvider.class.getName() );\nIncrementalSearchFactory sf = new SearchFactoryBuilder().configuration( configuration ).buildSearchFactory();\nSearchFactoryImplementor sfi = (SearchFactoryImplementor) sf;\nsf.addClasses( A.class );\nManualTransactionContext tc = new ManualTransactionContext();\ndoIndexWork( new A(1, \"Emmanuel\"), 1, sfi, tc );\ntc.end();\nQueryParser parser = new QueryParser( SearchTestCase.getTargetLuceneVersion(), \"name\", SearchTestCase.standardAnalyzer );\nQuery luceneQuery = parser.parse( \"Emmanuel\" );\n//we know there is only one DP\nDirectoryProvider provider = sfi\n.getDirectoryProviders( A.class )[0];\nIndexSearcher searcher = new IndexSearcher( provider.getDirectory(), true );\nTopDocs hits = searcher.search( luceneQuery, 1000 );\nassertEquals( 1, hits.totalHits );\nsearcher.close();\nsf.addClasses( B.class, C.class );\ntc = new ManualTransactionContext();\ndoIndexWork( new B(1, \"Noel\"), 1, sfi, tc );\ndoIndexWork( new C(1, \"Vincent\"), 1, sfi, tc );\ntc.end();\nluceneQuery = parser.parse( \"Noel\" );\n//we know there is only one DP\nprovider = sfi.getDirectoryProviders( B.class )[0];\nsearcher = new IndexSearcher( provider.getDirectory(), true );\nhits = searcher.search( luceneQuery, 1000 );\nassertEquals( 1, hits.totalHits );\nluceneQuery = parser.parse( \"Vincent\" );\nprovider = sfi.getDirectoryProviders( C.class )[0];\nsearcher = new IndexSearcher( provider.getDirectory(), true );\nhits = searcher.search( luceneQuery, 1000 );\nassertEquals( 1, hits.totalHits );\nsearcher.close();\nsfi.close();\n}", "4509": "@Override\npublic void reportError(BaseRecognizer recognizer, RecognitionException e)\nthrows RecognitionException\n{\nsuper.reportError(recognizer, e);\nASTNodeStream input = ((TreeParser) recognizer).getInputStream();\nObject root = input.getTreeSource();\nif ( root instanceof AST ) {\nTreeViewer viewer = new TreeViewer(recognizer, (Tree)root);\nviewer.open();\nif ( e instanceof NoViableTreeGrammarAltException ) {\nNoViableTreeGrammarAltException nva =\n\t\t\t\t\t(NoViableTreeGrammarAltException)e;\n//\t\t\t\t((AST)nva.startNode).get\n}\nelse {\n}\n//\t\t\tinput.get()\n//\t\t\tviewer.addHighlightedNodes();\n}\n}", "4512": "public void connect() {\n// if we have channels, then connect, otherwise wait for a channel\ncancelReconnect();\nif (!isConnected() &&!isConnecting() &&!mChannels.isEmpty()) {\nLogger.log(TAG, String.format(Locale.US, \"Connecting to %s\", mSocketURI));\nsetConnectionStatus(ConnectionStatus.CONNECTING);\nmReconnect = true;\nmConnectionProvider.onConnectionRequested(this);\n}\n}", "4515": "@Override\npublic void configure(MessageInputConfiguration config, GraylogServer graylogServer) throws MessageInputConfigurationException {\nthis.core = (Core) graylogServer;\nthis.socketAddress = new InetSocketAddress(config.getAddress(), config.getPort());\n}", "4517": "public void init(SessionImpl session,\n                     ItemManager itemMgr,\n                     QueryHandler handler,\n                     QueryObjectModelTree qomTree,\n                     String language)\nthrows InvalidQueryException, RepositoryException {\ncheckNotInitialized();\nthis.session = session;\nthis.language = language;\nthis.handler = handler;\nthis.qomTree = qomTree;\nthis.statement = null;\nthis.query = handler.createExecutableQuery(session, itemMgr, qomTree);\nsetInitialized();\n}", "4518": "@Override\npublic void onEvent(RequestEvent event, long sequence, boolean endOfBatch) throws Exception {\nString name = null;\ntry {\nif (event.getType() == RequestEvent.Type.TIMESTAMP) {\nname = \"timestampReqProcessor\";\nevent.getMonCtx().timerStart(name);\nhandleTimestamp(event);\n} else if (event.getType() == RequestEvent.Type.COMMIT) {\nname = \"commitReqProcessor\";\nevent.getMonCtx().timerStart(name);\nhandleCommit(event);\n}\n} finally {\nif (null!= name) {\nevent.getMonCtx().timerStop(name);\n}\n}\n}", "4519": "private void calculateCdiMethodInterceptors(BusinessMethodInterceptorInfo methodInterceptorInfo,\n                                                Set<Interceptor<?>> allUsedCdiInterceptors,\n                                                AnnotatedMethod annotatedMethod,\n                                                Set<Annotation> classInterceptorBindings)\n{\nAnnotationManager annotationManager = webBeansContext.getAnnotationManager();\nSet<Annotation> cummulatedInterceptorBindings = new HashSet<Annotation>();\ncummulatedInterceptorBindings.addAll(\n                annotationManager.getInterceptorAnnotations(annotatedMethod.getAnnotations()));\ncummulatedInterceptorBindings.addAll(classInterceptorBindings);\nif (cummulatedInterceptorBindings.size() == 0)\n{\nreturn;\n}\nInterceptionType interceptionType = methodInterceptorInfo.getInterceptionTypes().isEmpty()\n                                               ? InterceptionType.AROUND_INVOKE\n: methodInterceptorInfo.getInterceptionTypes().iterator().next();\nList<Interceptor<?>> methodInterceptors\n= webBeansContext.getBeanManagerImpl().resolveInterceptors(interceptionType, AnnotationUtil.asArray(cummulatedInterceptorBindings));\nmethodInterceptorInfo.setCdiInterceptors(methodInterceptors);\nallUsedCdiInterceptors.addAll(methodInterceptors);\n}", "4521": "@Test\npublic void testTableViewActions() throws Exception\n{\nAllDocsPage page = new AllDocsPage();\npage.gotoPage();\nLiveTableElement livetable = page.clickIndexTab();\nassertThat(livetable.getText(), is(\"Index\"));\n}", "4522": "@Test\npublic void testPurgeSystemOrJobHistory() {\nSystem.out.println(\"purgeSystemOrJobHistory\");\nFile[] itemDirs = null;\nJobConfigHistoryPurger sut = new JobConfigHistoryPurger(mockedPlugin);\nsut.purgeSystemOrJobHistory(itemDirs);\nassertThat(itemDirs, is(nullValue()));\n}", "4526": "@Test\npublic void testInsertGelfMessage() throws Exception {\nGELFMessage message = new GELFMessage();\nmessage.setType(GELFMessage.Type.MESSAGE);\nmessage.setMessageId(1);\nMongoBridge instance = new MongoBridge();\ninstance.insertGelfMessage(message);\nassertThat(message.getType(), is(GELFMessage.Type.MESSAGE));\nassertThat(message.getMessageId(), is(1));\n}", "4528": "void makePrimary(long id) {\nContentValues values = new ContentValues(1);\nvalues.put(Data.IS_SUPER_PRIMARY, 1);\nUri uri = ContentUris.withAppendedId(Data.CONTENT_URI, id);\nmContext.getContentResolver().update(uri, values, null, null);\n}", "4530": "@Test\npublic void test() throws FileNotFoundException, IOException {\n//Schema schema = new Schema.Parser().parse(schemaFile);\n// create the file, write some data\nOutputStream out = new FileOutputStream(testFile);\nString builderName = SyslogAvroEventSerializer.Builder.class.getName();\nEventSerializer serializer =\n        EventSerializerFactory.getInstance(builderName, null, out);\nserializer.afterCreate(); // must call this when a file is newly created\nList<Event> events = generateSyslogEvents();\nfor (Event e : events) {\nserializer.write(e);\n}\nserializer.flush();\nserializer.beforeClose();\nout.flush();\nout.close();\n// now try to read the file back\nDatumReader<GenericRecord> reader = new GenericDatumReader<GenericRecord>();\nDataFileReader<GenericRecord> fileReader =\n        new DataFileReader<GenericRecord>(testFile, reader);\nGenericRecord record = new GenericData.Record(fileReader.getSchema());\nint numEvents = 0;\nwhile (fileReader.hasNext()) {\nfileReader.next(record);\nint facility = (Integer) record.get(\"facility\");\nint severity = (Integer) record.get(\"severity\");\nlong timestamp = (Long) record.get(\"timestamp\");\nString hostname = record.get(\"hostname\").toString();\nString message = record.get(\"message\").toString();\nAssert.assertEquals(\"Facility should be 1\", 1, facility);\nSystem.out.println(timestamp + \": \" + message);\nnumEvents++;\n}\nfileReader.close();\nAssert.assertEquals(\"Should have found a total of 3 events\", 3, numEvents);\nFileUtils.forceDelete(testFile);\n}", "4533": "private void writeFolder(final DataOutput header) throws IOException {\n// one coder\nwriteUint64(header, 1);\nbyte[] id = contentCompression.getId();\nheader.write(id.length);\nheader.write(id);\n}", "4534": "public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\nServiceDomain domain = ServiceDomains.getDomain();\nif (method.getReturnType()!= null && method.getReturnType()!= Void.class) {\nfinal BlockingQueue<Exchange> responseQueue = new ArrayBlockingQueue<Exchange>(1);\nExchangeHandler responseExchangeHandler = new ExchangeHandler() {\n                    public void handleMessage(Exchange exchange) throws HandlerException {\nresponseQueue.offer(exchange);\n}\npublic void handleFault(Exchange exchange) {\nthrow new FaultException(\"Server failed to respond with a fault\", exchange);\n}\n                };\nExchange exchangeIn = domain.createExchange(serviceQName, ExchangePattern.IN_OUT, responseExchangeHandler);\nMessage sendMessage = prepareSend(exchangeIn, args, method);\nexchangeIn.send(sendMessage, exchangeIn.getContext(Scope.MESSAGE));\nExchange exchangeOut = responseQueue.take();\nObject responseObject = exchangeOut.getMessage().getContent();\nreturn responseObject;\n} else {\nExchange exchange = domain.createExchange(serviceQName, ExchangePattern.IN_ONLY, null);\nMessage sendMessage = prepareSend(exchange, args, method);\nexchange.send(sendMessage);\nreturn null;\n}\n}", "4535": "public void start() throws WebServiceConsumeException {\nsynchronized (BaseWebService.class) {\nif (_dispatcher == null) {\nClassLoader origLoader = Thread.currentThread().getContextClassLoader();\ntry {\nPortName portName = _config.getPort();\njavax.wsdl.Service wsdlService = WSDLUtil.getService(_config.getWsdl(), portName);\n_port = WSDLUtil.getPort(wsdlService, portName);\n// Update the portName\nportName.setServiceQName(wsdlService.getQName());\nportName.setName(_port.getName());\nURL wsdlUrl = WSDLUtil.getURL(_config.getWsdl());\nLOGGER.info(\"Creating dispatch with WSDL \" + wsdlUrl);\n// make sure we don't pollute the class loader used by the WS subsystem\nThread.currentThread().setContextClassLoader(getClass().getClassLoader());\nService service = Service.create(wsdlUrl, portName.getServiceQName());\n_dispatcher = service.createDispatch(portName.getPortQName(), SOAPMessage.class, Service.Mode.MESSAGE, new AddressingFeature(false, false));\n// this does not return a proper qualified Fault element and has no Detail so deferring for now\n// BindingProvider bp = (BindingProvider) _dispatcher;\n// bp.getRequestContext().put(\"jaxws.response.throwExceptionIfSOAPFault\", Boolean.FALSE);\n} catch (MalformedURLException e) {\nthrow new WebServiceConsumeException(e);\n} catch (WSDLException wsdle) {\nthrow new WebServiceConsumeException(wsdle);\n} finally {\nThread.currentThread().setContextClassLoader(origLoader);\n}\n}\n}\n}", "4540": "private void serializeSources(List<JoinExpression> joins) {\nappend(templates.getFrom());\nif (joins.isEmpty()) {\nappend(templates.getDummyTable());\n}\nfor (int i = 0; i < joins.size(); i++) {\nJoinExpression je = joins.get(i);\nif (i > 0) {\nappend(templates.getJoinSymbol(je.getType()));\n}\nhandleJoinTarget(je);\nif (je.getCondition()!= null) {\nappend(templates.getOn()).handle(je.getCondition());\n}\n}\n}", "4542": "@Override\npublic void handle(Session session, PingMessage message) {\nif (message.isKeepAlive()) {\nsession.getChannel().close();\n}\n}", "4551": "public void applyParameters(ShaderProgram program) {\nPostProcessingRenderer.FBO scene = PostProcessingRenderer.getInstance().getFBO(\"scene\");\nGL13.glActiveTexture(GL13.GL_TEXTURE1);\nPostProcessingRenderer.getInstance().getFBO(\"sceneBloom2\").bindTexture();\nGL13.glActiveTexture(GL13.GL_TEXTURE2);\nPostProcessingRenderer.getInstance().getFBO(\"sceneBlur2\").bindTexture();\nGL13.glActiveTexture(GL13.GL_TEXTURE3);\nTextureManager.getInstance().bindTexture(\"vignette\");\nGL13.glActiveTexture(GL13.GL_TEXTURE4);\nscene.bindDepthTexture();\nGL13.glActiveTexture(GL13.GL_TEXTURE0);\nPostProcessingRenderer.getInstance().getFBO(\"sceneTonemapped\").bindTexture();\nprogram.setInt(\"texScene\", 0);\nprogram.setInt(\"texBloom\", 1);\nprogram.setInt(\"texBlur\", 2);\nprogram.setInt(\"texVignette\", 3);\nprogram.setInt(\"texDepth\", 4);\nprogram.setFloat(\"viewingDistance\", Config.getInstance().getActiveViewingDistance() * 8.0f);\nif (CoreRegistry.get(LocalPlayer.class).isValid()) {\nprogram.setInt(\"swimming\", tera.getActivePlayer().isHeadUnderWater()? 1 : 0);\n}\n}", "4555": "public void visit(Update operation) throws NoSuchWorkspaceException, AccessDeniedException, LockException, InvalidItemStateException, RepositoryException {\nworkspaceItemStateMgr.execute(operation);\n}", "4557": "public void generate()\nthrows IOException, SAXException, ProcessingException {\nPortalManager portal = null;\nFormManager formManager = null;\ntry {\nformManager = (FormManager) this.manager.lookup(FormManager.ROLE);\nportal = (PortalManager) this.manager.lookup(PortalManager.ROLE);\nthis.xmlConsumer.startDocument();\nfinal Request request = ObjectModelHelper.getRequest(this.objectModel);\nif (request.getSession(false)!= null) {\nportal.showPortal(this.xmlConsumer, false, false);\n}\nthis.xmlConsumer.endDocument();\n} catch (ComponentException ce) {\nthrow new ProcessingException(\"Lookup of PortalManager failed.\", ce);\n} finally {\nthis.manager.release( (Component)formManager);\nthis.manager.release(portal);\n}\n}", "4558": "protected void setTagDirectory(Resource tagDirectory) {\nthis.tagDirectory=tagDirectory;\nthis.tagMapping= new MappingImpl(this,\"/mapping-tag/\",tagDirectory.getAbsolutePath(),null,true,true,true,true,true,true,true);\nTagLib tl=null;\nfor(int i=0;i<tlds.length;i++) {\nif(tlds[i].getNameSpaceAndSeparator().equals(\"cf\"))tl=tlds[i];\n}\n// now overwrite with new data\nif(tagDirectory.isDirectory()) {\nString[] files=tagDirectory.list(new ExtensionResourceFilter(new String[]{\"cfm\",\"cfc\"}));\nfor(int i=0;i<files.length;i++) {\nif(tl!=null)createTag(tl, files[i]);\n}\n}\n}", "4561": "@Override\npublic void storeCredential(IdentityContext context, Account account, CredentialStorage storage) {\nstorage.storeCredential(context, account, credentials);\n}", "4562": "public void testHome() {\nbeginAt(\"/forminput\");\nassertTitleEquals(\"Wicket Examples - forminput\");\n}", "4567": "@Command(\n\t\t\taliases = \"guard\",\n\t\t\tusage = \"flags\",\n\t\t\tdesc = \"view a guard's flags\",\n\t\t\tmodifiers = \"flags\",\n\t\t\tmin = 1,\n\t\t\tmax = 1)\n@CommandPermissions(\"guard.use.flags\")\npublic static void flags(CommandContext args, Player player, HumanNPC npc) {\nif (args.<Boolean>getAny()) {\nplayer.sendMessage(ChatColor.RED + \"All flags are set.\");\n} else {\nplayer.sendMessage(ChatColor.RED + \"Any flag is set.\");\n}\n}", "4568": "void registerSynchronization(Synchronization sync) throws RollbackException, SystemException {\nTransactionContext transactionContext = transactionContextManager.getContext();\nTransaction transaction = null;\nif (transactionContext instanceof InheritableTransactionContext) {\nInheritableTransactionContext inheritableTransactionContext = ((InheritableTransactionContext) transactionContext);\ntransaction = inheritableTransactionContext.getTransaction();\nassert transaction == null || inheritableTransactionContext.isActive(): \"Trying to register a sync on an inactive transaction context\";\n} else {\ntransaction = null;\n}\nif (transaction == null) {\nsync.beforeCompletion();\nsync.afterCompletion(Status.STATUS_COMMITTED);\n} else {\ntransaction.registerSynchronization(sync);\n}\n}", "4571": "private void executionProperties( MavenExecutionRequest request,\n                                      Configuration configuration )\n{\nProperties requestProperties = request.getProperties();\nif ( requestProperties == null )\n{\nrequestProperties = configuration.getSystemProperties();\nif ( requestProperties == null )\n{\nrequestProperties = System.getProperties();\n}\nrequest.setProperties( requestProperties );\n}\nif ( requestProperties.getProperty( MavenEmbedder.STANDALONE_MODE ) == null )\n{\nSystem.setProperty( MavenEmbedder.STANDALONE_MODE, \"true\" );\nrequestProperties.setProperty( MavenEmbedder.STANDALONE_MODE, \"true\" );\n}\nProperties userProperties = request.getUserProperties();\nif ( userProperties!= null )\n{\nfor ( Iterator it = userProperties.keySet().iterator(); it.hasNext(); )\n{\nString key = (String) it.next();\nif (!requestProperties.containsKey( key ) )\n{\nrequestProperties.setProperty( key, userProperties.getProperty( key ) );\n}\n}\n}\n}", "4573": "public void onPress(int primaryCode) {\nvibrate();\nplayKeyClick(primaryCode);\nif (mKeyboardSwitcher.hasDistinctMultitouch() && primaryCode == Keyboard.KEYCODE_SHIFT) {\nmShiftKeyState.onPress();\nhandleShift();\n} else if (primaryCode == Keyboard.KEYCODE_MODE_CHANGE) {\nmShiftKeyState.onKeyModeChanged(primaryCode);\n} else {\nmShiftKeyState.onOtherKeyPressed();\n}\n}", "4575": "public void execute()\nthrows MojoExecutionException, MojoFailureException\n{\nif (!skip )\n{\nif (!\"xml\".equals( outputFileFormat ) )\n{\nthrow new MojoExecutionException( \"Output format is '\" + outputFileFormat\n+ \"', checkstyle:check requires format to be 'xml'.\" );\n}\nif (!outputFile.exists() )\n{\ngetLog().info(\n                               \"Unable to perform checkstyle:check, \"\n+ \"unable to find checkstyle:checkstyle outputFile.\" );\nreturn;\n}\ntry\n            {\nXmlPullParser xpp = new MXParser();\nReader freader = new InputStreamReader( new FileInputStream( outputFile ), \"UTF-8\" );\nBufferedReader breader = new BufferedReader( freader );\nxpp.setInput( breader );\nint violations = countViolations( xpp );\nif ( violations > 0 )\n{\nif ( failOnViolation )\n{\nthrow new MojoFailureException( \"You have \" + violations + \" Checkstyle violation\"\n+ ( ( violations > 1 )? \"s\" : \"\" ) + \".\" );\n}\ngetLog().warn( \"checkstyle:check violations detected but failOnViolation set to false\" );\n}\n}\ncatch ( IOException e )\n{\nthrow new MojoExecutionException( \"Unable to read Checkstyle results xml: \"\n+ outputFile.getAbsolutePath(), e );\n}\ncatch ( XmlPullParserException e )\n{\nthrow new MojoExecutionException( \"Unable to read Checkstyle results xml: \"\n+ outputFile.getAbsolutePath(), e );\n}\n}\n}", "4577": "@Override\npublic void doOnMessage(Message message) throws Exception {\nLOG.debug(\"Entering \" + getClass());\nLOG.debug(message);\nLoadBalancer queueLb = getLoadbalancerFromMessage(message);\nLoadBalancer dbLoadBalancer;\ntry {\ndbLoadBalancer = loadBalancerService.getWithUserPages(queueLb.getId(), queueLb.getAccountId());\n} catch (EntityNotFoundException ex) {\nString alertDescription = String.format(\"Load balancer '%d' not found in database.\", queueLb.getId());\nnotificationService.saveAlert(queueLb.getAccountId(), queueLb.getId(), ex, DATABASE_FAILURE.name(), alertDescription);\nsendErrorToEventResource(queueLb, queueLb.getAccessLists());\nreturn;\n}\nSet<AccessList> accessListsToDelete = queueLb.getAccessLists();\ntry {\nLOG.debug(String.format(\"Deleting access list for load balancer '%s' in Zeus...\", dbLoadBalancer.getId()));\nreverseProxyLoadBalancerStmService.deleteAccessList(dbLoadBalancer, accessListsToDelete);\nLOG.debug(String.format(\"Access list successfully deleted for load balancer '%s' in Zeus.\", dbLoadBalancer.getId()));\n} catch (Exception e) {\nloadBalancerService.setStatus(dbLoadBalancer, LoadBalancerStatus.ERROR);\nString alertDescription = String.format(\"Error deleting access list in Zeus for loadbalancer '%d'.\", queueLb.getId());\nLOG.error(alertDescription, e);\nnotificationService.saveAlert(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), e, ZEUS_FAILURE.name(), alertDescription);\nsendErrorToEventResource(queueLb, queueLb.getAccessLists());\nreturn;\n}\nString atomTitle = \"Network Item Successfully Deleted\";\nfor (AccessList accessList : accessListsToDelete) {\nString atomSummary = String.format(\"Network Item '%d' successfully deleted\", accessList.getId());\nnotificationService.saveAccessListEvent(queueLb.getUserName(), queueLb.getAccountId(), queueLb.getId(), accessList.getId(), atomTitle, atomSummary, DELETE_ACCESS_LIST, DELETE, INFO);\n}\nfor (AccessList accessList : accessListsToDelete) {\nLOG.debug(String.format(\"Removing access list item '%d' from database...\", accessList.getId()));\ndbLoadBalancer.getAccessLists().remove(accessList);\ndbLoadBalancer.setStatus(LoadBalancerStatus.ACTIVE);\nloadBalancerService.update(dbLoadBalancer);\n//Set status record\nloadBalancerStatusHistoryService.save(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), LoadBalancerStatus.ACTIVE);\n}", "4580": "public void getValues(MeasurementReport report, Set<MeasurementScheduleRequest> metrics) throws Exception {\nEmsConnection conn = getConnection();\nEmsBean bean = conn.getBean(context.getPluginConfiguration().getSimpleValue(\"objectName\", null));\nbean.refreshAttributes();\nfor (MeasurementScheduleRequest req : metrics) {\nString tmp = (String) bean.getAttribute(req.getName()).getValue();\nDouble val = Double.valueOf(tmp);\nMeasurementDataNumeric res = new MeasurementDataNumeric(req, val);\nreport.addData(res);\n}\n}", "4582": "@Override\npublic void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nmDeviceAdapter = new DeviceListAdapter(mContext);\nif (mDevices!= null) {\nsetDevices(mDevices);\n}\n}", "4583": "protected void configureAttributes()\n{\n// If an attribute class has been configured, scan it for attributes\nif (attributeClass!= null)\n{\nList<Property<Object>> props = PropertyQueries.createQuery(attributeClass)\n.addCriteria(new PropertyTypeCriteria(PropertyType.NAME))\n.addCriteria(new TypedPropertyCriteria(String.class))\n.getResultList();\nif (props.size() == 1)\n{\nmodelProperties.put(PROPERTY_ATTRIBUTE_NAME, props.get(0));\n}\nelse if (props.size() > 1)\n{\nthrow new IdentityManagementException(\n            \t\t\"Ambiguous attribute name property in class \" +\nattributeClass.getName());\n}\nelse\n         {\nProperty<Object> prop = findNamedProperty(attributeClass,\n                  \"attributeName\", \"name\");\nif (prop!= null) modelProperties.put(PROPERTY_ATTRIBUTE_NAME, prop);\n}\nprops = PropertyQueries.createQuery(attributeClass)\n.addCriteria(new PropertyTypeCriteria(PropertyType.VALUE))\n.getResultList();\nif (props.size() == 1)\n{\nmodelProperties.put(PROPERTY_ATTRIBUTE_VALUE, props.get(0));\n}\nelse if (props.size() > 1)\n{\nthrow new IdentityManagementException(\n                  \"Ambiguous attribute value property in class \" +\nattributeClass.getName());\n}\nelse\n         {\nProperty<Object> prop = findNamedProperty(attributeClass, \n                  \"attributeValue\", \"value\");\nif (prop!= null) modelProperties.put(PROPERTY_ATTRIBUTE_VALUE, prop);\n}\n}\n// Scan for additional attributes in the identity class also\nList<Property<Object>> props = PropertyQueries.createQuery(identityClass)\n.addCriteria(new PropertyTypeCriteria(PropertyType.ATTRIBUTE))\n.getResultList();\nfor (Property<Object> p : props)\n{\nattributeProperties.put(\n               p.getAnnotatedElement().getAnnotation(IdentityProperty.class).attributeName(), \n               p);\n}\n// Scan for entity classes referenced by the identity class also\nList<Class<?>> entityClasses = EntityClasses.getEntityClasses(identityClass);\nfor (Class<?> clazz : entityClasses)\n{\nif (isEntityClass(clazz))\n{\nString entityName = clazz.getSimpleName();\nif (entityName.endsWith(\"Repository\"))\n{\nentityName = entityName.substring(0, entityName.length() - 4);\n}\nmodelProperties.put(PROPERTY_ENTITY_NAME, new TypedPropertyCriteria(entityName));\n}\n}\n}", "4584": "public static void importJson(String jsonFile, String keyspace, String cf, String ssTablePath)\nthrows IOException, ParseException\n{\nColumnFamily cfamily = ColumnFamily.create(keyspace, cf);\nString cfType = cfamily.type(); // Super or Standard\nIPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();\nDataOutputBuffer dob = new DataOutputBuffer();\ntry\n        {\nJSONObject json = (JSONObject)JSONValue.parseWithException(new FileReader(jsonFile));\nSSTableWriter writer = new SSTableWriter(ssTablePath, json.size(), partitioner);\nList<DecoratedKey<?>> decoratedKeys = new ArrayList<DecoratedKey<?>>();\nfor (String key : (Set<String>)json.keySet())\ndecoratedKeys.add(partitioner.decorateKey(key.getBytes(UTF8)));\nCollections.sort(decoratedKeys);\nfor (DecoratedKey<?> rowKey : decoratedKeys)\n{\nif (cfType.equals(\"Super\"))\naddToSuperCF((JSONObject)json.get(asStr(rowKey.key)), cfamily);\nelse\naddToStandardCF((JSONArray)json.get(asStr(rowKey.key)), cfamily);\nColumnFamily.serializer().serializeWithIndexes(cfamily, dob);\nwriter.append(rowKey, dob);\ndob.reset();\ncfamily.clear();\n}\nwriter.closeAndOpenReader();\n}\ncatch (ClassCastException cce)\n{\nthrow new RuntimeException(\"Invalid JSON input, or incorrect column family.\", cce);\n}\n}", "4585": "@Test\npublic void testEncKrbCredPart() throws Exception\n{\nint size = optionalFieldValueList.size();\nfor ( int i = 0; i < 1; i++ )\n{\nEncKrbCredPart expected = new EncKrbCredPart();\nexpected.setTicketInfo( ticketInfo );\nMap<String, Field> EncKrbCrePartFieldNameMap = getFieldMap( expected );\nList<FieldValueHolder> presentFieldList = new ArrayList<FieldValueHolder>();\nFieldValueHolder fieldValHolder = optionalFieldValueList.get( i );\npresentFieldList.add( fieldValHolder );\nField f = EncKrbCrePartFieldNameMap.get( fieldValHolder.fieldName.toLowerCase() );\nf.set( expected, fieldValHolder.value );\nfor ( int j = i + 1; j < size; j++ )\n{\nfieldValHolder = optionalFieldValueList.get( j );\npresentFieldList.add( fieldValHolder );\nf = EncKrbCrePartFieldNameMap.get( fieldValHolder.fieldName.toLowerCase() );\nf.set( expected, fieldValHolder.value );\n}\nByteBuffer stream = ByteBuffer.allocate( expected.computeLength() );\nexpected.encode( stream );\nstream.flip();\nAsn1Decoder decoder = new Asn1Decoder();\nEncKrbCredPartContainer container = new EncKrbCredPartContainer();\ncontainer.setStream( stream );\ntry\n            {\ndecoder.decode( stream, container );\n}\ncatch ( DecoderException e )\n{\n// NOTE: keep this sysout for easy debugging (no need to setup a logger)\nSystem.out.println( \"failed sequence:\\n\" + expected );\nthrow e;\n}\nEncKrbCredPart actual = container.getEncKrbCredPart();\nassertValues( presentFieldList, actual );\n}\n}", "4587": "private void buildWizardStep() {\nFormLayout layout = new FormLayout(\n\t\t\t\t\"center:pref, 3dlu, right:pref, 3dlu, fill:pref:grow, 3dlu, left:pref\",\n\t\t\t\t\"p, 3dlu, p\"\n\t\t\t\t);\nd_builder = new PanelBuilder(layout);\nd_builder.setDefaultDialogBorder();\nCellConstraints cc = new CellConstraints();\nint row = buildSlotsPart(7, cc, 1, layout);\n// Add slot button\nrow += 2;\nJButton btn = new JButton(\"Add \" + d_pm.getTypeName());\nd_builder.add(btn, cc.xy(1, row));\nbtn.addActionListener(new AbstractAction() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\nd_pm.addSlot();\nprepare();\n}\n\t\t});\nJPanel panel = d_builder.getPanel();\nd_scrollPane = new JScrollPane(panel);\nadd(d_scrollPane, BorderLayout.CENTER);\n}", "4588": "public void handshake(boolean async) throws IOException\n{\nif (_session!=null)\nthrow new IllegalStateException();\n_session = new ServerSessionImpl(_bayeux,this,_idHint);\n_bayeux.addServerSession(_session);\nif (async)\n_session.getServer().getMetadata().getHandshake().send(this);\n}", "4590": "void resolveSuperClasses() {\nfor (ComponentClass cc : getComponentClasses()) {\nif (cc.getSuperClass() == null && cc.getSuperClassName()!= null) {\nSystem.err.println(\"WARNING: Super component class '\" + cc.getSuperClassName() + \"' not found.\");\n}\n}\n}", "4604": "@Override\npublic void handleFault(final Exchange exchange) {\nif (exchange.getException() instanceof ApplicationException) {\n// The exception is an application exception and we should handle the fault.\nhandleApplicationException((ApplicationException) exchange.getException());\n} else {\n// The exception is not an application exception and we should handle the fault.\nhandleExchangeFault(exchange);\n}\n}", "4610": "@Override\nprotected void onPostExecute(Exception e) {\nfinal Context context = StorageWizardFormatProgress.this;\nif (e == null) {\nif (mFormatPrivate) {\nfinal Intent intent = new Intent(context, StorageWizardMigrate.class);\nintent.putExtra(DiskInfo.EXTRA_DISK_ID, mDisk.getId());\nstartActivity(intent);\n}\nfinal Intent intent = new Intent(context, StorageWizardReady.class);\nintent.putExtra(DiskInfo.EXTRA_DISK_ID, mDisk.getId());\nstartActivity(intent);\n} else {\nfinal Intent intent = new Intent(context, StorageWizardReady.class);\nintent.putExtra(DiskInfo.EXTRA_DISK_ID, mDisk.getId());\nstartActivity(intent);\n}\nfinishAffinity();\n} else {\nLog.e(TAG, \"Failed to partition\", e);\nToast.makeText(context, e.getMessage(), Toast.LENGTH_LONG).show();\nfinishAffinity();\n}\n}", "4611": "@SuppressWarnings(\"unchecked\")\npublic void eventSunk(\n            ChannelPipeline pipeline, ChannelEvent e) throws Exception {\nXnioChannel channel = (XnioChannel) e.getChannel();\nif (e instanceof ChannelStateEvent) {\nChannelStateEvent event = (ChannelStateEvent) e;\nChannelFuture future = event.getFuture();\nChannelState state = event.getState();\nObject value = event.getValue();\nswitch (state) {\ncase OPEN:\nif (Boolean.FALSE.equals(value)) {\nchannel.closeNow(future);\n}\nbreak;\ncase BOUND:\ncase CONNECTED:\nif (value!= null) {\nif (channel instanceof XnioClientChannel) {\nfinal XnioClientChannel cc = (XnioClientChannel) channel;\nsynchronized (cc.connectLock) {\nboolean connectInProgress = cc.connectInProgress;\ncc.connectInProgress = false;\ntry {\nFutureConnection fc =\n                                    cc.xnioConnector.connectTo(value, HANDLER);\nfc.addNotifier(new Notifier() {\n                                    public void notify(\n                                            IoFuture future, Object attachment) {\nChannelFuture cf = (ChannelFuture) attachment;\ntry {\njava.nio.channels.Channel xnioChannel = (java.nio.channels.Channel) future.get();\ncc.xnioChannel = xnioChannel;\nXnioChannelRegistry.registerChannelMapping(cc);\ncf.setSuccess();\n} catch (Throwable t) {\ncf.setFailure(t);\nfireExceptionCaught(cc, t);\n}\n}\n                                }, future);\n}\n}\n} else {\nfuture.setFailure(new UnsupportedOperationException());\n}\n} else {\nchannel.closeNow(future);\n}\nbreak;\ncase INTEREST_OPS:\nint interestOps = ((Integer) value).intValue();\njava.nio.channels.Channel xnioChannel = channel.xnioChannel;\nif (xnioChannel instanceof SuspendableReadChannel) {\nif ((interestOps & Channel.OP_READ) == 0) {\n((SuspendableReadChannel) xnioChannel).suspendReads();\n} else {\n((SuspendableReadChannel) xnioChannel).resumeReads();\n}\n}\ne.getFuture().setSuccess();\nbreak;\n}\n} else if (e instanceof MessageEvent) {\nMessageEvent event = (MessageEvent) e;\njava.nio.channels.Channel xnioChannel = channel.xnioChannel;\nif (xnioChannel instanceof GatheringByteChannel ||\nxnioChannel instanceof MultipointWritableMessageChannel ||\nxnioChannel instanceof WritableMessageChannel) {\nchannel.writeBuffer.offer(event);\nif (xnioChannel instanceof SuspendableWriteChannel) {\n((SuspendableWriteChannel) xnioChannel).resumeWrites();\n}\n} else {\nevent.getFuture().setFailure(new IllegalStateException());\n}\n}\n}", "4614": "private void load() {\n// Use the ContentUris method to produce the base URI for the contact with _ID == 23.\nUri poiUri = Uri.withAppendedPath(Wheelmap.POIs.CONTENT_URI, poiID);\n// Then query for this specific record:\nCursor cur = managedQuery(poiUri, null, null, null, null);\nif (cur.moveToFirst()) {\nname.setText(cur.getString(cur.getColumnIndexOrThrow(Wheelmap.POIsColumns.NAME)));\naddress.setText(cur.getString(cur.getColumnIndexOrThrow(Wheelmap.POIsColumns.CITY)));\nnotes.setText(cur.getString(cur.getColumnIndexOrThrow(Wheelmap.POIsColumns.WEBSITE)));\nWheelchairState state = WheelchairState.valueOf(cur.getInt(cur.getColumnIndexOrThrow(Wheelmap.POIsColumns.WHEELCHAIR)));\nswitch (state) {\ncase UNKNOWN: {\ntypes.check(R.id.unknown);\nbreak;\n}\ncase YES:\ntypes.check(R.id.yes);\nbreak;\ncase LIMITED:\ntypes.check(R.id.limited);\nbreak;\ncase NO:\ntypes.check(R.id.no);\nbreak;\ndefault:\ntypes.check(R.id.unknown);\nbreak;\n}\ncur.close();\n}\n}", "4616": "public void setCompression(String compress) throws FormatException {\nif (compress == null) {\ncompress = DEFAULT_COMPRESS;\n}\nif (compress.equals(\"none\")) {\ncompress = DEFAULT_COMPRESS_NONE;\n}\nif (compress.equals(\"gzip\")) {\ncompress = DEFAULT_COMPRESS_GZIP;\n}\nif (compress.equals(\"deflate\")) {\ncompress = DEFAULT_COMPRESS_DEFLATE;\n}\nif (compress.equals(\"none\")) {\ncompress = DEFAULT_COMPRESS_NONE;\n}\nthis.compress = compress;\n}", "4622": "private void ensureMetaCharset() {\nif( updateMetaCharset == true ) {\nElement metaCharset = select(\"meta[charset]\").first();\nif( metaCharset!= null ) {\nmetaCharset.attr(\"charset\", outputSettings.charset().displayName());\nremoveMetaTag( metaCharset );\n}\nelse {\nElement head = head();\nif( head!= null ) {\nhead.appendElement(\"meta\").attr(\"charset\", outputSettings.charset().displayName());\n}\n}\n}", "4623": "private void parse(final XMLStreamReader reader, final CtClass ctClass, final String pluginIdentifier)\nthrows XMLStreamException {\nLOG.info(\"Defining class \" + ctClass.getName());\ncreateField(ctClass, \"id\", Long.class.getCanonicalName());\nwhile (reader.hasNext() && reader.next() > 0) {\nif (isTagEnded(reader, TAG_MODEL)) {\nbreak;\n}\nif (TAG_FIELDS.equals(getTagStarted(reader))) {\nwhile (reader.hasNext() && reader.next() > 0) {\nif (isTagEnded(reader, TAG_FIELDS)) {\nbreak;\n}\nString tag = getTagStarted(reader);\nif (tag == null) {\ncontinue;\n}\nparseField(reader, pluginIdentifier, ctClass, tag);\n}\nbreak;\n}\n}\nparseInterface(reader, pluginIdentifier, ctClass);\n}", "4625": "public void setupExistingData(Encounter encounter) {\nexistingEncounter = encounter;\nexistingObs = new HashMap<Concept, List<Obs>>();\nif (encounter!= null) {\nfor (Obs obs : encounter.getObsAtTopLevel(false)) {\nList<Obs> list = existingObs.get(obs.getConcept());\nif (list == null) {\nlist = new LinkedList<Obs>();\nexistingObs.put(obs.getConcept(), list);\n}\nlist.add(obs);\n}\n}\nexistingObsInGroups = new ArrayList<Obs>();\nif (encounter!= null) {\nfor (Obs parent : encounter.getObsAtTopLevel(false)) {\nif (parent.hasGroupMembers()) {\nexistingObsInGroups.add(parent);\n}\n}\n}\n}", "4627": "public void childRemoved(ConfiguredObject object, ConfiguredObject child)\n{\nsynchronized (_children)\n{\nAMQManagedObject mbean = _children.remove(child);\nif(mbean!= null)\n{\ntry\n                {\nmbean.unregister();\n}\ncatch(JMException e)\n{\ne.printStackTrace();\n}\n}\n}\n}", "4628": "public void process(RelationContainer container) {\nRelation relation;\nRelation filteredRelation;\nrelation = container.getEntity();\n// Create a new relation object to contain only items within the bounding box.\nfilteredRelation = new Relation(relation.getId(), relation.getTimestamp(), relation.getUser());\n// Add relation entity lists to relation.\nfor (RelationEntity relationEntity : relation.getRelationEntityLists()) {\nfilteredRelation.addRelationEntity(relationEntity);\n}\nsink.process(new RelationContainer(filteredRelation));\n}", "4630": "public void setLocation(Location location){\nif(Log.isLoggable(LogUtil.TAG, Log.DEBUG)){\nLog.d(LogUtil.TAG, \"Location changed \" + location.getProvider()); //$NON-NLS-1$\n}\nif(location!= null && settings.SAVE_TRACK_TO_GPX.get()){\n// write only with 50 meters accuracy\nif (!location.hasAccuracy() || location.getAccuracy() < ACCURACY_FOR_GPX_AND_ROUTING) {\nsavingTrackHelper.insertData(location.getLatitude(), location.getLongitude(), location.getAltitude(), location.getSpeed(),\n\t\t\t\t\t\tlocation.getAccuracy(), location.getTime(), settings);\n}\n}\nregisterUnregisterSensor(location);\nupdateSpeedBearing(location);\nmapLayers.getLocationLayer().setLastKnownLocation(location);\nif(routingHelper.isFollowingMode()){\nif(location == null ||\n!location.hasAccuracy() || location.getAccuracy() < ACCURACY_FOR_GPX_AND_ROUTING) {\n// Update routing position  \nroutingHelper.setCurrentLocation(location);\n// Check with delay that gps location is not lost\nif(location!= null && routingHelper.getLeftDistance() > 0){\nMessage msg = Message.obtain(uiHandler, new Runnable() {\n    \t\t\t\t\t@Override\npublic void run() {\nif (routingHelper.getLeftDistance() > 0 && settings.MAP_ACTIVITY_ENABLED.get()) {\nroutingHelper.getVoiceRouter().gpsLocationLost();\n}\n}\n    \t\t\t\t});\nmsg.what = LOST_LOCATION_MSG_ID;\nuiHandler.removeMessages(LOST_LOCATION_MSG_ID);\nuiHandler.sendMessageDelayed(msg, LOST_LOCATION_CHECK_DELAY);\n}\n}\n}\nif (location!= null) {\nif (isMapLinkedToLocation()) {\nif(settings.AUTO_ZOOM_MAP.get() && location.hasSpeed()){\nint z = defineZoomFromSpeed(location.getSpeed(), mapView.getZoom());\nif(mapView.getZoom()!= z &&!mapView.mapIsAnimating()){\nlong now = System.currentTimeMillis();\n// prevent ui hysterisis (check time interval for autozoom)\nif(Math.abs(mapView.getZoom() - z) > 1 || (lastTimeAutoZooming - now) > 6500){\nlastTimeAutoZooming = now;\nmapView.setZoom(z);\n}\n}\n}\nint currentMapRotation = settings.ROTATE_MAP.get();\nif (location.hasBearing() && currentMapRotation == OsmandSettings.ROTATE_MAP_BEARING) {\nmapView.setRotate(-location.getBearing());\n}\nmapView.setLatLon(location.getLatitude(), location.getLongitude());\n} else {\nif(!mapLayers.getMapInfoLayer().getBackToLocation().isEnabled()){\nmapLayers.getMapInfoLayer().getBackToLocation().setEnabled(true);\n}\n}\n} else {\nif(mapLayers.getMapInfoLayer().getBackToLocation().isEnabled()){\nmapLayers.getMapInfoLayer().getBackToLocation().setEnabled(false);\n}\n}\n// When location is changed we need to refresh map in order to show movement! \nmapView.refreshMap();\n}", "4633": "public static void levelUpNotification(SkillType skillType, SpoutPlayer spoutPlayer) {\nPlayerProfile profile = Users.getProfile(spoutPlayer);\nint notificationTier = getNotificationTier(profile.getSkillLevel(skillType));\nMaterial mat = null;\nswitch (skillType) {\ncase TAMING:\nswitch (notificationTier) {\ncase 1:\ncase 2:\nmat = Material.PORK;\nbreak;\ncase 3:\ncase 4:\nmat = Material.GRILLED_PORK;\nbreak;\ncase 5:\nmat = Material.BONE;\nbreak;\ndefault:\nbreak;\n}\nbreak;\ncase MINING:\nswitch (notificationTier) {\ncase 1:\nmat = Material.COAL_ORE;\nbreak;\ncase 2:\nmat = Material.IRON_ORE;\nbreak;\ncase 3:\nmat = Material.GOLD_ORE;\nbreak;\ncase 4:\nmat = Material.LAPIS_ORE;\nbreak;\ncase 5:\nmat = Material.DIAMOND_ORE;\nbreak;\ndefault:\nbreak;\n}\nbreak;\ncase WOODCUTTING:\nswitch (notificationTier) {\ncase 1:\ncase 2:\ncase 3:\nmat = Material.WOOD;\nbreak;\ncase 4:\ncase 5:\nmat = Material.LOG;\nbreak;\ndefault:\nbreak;\n}\nbreak;\ncase REPAIR:\nswitch (notificationTier) {\ncase 1:\nmat = Material.COBBLESTONE;\nbreak;\ncase 2:\nmat = Material.IRON_BLOCK;\nbreak;\ncase 3:\nmat = Material.GOLD_BLOCK;\nbreak;\ncase 4:\nmat = Material.LAPIS_BLOCK;\nbreak;\ncase 5:\nmat = Material.DIAMOND_BLOCK;\nbreak;\ndefault:\nbreak;\n}\nbreak;\ncase HERBALISM:\nswitch (notificationTier) {\ncase 1:\nmat = Material.YELLOW_FLOWER;\nbreak;\ncase 2:\nmat = Material.RED_ROSE;\nbreak;\ncase 3:\nmat = Material.BROWN_MUSHROOM;\nbreak;\ncase 4:\nmat = Material.RED_MUSHROOM;\nbreak;\ncase 5:\nmat = Material.PUMPKIN;\nbreak;\ndefault:\nbreak;\n}\nbreak;\ncase ACROBATICS:\nswitch (notificationTier) {\ncase 1:\nmat = Material.LEATHER_BOOTS;\nbreak;\ncase 2:\nmat = Material.CHAINMAIL_BOOTS;\nbreak;\ncase 3:\nmat = Material.IRON_BOOTS;\nbreak;\ncase 4:\nmat = Material.GOLD_BOOTS;\nbreak;\ncase 5:\nmat = Material.DIAMOND_BOOTS;\nbreak;\ndefault:\nbreak;\n}\nbreak;\ncase SWORDS:\nswitch (notificationTier) {\ncase 1:\nmat = Material.WOOD_SWORD;\nbreak;\ncase 2:\nmat = Material.STONE_SWORD;\nbreak;\ncase 3:\nmat = Material.IRON_SWORD;\nbreak;\ncase 4:\nmat = Material.GOLD_SWORD;\nbreak;\ncase 5:\nmat = Material.DIAMOND_SWORD;\nbreak;\ndefault:\nbreak;\n}\nbreak;\ncase ARCHERY:\nswitch (notificationTier) {\ncase 1:\ncase 2:\ncase 3:\nmat = Material.ARROW;\nbreak;\ncase 4:\ncase 5:\nmat = Material.BOW;\nbreak;\ndefault:\nbreak;\n}\nbreak;\ncase UNARMED:\nswitch (notificationTier) {\ncase 1:\nmat = Material.LEATHER_HELMET;\nbreak;\ncase 2:\nmat = Material.CHAINMAIL_HELMET;\nbreak;\ncase 3:\nmat = Material.IRON_HELMET;\nbreak;\ncase 4:\nmat = Material.GOLD_HELMET;\nbreak;\ncase 5:\nmat = Material.DIAMOND_HELMET;\nbreak;\ndefault:\nbreak;\n}\nbreak;\ncase EXCAVATION:\nswitch (notificationTier) {\ncase 1:\nmat = Material.WOOD_SPADE;\nbreak;\ncase 2", "4636": "void moveItems(final long toListId, final long[] taskIds) {\nfor (long id: taskIds) {\nfinal Cursor c =\n getActivity().getContentResolver().query(Task.getUri(id),\nTask.Columns.FIELDS, null, null, null);\nif (c.moveToFirst()) {\nTask t = new Task(c);\n// Remove from old location\nt.delete(getActivity());\n// Reset, and set new list\nt.resetForInsertion();\nt.dblist = toListId;\n// And save anew\nt.save(getActivity());\n}\nc.close();\n}\nfinal ContentValues val = new ContentValues();\nval.put(Task.Columns.DBLIST, toListId);\n// where _ID in (1, 2, 3)\nfinal String whereId = new StringBuilder(Task.Columns._ID)\n.append(\" IN (\").append(DAO.arrayToCommaString(taskIds))\n.append(\")\").toString();\ngetActivity().getContentResolver().update(Task.URI, val, whereId, null);\n}", "4639": "public void populateExchangeFromCxfRsRequest(org.apache.cxf.message.Exchange cxfExchange,\n                                                 Exchange camelExchange, Method method, Object[] paramArray) {\nMessage inMessage = camelExchange.getIn();\ninMessage.setHeader(CxfConstants.OPERATION_NAME, method.getName());\ninMessage.setBody(paramArray);\n}", "4640": "public static void validate(AriesSubsystem subsystem, SubsystemManifest manifest) {\nvalidatePreferredProviderHeader(manifest.getPreferredProviderHeader());\nif (subsystem.isComposite()) {\nSubsystemContentHeader header = manifest.getSubsystemContentHeader();\nif (header == null)\nreturn;\nfor (SubsystemContentHeader.Content content : header.getContents()) {\nif (!isExactVersion(content.getVersionRange()))\nthrow new SubsystemException(\"Composite subsystem using version range for content: \" + content);\n}\n}\nelse if (subsystem.isFeature()) {\nif (manifest.getSubsystemTypeHeader().getProvisionPolicyDirective().isAcceptDependencies())\nthrow new SubsystemException(\"Feature subsystems may not declare a provision-policy of acceptDependencies\");\nif (manifest.getHeaders().get(SubsystemConstants.PREFERRED_PROVIDER)!= null)\nthrow new SubsystemException(\"Feature subsystems may not declare a \" + SubsystemConstants.PREFERRED_PROVIDER + \" header\");\n}\n}", "4642": "@Test\nvoid testParsingEntities() throws Exception {\nMap<String, String> typeToClassMap = new HashMap<>();\naddEntityTypes(typeToClassMap);\nAnnotationConfiguration annConfig = new AnnotationConfiguration(typeToClassMap);\nObjectStream<BratAnnotation> annStream = creatBratAnnotationStream(annConfig,\n        \"brat/voa-with-entities.ann\");\nBratAnnotation ann;\nwhile ((ann = annStream.read())!= null) {\nSystem.out.println(ann);\n}\n}", "4644": "@Override\npublic void invalidateAll() {\nif ( log.isDebugEnabled() ) {\nlog.debug(\"Invalidating all connections at {} (thread={})\", this,\n          Thread.currentThread().getName());\n}\nwhile (!liveClientsFromPool.isEmpty()) {\ninvalidateClient(liveClientsFromPool.iterator().next());\n}\n}", "4655": "private void updateCameraParametersInitialize() {\n// Reset preview frame rate to the maximum because it may be lowered by\n// video camera application.\nList<Integer> frameRates = mParameters.getSupportedPreviewFrameRates();\nif (frameRates!= null) {\nInteger max = Collections.max(frameRates);\nmParameters.setPreviewFrameRate(max);\n}\nmParameters.setRecordingHint(false);\n}", "4656": "public void testNoSplitCharacter() {\nargs = new String[]{\"-T\", \"keyvalue\"};\ntry {\nparser.parseArgument(args);\nfail(\"An exception should have been thrown.\");\n} catch (CmdLineException e) {\nassertEquals(\"Wrong error message.\", \"A keyvalue must be separated by a space.\", e.getMessage());\n}\n}", "4659": "public void configure(final Consumer<DiscoveryProvider> discoveryProviderConsumer, final Consumer<RegistryProvider> registryProviderConsumer) {\nfinal JBossEJBProperties ejbProperties = JBossEJBProperties.getCurrent();\nif (ejbProperties == null) {\nreturn;\n}\nfinal List<ServiceURL> list = new ArrayList<>();\nfor (Map.Entry<String, JBossEJBProperties.ClusterConfiguration> entry : ejbProperties.getClusterConfigurations().entrySet()) {\nfinal String name = entry.getKey();\nfinal JBossEJBProperties.ClusterConfiguration configuration = entry.getValue();\nfinal ExceptionSupplier<ClusterNodeSelector, ReflectiveOperationException> clusterNodeSelectorSupplier = configuration.getClusterNodeSelectorSupplier();\nfinal long maximumAllowedConnectedNodes = configuration.getMaximumAllowedConnectedNodes();\nfor (JBossEJBProperties.ClusterNodeConfiguration nodeConfiguration : configuration.getNodeConfigurations()) {\nfinal String nodeName = nodeConfiguration.getNodeName();\n}\nfinal ServiceURL url = buildClusterURL(name, clusterNodeSelectorSupplier, maximumAllowedConnectedNodes);\nlist.add(url);\n}\nif (! list.isEmpty()) {\nLogs.MAIN.legacyEJBPropertiesDiscoveryConfigurationInUse();\ndiscoveryProviderConsumer.accept(new StaticDiscoveryProvider(list));\n}\n}", "4660": "public void unlockProject(CmsUser currentUser, CmsProject currentProject, int id)\nthrows CmsException {\n// read the project.\nCmsProject project = readProject(currentUser, currentProject, id);\n// check the security\nif( isAdmin(currentUser, currentProject) ||\nisManagerOfProject(currentUser, project) ||\n(project.getFlags() == C_PROJECT_STATE_UNLOCKED )) {\nm_dbAccess.unlockProject(project);\n} else {\nthrow new CmsException(\"[\" + this.getClass().getName() + \"] \" + id, \n\t\t\t\tCmsException.C_NO_ACCESS);\n}\n}", "4662": "synchronized void onPackageUnavailable(String packageName) {\nif (mIndex == null) return;\nif (!mInputMethodServices.remove(packageName)) return;\nbuildIndex(InputMethodAndLanguageSettings.class, true /* rebuild */);\n}", "4668": "@Override\npublic void trigger(ChipState chip) {\nif(!chip.getInput(0))\nreturn;\nBlock left = SignUtil.getLeftBlock(getSign().getBlock());\nSign effectSign = null;\nif(left.getTypeId() == BlockID.WALL_SIGN) {\neffectSign = (Sign) left.getState();\n}\nBlock right = SignUtil.getRightBlock(getSign().getBlock());\nSign armourSign = null;\nif(right.getTypeId() == BlockID.WALL_SIGN) {\narmourSign = (Sign) right.getState();\n}\nfor(int i = 0; i < amount; i++) {\nEntity ent = getSign().getWorld().spawnEntity(BukkitUtil.toLocation(location), type);\nif(armourSign!= null) { //Apply armor\nfor(int s = 0; s < 4; s++) {\ntry {\nString bit = armourSign.getLine(s);\nif(bit == null || bit.trim().length() == 0)\ncontinue;\nbyte data = 0;\ntry {\ndata = Byte.parseByte(bit.split(\";\")[0].split(\":\")[1]);\n}\ncatch(Exception e){}\nItemStack slot = new ItemStack(Item.byId[Integer.parseInt(bit.split(\";\")[0].split(\":\")[0])], 1, data);\ntry {\nfor(int e = 1; e < bit.split(\";\").length; e++) {\nslot.addEnchantment(Enchantment.byId[Integer.parseInt(bit.split(\";\")[e].split(\":\")[0])],\n                                            Integer.parseInt(bit.split(\";\")[e].split(\":\")[1]));\n}\n}\ncatch(Exception e){}\neliv.setEquipment(s + 1, slot);\n}\ncatch(Exception e){}\n}\n}\nif(effectSign!= null) { //Apply effects\nfor(int s = 0; s < 4; s++) {\ntry {\nString bit = effectSign.getLine(s);\nif(bit == null || bit.trim().length() == 0)\ncontinue;\nString[] data = bit.split(\":\");\nif(data[0].equalsIgnoreCase(\"e\"))\nsetEntityData(ent, bit.replace(data[0] + \":\", \"\"));\nelse if(data[0].equalsIgnoreCase(\"p\")) {\nent.setPotionEffect(PotionEffect.POTION_POTION_EAT);\n}\nelse if(data[0].equalsIgnoreCase(\"v\")) {\ntry {\ndouble x, y, z;\nx = Double.parseDouble(data[1].split(\",\")[0]);\ny = Double.parseDouble(data[1].split(\",\")[1]);\nz = Double.parseDouble(data[1].split(\",\")[2]);\nent.setVelocity(new org.bukkit.util.Vector(x,y,z));\n}\ncatch(Exception e){\n}\n}\nelse if(data[0].equalsIgnoreCase(\"s\")) {\nif(!(ent instanceof LivingEntity))\ncontinue;\nCraftLivingEntity cle = (CraftLivingEntity) ent;\nEntityLiving eliv = cle.getHandle();\nbyte d = 0;\ntry {\nd = Byte.parseByte(bit.split(\";\")[0].split(\":\")[2]);\n}\ncatch(Exception e){}\nItemStack slot = new ItemStack(Item.byId[Integer.parseInt(bit.split(\";\")[0].split(\":\")[1])], 1, d);\ntry {\nfor(int e = 1; e < bit.split(\";\").length; e++) {\nslot.addEnchantment(Enchantment.byId[Integer.parseInt(bit.split(\";\")[e].split(\":\")[0])],\n                                            Integer.parseInt(bit.split(\";\")[e].split(\":\")[1]));\n}\n}\ncatch(Exception e){}\neliv.setEquipment(0, slot);\n}\n}\ncatch(Exception e){}\n}\n}\n}\n}", "4672": "@Override\npublic void setAttributes( Object[] arg0 ) {\nif ( arg0.length == 0 ) {\n// clear the attributes\nfor ( Iterator i = attributes.iterator(); i.hasNext(); ) {\nAttribute attr = (Attribute) i.next();\nattr.setValue( null );\n}\n} else {\n// set the attributes\nfor ( Iterator i = attributes.iterator(); i.hasNext(); ) {\nAttribute attr = (Attribute) i.next();\nattr.setValue( arg0[0] );\n}\n}\n}", "4674": "public void moveTo(int pos) {\nif (mClosed) {\nthrow new IllegalStateException(\"moveTo(\" + pos + \") after close()\");\n}\nif (!mCursor.moveToPosition(pos)) {\nthrow new IllegalArgumentException(\"Move to \" + pos + \", count=\" + getCount());\n}\n}", "4676": "@Test\npublic void canFindOneWithParameters() throws Exception {\n/* given */\nmongoCollection.save(new Poi(\"999\", address));\n/* when */\nString id = mongoCollection.findOne(\"{_id:#}\", new Object[] { \"999\" }, new IdDBObjectMapper());\nPoi poi = mongoCollection.findOne(\"{_id:#}\", new Object[] { \"999\" }, Poi.class);\n/* then */\nassertThat(id).isEqualTo(\"999\");\nassertThat(poi.id).isEqualTo(\"999\");\n}", "4679": "void onStart() throws IOException\n{\n/* Do major compaction */\nList<File> sstableFiles = new ArrayList<File>();\nString[] dataFileDirectories = DatabaseDescriptor.getAllDataFileLocations();\nfor (String directory : dataFileDirectories)\n{\nFile fileDir = new File(directory);\nFile[] files = fileDir.listFiles();\nfor (File file : files)\n{\nString filename = file.getName();\nif (((file.length() == 0) || (filename.contains(\"-\" + SSTable.temporaryFile_))) && (filename.contains(columnFamily_)))\n{\nfile.delete();\ncontinue;\n}\nString[] tblCfName = getTableAndColumnFamilyName(filename);\nif (tblCfName[0].equals(table_)\n&& tblCfName[1].equals(columnFamily_)\n&& filename.contains(\"-Data.db\"))\n{\nsstableFiles.add(file.getAbsoluteFile());\n}\n}\n}\nCollections.sort(sstableFiles, new FileUtils.FileComparator());\nList<String> filenames = new ArrayList<String>();\nfor (File ssTable : sstableFiles)\n{\nfilenames.add(ssTable.getAbsolutePath());\n}\n/* Load the index files and the Bloom Filters associated with them. */\nfor (String filename : filenames)\n{\ntry\n            {\nSSTable sstable = SSTable.open(filename, StorageService.getPartitioner());\nssTables_.put(filename, sstable);\n}\ncatch (IOException ex)\n{\nlogger_.info(\"Deleting corrupted file \" + filename);\nFileUtils.delete(filename);\nlogger_.warn(LogUtil.throwableToString(ex));\n}\n}\nMinorCompactionManager.instance().submit(ColumnFamilyStore.this);\nif (table_.equals(Table.SYSTEM_TABLE) && columnFamily_.equals(HintedHandOffManager.HINTS_CF))\n{\nHintedHandOffManager.instance().submit(this);\n}\nMinorCompactionManager.instance().submitPeriodicCompaction(this);\n/* submit periodic flusher if required */\nint flushPeriod = DatabaseDescriptor.getFlushPeriod(table_, columnFamily_);\nif (flushPeriod > 0)\n{\nPeriodicFlushManager.instance().submitPeriodicFlusher(this, flushPeriod);\n}\n}", "4682": "public void run() throws Exception {\nMavenRepository repo = createRepository();\nif (cap!=null)\nrepo = new VersionCappedMavenRepository(repo,new VersionNumber(cap));\nif(pluginExtensionPoints) {\nbuildPluginExtensionPoints(repo);\nreturn; //TODO don't do this.\n}\nFile p = htaccess.getParentFile();\nif (p!=null) p.mkdirs();\nPrintWriter latestRedirect = new PrintWriter(new FileWriter(htaccess), true);\nJSONObject root = new JSONObject();\nroot.put(\"updateCenterVersion\",\"1\"); // we'll bump the version when we make incompatible changes\nJSONObject core = buildCore(repo, latestRedirect);\nif (core!=null)\nroot.put(\"core\", core);\nroot.put(\"plugins\", buildPlugins(repo, latestRedirect));\nroot.put(\"id\",id);\nif (connectionCheckUrl!=null)\nroot.put(\"connectionCheckUrl\",connectionCheckUrl);\nif(privateKey!=null &&!certificates.isEmpty())\nsign(root);\nelse {\nif (privateKey!=null ||!certificates.isEmpty())\nthrow new Exception(\"private key and certificate must be both specified\");\n}\nPrintWriter pw = new PrintWriter(new FileWriter(output));\npw.println(\"updateCenter.post(\");\npw.println(prettyPrint?root.toString(2):root.toString());\npw.println(\");\");\npw.close();\nJSONObject rhRoot = new JSONObject();\nrhRoot.put(\"releaseHistory\", buildReleaseHistory(repo));\nPrintWriter rhpw = new PrintWriter(new FileWriter(releaseHistory));\nrhpw.println(prettyPrint?rhRoot.toString(2):rhRoot.toString());\nrhpw.close();\nlatestRedirect.close();\n}", "4683": "@Override\npublic void onConnected(SocketChannel socketChannel, Peer peer) {\nregisterNewPeer(peer);\nConnectionUtils.sendHandshake(socketChannel, peer.getInfoHash(), peersStorageFactory.getPeersStorage().getSelf().getPeerIdArray());\nthis.next = new HandshakeReceiver(uid, peersStorageFactory, torrentsStorageFactory, false);\n}", "4684": "@Test\npublic void testDupeTailNames() throws Exception\n{\nTap source = getPlatform().getTextFile( inputFileJoined );\nTap sink = getPlatform().getTextFile( getOutputPath( \"unknown\" ), SinkMode.REPLACE );\nPipe pipe = new Pipe( \"test\" );\npipe = new Each( pipe, new Fields( \"line\" ), new RegexSplitter( \" \" ) );\nPipe group = new GroupBy( pipe, Fields.size( 3 ) );\nPipe lhs = new Pipe( \"tail\", group );\nlhs = new Each( group, new Fields( \"line\" ), new RegexSplitter( \" \" ) );\nPipe rhs = new Pipe( \"tail\", group );\nrhs = new Each( group, new Fields( \"line\" ), new RegexSplitter( \" \" ) );\nMap<String, Tap> sinks = Cascades.tapsMap( Pipe.pipes( lhs, rhs ), Tap.taps( sink, sink ) );\ntry\n      {\ngetPlatform().getFlowConnector().connect( source, sinks, Pipe.pipes( lhs, rhs ) );\nfail( \"did not fail on dupe head names\" );\n}\ncatch( Exception exception )\n{\n// ignore\n}\n}", "4688": "@Test\npublic void testExportArchiveWithOnlyDirectories() throws IOException\n{\n// Create an archive with directories\nfinal Archive<?> archive = ShrinkWrap.create(JavaArchive.class, NAME_ARCHIVE).addDirectories(\"/test/game\");\n// Fully export by reading all content (export is on-demand)\nfinal InputStream content = this.exportAsInputStream(archive);\nfinal OutputStream sink = new OutputStream()\n{\n\n         @Override\npublic void write(int b) throws IOException\n{\n//NOOP\n}\n      };\nIOUtil.copyWithClose(content, sink);\nassertThat(archive.getEntryCount(), is(0));\n}", "4690": "@Override\npublic void onReceive(Context context, Intent intent) {\nif (Intent.ACTION_DELETE.equals(intent.getAction())) {\nif (intent.hasExtra(ARG_MAX_TIME)) {\ndeleteNotification(context,\n\t\t\t\t\t\tintent.getLongExtra(ARG_LISTID, -1),\n\t\t\t\t\t\tintent.getLongExtra(ARG_MAX_TIME, 0));\n}\nelse {\n// Just a notification\ncontext.getContentResolver().delete(intent.getData(), null,\n\t\t\t\t\t\tnull);\ncancelNotification(context, intent.getData());\nif (intent.getBooleanExtra(ARG_COMPLETE, false)) {\n// Also complete note\nTask.setCompleted(context, true,\n\t\t\t\t\t\t\tintent.getLongExtra(ARG_TASKID, -1));\n}\n}\n// User in editor, don't spam\nnotifyPast(context, true);\n}\nelse if (Intent.ACTION_EDIT.equals(intent.getAction())) {\nif (intent.getBooleanExtra(ARG_SNOOZE, false)) {\n// Cancel current notification\ncancelNotification(context, intent.getData());\n// msec/sec * sec/min * 15\nlong delay15min = 1000 * 60 * 15;\nfinal Calendar now = Calendar.getInstance();\ncom.nononsenseapps.notepad.database.Notification.setTime(\n\t\t\t\t\t\tcontext, intent.getData(),\n\t\t\t\t\t\tdelay15min + now.getTimeInMillis());\n}\nnotifyPast(context, true);\n}\nelse {\nnotifyPast(context, false);\n}\nscheduleNext(context);\n}", "4692": "public void actionPerformed(ActionEvent e)\n{\nif (e.getSource() == newSprite)\n{\nResNode n = Listener.getPrimaryParent(Sprite.class);\nSprite spr = LGM.currentFile.resMap.getList(Sprite.class).add();\nListener.putNode(LGM.tree,n,n,Sprite.class,n.getChildCount(),spr);\nres.put(PGmObject.SPRITE,spr.reference);\nreturn;\n}\nif (e.getSource() == editSprite)\n{\nSprite spr = deRef(sprite.getSelected());\nif (spr == null) return;\nspr.getNode().openFrame();\nreturn;\n}\nif (e.getSource() == information)\n{\nObjectInfo info = new ObjectInfo();\ninfo.setName(infoName.getSelected());\ninfo.setDescription(infoDescription.getSelected());\ninfo.setIcon(infoIcon.getSelected());\ninfo.setVisible(infoVisible.getSelected());\ninfo.setEnabled(infoEnabled.getSelected());\ninfo.setSelected(infoSelected.getSelected());\ninfo.setVisible(infoVisible.getSelected());\ninfo.setEnabled(infoEnabled.getSelected());\ninfo.setSelected(infoSelected.getSelected());\nreturn;\n}\nif (e.getSource() == eventAdd || e.getSource() == eventAddItem)\n{\nLGM.eventSelect.setVisible(true);\nLGM.eventSelect.function.setValue(EventPanel.FUNCTION_ADD);\nreturn;\n}\nif (e.getSource() == eventReplace || e.getSource() == eventReplaceItem)\n{\nLGM.eventSelect.setVisible(true);\nLGM.eventSelect.function.setValue(EventPanel.FUNCTION_REPLACE);\nreturn;\n}\nif (e.getSource() == eventDuplicate || e.getSource() == eventDuplicateItem)\n{\nLGM.eventSelect.setVisible(true);\nLGM.eventSelect.function.setValue(EventPanel.FUNCTION_DUPLICATE);\nreturn;\n}\nif (e.getSource() == eventDelete || e.getSource() == eventDeleteItem)\n{\nObject comp = events.getLastSelectedPathComponent();\nif (!(comp instanceof EventInstanceNode)) return;\nremoveEvent((EventInstanceNode) comp);\nreturn;\n}\nsuper.actionPerformed(e);\n}", "4695": "private static final ABIType getABITypeImpl(final CPUType cpuType, final String cpuABI) {\nif( null == cpuType || null == cpuABI ) {\nreturn null;\n} else if( CPUFamily.ARM!= cpuType.family ) {\nreturn ABIType.GENERIC_ABI;\n} else if( CPUType.ARM64 == cpuType ||\nCPUType.ARMv8_A == cpuType ) {\nreturn ABIType.EABI_AARCH64;\n}\nreturn ABIType.EABI_GNU_ARMEL;\n}", "4702": "public void consumeExtraParameter(ElementRef parameter) {\nTypeRef type = parameter.type();\nif (type.isBasic()) {\naddArgument(parameter.document(), parameter.name(), type.mirror(), parameter.reference());\n} else if (type.isGroupView()) {\nTypeRef arg = type.arg(0);\nif (arg.isDataModel()) {\nKeyRef key = parameter.resolveKey(arg);\nValueDescription info = key.toTableInfo();\naddInput(parameter.document(), parameter.name(), arg.mirror(), null, parameter.reference(), info);\n} else {\nparameter.error(Messages.getString(\"DslBuilder.errorGroupViewNotDataModelType\")); //$NON-NLS-1$\n}\n} else if (type.isFlatView()) {\nTypeRef arg = type.arg(0);\nif (arg.isDataModel()) {\nValueDescription info = ObjectDescription.of(TYPE_VIEW_INFO, NAME_FLAT_VIEW_INFO_FACTORY);\naddInput(parameter.document(), parameter.name(), arg.mirror(), null, parameter.reference(), info);\n} else {\nparameter.error(Messages.getString(\"DslBuilder.errorFlatViewNotDataModelType\")); //$NON-NLS-1$\n}\n} else {\nthrow new IllegalArgumentException();\n}\n}", "4706": "@Test\npublic void bug57535() throws Exception {\nWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"57535.xlsx\");\nFormulaEvaluator evaluator = wb.getCreationHelper().createFormulaEvaluator();\nevaluator.clearAllCachedResultValues();\nSheet sheet = wb.getSheet(\"Sheet1\");\nCell cell = sheet.getRow(5).getCell(4);\nassertEquals(Cell.CELL_TYPE_FORMULA, cell.getCellType());\nassertEquals(\"E4+E5\", cell.getCellFormula());\nCellValue value = evaluator.evaluate(cell);\nassertEquals(Cell.CELL_TYPE_ERROR, value.getCellType());\nassertEquals(-60, value.getErrorValue());\nassertEquals(\"Formula error: -60\", value.getErrorValueAsString());\n}", "4707": "@Override\npublic void execute(String[] params, Server server, Conversation conversation, IRCService service) throws CommandException\n{\nif (conversation.getType()!= Conversation.TYPE_CHANNEL) {\nthrow new CommandException(service.getString(R.string.only_usable_from_channel));\n}\nStringBuffer userList = new StringBuffer(\"Users \" + conversation.getName() + \":\");\nUser[] mUsers = service.getConnection(server.getId()).getUsers(conversation.getName());\nint mSize = mUsers.length;\nfor (int i = 0; i < mSize; i++) {\nuserList.append(\" \");\nuserList.append(mUsers[i].getPrefix());\nuserList.append(mUsers[i].getNick());\n}\nMessage message = new Message(userList.toString());\nmessage.setColor(Message.COLOR_YELLOW);\nconversation.addMessage(message);\nIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tconversation.getName()\n\t\t);\nservice.sendBroadcast(intent);\n}", "4711": "private void innerQuickShrink(long curBlocks, long maxBlocks, boolean offline) throws DatabaseException, IOException {\nlong oldCurBlocks = curBlocks;\ntry {\ncurBlocks = Math.max(oldCurBlocks, highestBlockNumberInDatabase());\n} catch (DatabaseException e) {\nLogger.error(this, \"Ignoring \"+e+\" in innerQuickShrink initialisation\", e);\n}\nTransaction t = null;\ntry {\nString msg = \"Shrinking store: \"+curBlocks+\" -> \"+maxBlocks+\" (from db \"+chkDB.count()+\", highest \"+highestBlockNumberInDatabase()+\", from file \"+countCHKBlocksFromFile()+ ')';\nSystem.err.println(msg); Logger.normal(this, msg);\nWrapperManager.signalStarting((int)Math.max(0,(curBlocks-maxBlocks)*100)+5*60*1000); // 0.1s per block plus 5 minutes\nwhile(true) {\nt = environment.beginTransaction(null,null);\nlong deleted = 0;\nfor(long i=curBlocks-1;i>=maxBlocks;i--) {\n// Delete the block with this blocknum.\nDatabaseEntry blockNumEntry = new DatabaseEntry();\nLongBinding.longToEntry(i, blockNumEntry);\nOperationStatus result = \n\t\t\t\t\t\tchkDB_blockNum.delete(t, blockNumEntry);\nif(result.equals(OperationStatus.SUCCESS))\ndeleted++;\nif((curBlocks-i) % 2048 == 0) {\nt.commit();\nif(i-1 >= maxBlocks)\nt = environment.beginTransaction(null,null);\nelse\nt = null;\n}\nfreeBlocks.remove(i);\nsynchronized(this) {\nmaxBlocks = maxChkBlocks;\ncurBlocks = chkBlocksInStore;\nif(maxBlocks >= curBlocks) break;\n}\n}\nt.commit();\nSystem.err.println(\"Deleted \"+deleted+\" keys\");\nt = null;\nif(offline) break;\nSystem.err.println(\"Checking...\");\nsynchronized(this) {\nmaxBlocks = maxChkBlocks;\ncurBlocks = chkBlocksInStore;\nif(maxBlocks >= curBlocks) break;\n}\n}\nchkStore.setLength(maxChkBlocks * (dataBlockSize + headerBlockSize));\nchkBlocksInStore = maxChkBlocks;\nSystem.err.println(\"Successfully shrunk store to \"+chkBlocksInStore);\n} finally {\nif(t!= null) t.abort();\n}\n}", "4713": "private static Converter<?> createResponseConverter(Method method, Type responseType,\n      List<Converter.Factory> converterFactories) {\nif (responseType == ResponseBody.class) {\nboolean isStreaming = method.isAnnotationPresent(Streaming.class);\nreturn new OkHttpResponseBodyConverter(isStreaming);\n}\ntry {\nreturn Utils.resolveConverter(converterFactories, responseType);\n} catch (RuntimeException e) { // Wide exception range because factories are user code.\nthrow Utils.methodError(e, method, \"Unable to create converter for %s\", responseType);\n}\n}", "4714": "private void onRemoveSiteSelected() {\nif (getSelectedItem() == AddonSite.ADDON_SITE_URL) {\nDialogInterface.Builder builder = new DialogInterface.Builder(this);\nbuilder.setMessage(getString(R.string.remove_addon_site_title))\n.setTitle(R.string.remove_addon_site_title)\n.setPositiveButton(R.string.remove_addon_site_title, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\npublic void onClick(DialogInterface dialogInterface, int i, String s) {\ndialogInterface.cancel(0);\ngetItems().remove(getSelectedItem());\nstoreSettings();\n}\n\t\t\t\t})\n.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\npublic void onClick(DialogInterface dialogInterface, int i, String s) {\ndialogInterface.cancel(0);\n}\n\t\t\t\t})\n.show();\n}\nelse {\ngetItems().remove(getSelectedItem());\nstoreSettings();\n}\n}", "4715": "private void startup() {\nrestart = false;\nloadResources();\nif (!globalConfig.loadsuccess) {\nSystem.out.println(\"[SimpleServer] Syntax error in comfig.xml! Emergency shutdown...\");\nSystem.exit(1);\n}\nauthenticator = new Authenticator(this);\nplayerList = new PlayerList(this);\nrequestTracker = new RequestTracker(this);\nmessager = new Messager(this);\nmessageLog = new MessageLog(config.properties.get(\"logMessageFormat\"), config.properties.getBoolean(\"logMessages\"));\nminecraft = new MinecraftWrapper(this, options, systemInput);\nif (!minecraft.prepareServerJar()) {\nSystem.out.println(\"[SimpleServer] Please download minecraft_server.jar to the folder with SimpleServer.jar.\");\nSystem.exit(1);\n}\ntry {\nminecraft.start();\n} catch (InterruptedException e) {\n// Severe error happened while starting up.\n// Already on track to stop/restart.\n}\nif (options.getBoolean(\"enableTelnet\")) {\ntelnetServer = new TelnetServer(this);\n}\nif (options.getBoolean(\"enableRcon\")) {\nrconServer = new RconServer(this);\n}\nworld = new WorldFile(options.get(\"levelName\"));\nautoSpaceCheck = new AutoFreeSpaceChecker(this);\nautoBackup = new AutoBackup(this);\nautosave = new AutoSave(this);\nautoRestart = new AutoRestart(this);\nstatistics = new Statistics(this);\nc10t = new AutoRun(this, options.get(\"c10tArgs\"));\nif (options.contains(\"freezeTime\")) {\ntry {\ntime.freeze(time.parse(options.get(\"freezeTime\")));\n} catch (Exception e) {\nSystem.out.println(\"[SimpleServer] Warning: freezeTime option is not valid\");\n}\n}\nbots.ready();\nstatistics.start();\n}", "4717": "public void run() {\nif(Logger.shouldLog(Logger.MINOR, this))\nLogger.minor(this, \"Finished \"+req);\n}", "4718": "protected void generate() throws UnableToCompleteException {\nthis.XML_CALLBACK_TYPE = find(XmlCallback.class);\nthis.METHOD_CALLBACK_TYPE = find(MethodCallback.class);\nthis.TEXT_CALLBACK_TYPE = find(TextCallback.class);\nthis.JSON_CALLBACK_TYPE = find(JsonCallback.class);\nthis.DOCUMENT_TYPE = find(Document.class);\nthis.METHOD_TYPE = find(Method.class);\nthis.STRING_TYPE = find(String.class);\nthis.JSON_VALUE_TYPE = find(JSONValue.class);\nif (source.isInterface() == null) {\nerror(\"Type is not an interface.\");\n}\np(\"private \" + RESOURCE_CLASS + \" resource;\");\np();\nif (source.getAnnotation(Path.class)!= null) {\np(\"private \" + RESOURCE_CLASS + \" resource = \" + source.getAnnotation(Path.class).value();\n}\nif (source.getAnnotation(RemoteServiceRelativePath.class)!= null) {\np(\"private \" + RESOURCE_CLASS + \" resource = \" + source.getAnnotation(RemoteServiceRelativePath.class).value();\n}\np(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n{\np(\"this.resource = resource;\");\n}\ni(-1).p(\"}\");\nfor (JMethod method : source.getMethods()) {\nwriteMethodImpl(method);\n}\n}", "4721": "public void registerResources( final String alias, final String name, final HttpContext httpContext )\nthrows NamespaceException\n{\nif( m_logger.isInfoEnabled() )\n{\nm_logger.info( \"Registering resource: [\" + alias + \"] -> \" + name );\n}\nm_registry.registerResource( alias, name, httpContext );\nif( m_logger.isInfoEnabled() )\n{\nm_logger.info( \"Registered resource: [\" + alias + \"] -> \" + name );\n}\n}", "4722": "public void bind(final Nifty newNifty, final Screen newScreen) {\nscreen = newScreen;\nnifty = newNifty;\n// dynamically add another Textfield\nElement dynamicParent = screen.findElementByName(\"dynamic-parent\");\nPanelCreator panelCreator = new PanelCreator();\npanelCreator.setChildLayout(\"horizontal\");\npanelCreator.setHeight(\"8px\");\npanelCreator.create(newNifty, screen, dynamicParent);\npanelCreator = new PanelCreator();\npanelCreator.setId(\"bla\");\npanelCreator.setChildLayout(\"horizontal\");\nElement row = panelCreator.create(newNifty, screen, dynamicParent);\nCreateLabelControl labelCreator = new CreateLabelControl(\"Dynamic:\");\nlabelCreator.setWidth(\"150px\");\nlabelCreator.setAlign(\"left\");\nlabelCreator.setTextVAlign(\"center\");\nlabelCreator.setTextHAlign(\"left\");\nlabelCreator.create(newNifty, screen, row);\nTextFieldCreator textFieldCreator = new TextFieldCreator();\ntextFieldCreator.create(nifty, screen, row);\ntextFieldCreator.setText(\"Dynamically created TextField\");\n// dynamically change a label name\nElement element = screen.findElementByName(\"labelName\");\nelement.getRenderer(TextRenderer.class).setText(\"Name:\");\n}", "4723": "@Override\npublic void update(AnActionEvent event) {\nevent.getPresentation().setEnabled(!browserPanel.getJenkins().getJobs().isEmpty());\n}", "4728": "private void usage() {\nSystem.out.println(\"Usage: java com.opencms.setup.CmsShell connectstring [init]\");\n}", "4730": "@OnClick(R.id.twitter)\nvoid onTwitterClicked() {\nIntent intent = new Intent(getActivity(), SignIntoTwitter.class);\nintent.putExtra(SignIntoTwitter.EXTRA_TWITTER_ACCOUNT, mTwitterAccount);\ngetActivity().startActivity(intent);\nshowSnabackar(getView(), \"Twitter CardView Clicked\");\n}", "4731": "private void renderSection( PrettyPrintXMLWriter writer, Section section, BookContext context )\nthrows BookDoxiaException\n{\n//        writer.startElement( \"section\" );\n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\nBookContext.BookFile bookFile = (BookContext.BookFile) context.getFiles().get( section.getId() );\nif ( bookFile == null )\n{\nthrow new BookDoxiaException( \"No document that matches section with id=\" + section.getId() + \".\" );\n}\n// ----------------------------------------------------------------------\n//\n// ----------------------------------------------------------------------\nSink itextSink = new ITextSinkFactory().createSink( writer );\nList pipeline = new ArrayList();\n//        pipeline.add( DebugSink.newInstance() );\npipeline.add( itextSink );\nSink sink = PipelineSink.newInstance( pipeline );\ntry\n        {\ndoxia.parse( new FileReader( bookFile.getFile() ), bookFile.getParserId(), sink );\n}\ncatch ( ParserNotFoundException e )\n{\nthrow new BookDoxiaException( \"Parser not found: \" + bookFile.getParserId() + \".\", e );\n}\ncatch ( ParseException e )\n{\nthrow new BookDoxiaException(\n                                          \"Error while parsing document: \" + bookFile.getFile().getAbsolutePath() + \".\",\n                                          e );\n}\ncatch ( FileNotFoundException e )\n{\nthrow new BookDoxiaException( \"Could not find document: \" + bookFile.getFile().getAbsolutePath() + \".\", e );\n}\n//        writer.endElement(); // section\n}", "4733": "public static <T> void bind(T instance, Map<String, Object> values,\n        BindingPolicy policy) throws InstantiationException\n{\nif (instance.getClass().getAnnotation(Bindable.class) == null)\n{\nthrow new IllegalArgumentException(\"Class is not bindable: \"\n+ instance.getClass().getName());\n}\nfinal Collection<ParameterDescriptor> parameterDescriptors = ParameterDescriptorBuilder\n.getParameterDescriptors(instance.getClass(), policy);\nfinal Map<String, Field> fields = ParameterDescriptorBuilder.getFieldMap(instance\n.getClass(), policy);\nfor (ParameterDescriptor parameterDescriptor : parameterDescriptors)\n{\nObject value = values.get(parameterDescriptor.getKey());\n// Try to coerce from class to its instance first\nif (value instanceof Class)\n{\nif (policy == BindingPolicy.RUNTIME)\n{\nthrow new RuntimeException(\n                        \"Only instantiation-time parameters can \"\n+ \"be bound to class values, offending field: \"\n+ parameterDescriptor.getKey());\n}\nClass<?> clazz = ((Class<?>) value);\ntry\n                {\nvalue = clazz.newInstance();\n}\ncatch (IllegalAccessException e)\n{\nthrow new InstantiationException(\n                        \"Could not create instance of class: \" + clazz.getName()\n+ \" for parameter \" + parameterDescriptor.getKey());\n}\n}\nif (value!= null)\n{\n// Check constraints\nConstraint constraint = parameterDescriptor.getConstraint();\nif (constraint!= null)\n{\nif (!constraint.isMet(value))\n{\nthrow new ConstraintViolationException(parameterDescriptor,\n                            constraint, value);\n}\n}\n}\nif (value == null)\n{\n// check the default value of parameter.\nvalue = parameterDescriptor.getDefaultValue();\n}\nfinal Field field = fields.get(parameterDescriptor.key);\nfinal Parameter binding = field.getAnnotation(Parameter.class);\nif (binding!= null && value!= null\n&& value.getClass().getAnnotation(Bindable.class)!= null)\n{\n// Recursively descend into other types.\nbind(value, values, policy);\n}\ntry\n            {\nfield.set(instance, value);\n}\ncatch (Exception e)\n{\nthrow new RuntimeException(\"Could not assign field \"\n+ instance.getClass().getName() + \"#\" + field.getName()\n+ \" with value \" + value, e);\n}\n}\n}", "4735": "private void startAnimation() {\nif (this.animating)\nreturn;\nfinal int startX = this.x;\nfinal int startY = this.y;\nif (this.steps.length() == 0) {\nresetPos(400);\nreturn;\n}\nfinal Step step = this.steps.shift();\nif (step.getX() == startX && step.getY() == startY) {\nstep.setTime(0);\n}\nthis.animating = true;\nthis.moved = true;\nif (this.useTransistion) {\nsetTransistionTime(step.getTime());\npos(step.getX(), step.getY());\nthis.animating = false;\nif (step.getTime()!= 0) {\nbindTransistionEndEvent();\n} else {\nresetPos(0);\n}\nreturn;\n}\nfinal long startTime = System.currentTimeMillis();\nfinal AnimationCallback animationCallback = new AnimationCallback() {\n\n\t\t\t@Override\npublic void execute(double now) {\nif (now >= startTime + step.getTime()) {\nScrollPanelNewPort.this.pos(step.x, step.y);\nScrollPanelNewPort.this.animating = false;\nif (step.getEvent() instanceof AnimationEndEvent) {\n((AnimationEndEvent) step.getEvent()).fireAnimationEnd();\n}\nScrollPanelNewPort.this.startAnimation();\nreturn;\n}\nnow = (now - startTime) / step.getTime() - 1;\ndouble easeOut = Math.sqrt(1 - now * now);\nint newX = (int) Math.round((step.getX() - startX) * easeOut + startX);\nint newY = (int) Math.round((step.getY() - startY) * easeOut + startY);\nScrollPanelNewPort.this.pos(newX, newY);\nif (ScrollPanelNewPort.this.animating)\nScrollPanelNewPort.this.aniTime = AnimationScheduler.get().requestAnimationFrame(this);\n}\n\t\t};\nanimationCallback.execute(startTime);\n}", "4738": "public void testInterceptorWithPredicate() throws Exception {\ncontext.addRoutes(new RouteBuilder() {\n            public void configure() throws Exception {\nintercept(header(\"user\").isEqualTo(\"test\")).to(\"mock:test\");\nfrom(\"seda:order\").to(\"mock:ok\");\n}\n        });\nMockEndpoint mockTest = getMockEndpoint(\"mock:test\");\nmockTest.expectedBodiesReceived(\"Camel in Action\");\nMockEndpoint mockOk = getMockEndpoint(\"mock:ok\");\nmockOk.expectedBodiesReceived(\"Camel in Action\");\ntemplate.sendBodyAndHeader(\"seda:order\", \"Camel in Action\", \"user\", \"test\");\nmockTest.assertIsSatisfied();\nmockOk.assertIsSatisfied();\n}", "4741": "private void doCorrelations(List<Correlation> correlations, OScope.Variable var,\n            Collection<OScope.CorrelationSet> assertCorrelations, Collection<OScope.CorrelationSet> initCorrelations) {\nfor (Correlation correlation : correlations) {\nOScope.CorrelationSet cset = _context.resolveCorrelationSet(correlation.getCorrelationSet());\nswitch (correlation.getInitiate()) {\ncase NO:\nassertCorrelations.add(cset);\nbreak;\ncase YES:\ninitCorrelations.add(cset);\nbreak;\ncase JOIN:\nthrow new UnsupportedOperationException();\n}\nfor (OProcess.OProperty property : cset.properties) {\n// Force resolution of alias, to make sure that we have one for\n// this variable-property pair.\ntry {\n_context.resolvePropertyAlias(var, property.name);\n} catch (CompilationException ce) {\nif (ce.getCompilationMessage().source == null) {\nce.getCompilationMessage().source = correlation;\n}\nthrow ce;\n}\n// onMessage.\n}\n}\n}", "4743": "@Test\n@SpecAssertions({\n\t\t\t@SpecAssertion(section = \"\", id = \"\")\n\t})\npublic void testClockProviderSpecifiedInValidationXmlHasNoDefaultConstructor() {\ntry {\nTestUtil.getValidatorUnderTest();\nfail( \"Bootstrapping should have failed due to missing no-arg constructor in ClockProvider\" );\n}\ncatch ( ValidationException e ) {\n// success\n}\n}", "4745": "public void execute()\nthrows MojoExecutionException\n{\nFile baseDir = new File( inputDirectory );\nFile zipFile = null;\ntry\n        {\nzipFile = File.createTempFile( \"site\", \".zip\", new File( workingDirectory ) );\n}\ncatch ( IOException e )\n{\nthrow new MojoExecutionException( \"Cannot create site archive!\", e );\n}\nSshCommandExecutor commandExecutor = new ScpWagon();\ntry\n        {\nDistributionManagement distributionManagement = project.getDistributionManagement();\nif ( distributionManagement == null )\n{\nString msg = \"distributionManagement element is missing in the POM: \"\n+ project.getId();\nthrow new MojoExecutionException( msg );\n}\nif ( distributionManagement.getSite() == null )\n{\nString msg = \"distributionManagement/repository element is missing in the POM: \"\n+ project.getId();\nthrow new MojoExecutionException( msg );\n}\nString url = distributionManagement.getSite().getUrl();\nString id = distributionManagement.getSite().getId();\nif ( url == null )\n{\nString msg = \"distributionManagement/site/url element is missing in the POM: \"\n+ project.getId();\nthrow new MojoExecutionException( msg );\n}\nRepository repository = new Repository( id, url );\ncommandExecutor.connect( repository, WagonUtils.getAuthInfo() );\nString basedir = repository.getBasedir();\nList files = FileUtils.getFileNames( baseDir, \"**/**\", \"\", false );\ncreateZip( files, zipFile, baseDir );\nDebug debug = new Debug();\ncommandExecutor.addSessionListener( debug );\ncommandExecutor.addTransferListener( debug );\nString cmd = \" mkdir -p \" + basedir;\ncommandExecutor.executeCommand( cmd );\ncommandExecutor.put( zipFile, zipFile.getName() );\ncmd = \" cd \" + basedir + \";\" + unzipCommand + \" \" + zipFile.getName() + \"\\n\";\ncommandExecutor.executeCommand( cmd );\nString rmCommand = \"rm  \" + basedir + \"/\" + zipFile.getName();\ncommandExecutor.executeCommand( rmCommand );\n}\ncatch( Exception e )\n{\nthrow new MojoExecutionException( \"Error transfering site archive!\", e );\n}\nfinally\n        {\nif ( commandExecutor!= null )\n{\ntry\n                {\ncommandExecutor.disconnect();\n}\ncatch ( ConnectionException e )\n{\n//what to to here?\n}\n}\nif (!zipFile.delete() )\n{\nzipFile.deleteOnExit();\n}\n}\n}", "4751": "private void testAppliesNoMasterBlock(String noMasterBlockSetting, ClusterBlock expectedBlock) {\ntry (Cluster cluster = new Cluster(3)) {\ncluster.runRandomly();\ncluster.stabilise();\nfinal ClusterNode leader = cluster.getAnyLeader();\nleader.submitUpdateTask(\"update NO_MASTER_BLOCK_SETTING\", cs -> {\nfinal Builder settingsBuilder = Settings.builder().put(cs.metadata().persistentSettings());\nsettingsBuilder.put(NO_MASTER_BLOCK_SETTING.getKey(), noMasterBlockSetting);\nreturn\n                    ClusterState.builder(cs).metadata(Metadata.builder(cs.metadata()).persistentSettings(settingsBuilder.build())).build();\n}, (source, e) -> {});\ncluster.runFor(DEFAULT_CLUSTER_STATE_UPDATE_DELAY, \"committing setting update\");\nleader.disconnect();\ncluster.runFor(defaultMillis(FOLLOWER_CHECK_TIMEOUT_SETTING) + defaultMillis(FOLLOWER_CHECK_INTERVAL_SETTING)\n+ DEFAULT_CLUSTER_STATE_UPDATE_DELAY, \"detecting disconnection\");\nassertThat(leader.getLastAppliedClusterState().blocks().global(), hasItem(expectedBlock));\nfinal ClusterNode leaderReconnectedNode = cluster.getAnyLeader();\nassertThat(leaderReconnectedNode.getLastAppliedClusterState().blocks().global(), hasItem(expectedBlock));\nassertThat(leaderReconnectedNode.getLastAppliedClusterState().blocks().global(), hasItem(ClusterBlock.EMPTY));\n}\n}", "4752": "void devicePropertyChangedCallback(byte[] address, int[] types, byte[][] values) {\nIntent intent;\nbyte[] val;\nint type;\nBluetoothDevice bdDevice = getDevice(address);\nDeviceProperties device;\nif (bdDevice == null) {\ndevice = addDeviceProperties(address);\nbdDevice = getDevice(address);\n} else {\ndevice = getDeviceProperties(bdDevice);\n}\nfor (int j = 0; j < types.length; j++) {\ntype = types[j];\nval = values[j];\nif(val.length <= 0)\nerrorLog(\"devicePropertyChangedCallback: bdDevice: \" + bdDevice + \", value is empty for type: \" + type);\nelse {\nsynchronized(mObject) {\nswitch (type) {\ncase AbstractionLayer.BT_PROPERTY_BDNAME:\ndevice.mName = new String(val);\nintent = new Intent(BluetoothDevice.ACTION_NAME_CHANGED);\nintent.putExtra(BluetoothDevice.EXTRA_DEVICE, bdDevice);\nintent.putExtra(BluetoothDevice.EXTRA_NAME, device.mName);\nintent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);\nmAdapterService.sendBroadcast(intent, mAdapterService.BLUETOOTH_PERM);\ndebugLog(\"Remote Device name is: \" + device.mName);\nbreak;\ncase AbstractionLayer.BT_PROPERTY_REMOTE_FRIENDLY_NAME:\nif (device.mAlias!= null) {\nSystem.arraycopy(val, 0, device.mAlias, 0, val.length);\n}\nbreak;\ncase AbstractionLayer.BT_PROPERTY_BDADDR:\ndevice.mAddress = val;\ndebugLog(\"Remote Address is:\" + Utils.getAddressStringFromByte(val));\nbreak;\ncase AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE:\ndevice.mBluetoothClass = Utils.byteArrayToInt(val);\nintent = new Intent(BluetoothDevice.ACTION_CLASS_CHANGED);\nintent.putExtra(BluetoothDevice.EXTRA_DEVICE, bdDevice);\nintent.putExtra(BluetoothDevice.EXTRA_CLASS,\n                                    new BluetoothClass(device.mBluetoothClass));\nintent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);\nmAdapterService.sendBroadcast(intent, mAdapterService.BLUETOOTH_PERM);\ndebugLog(\"Remote class is:\" + device.mBluetoothClass);\nbreak;\ncase AbstractionLayer.BT_PROPERTY_UUIDS:\nint numUuids = val.length/AbstractionLayer.BT_UUID_SIZE;\ndevice.mUuids = Utils.byteArrayToUuid(val);\nsendUuidIntent(bdDevice);\nbreak;\ncase AbstractionLayer.BT_PROPERTY_TYPE_OF_DEVICE:\ndevice.mDeviceType = Utils.byteArrayToInt(val);\nbreak;\ncase AbstractionLayer.BT_PROPERTY_REMOTE_RSSI:\ndevice.mRssi = Utils.byteArrayToShort(val);\nbreak;\n}\n}\n}\n}\n}", "4753": "private void stopPulse( Boolean stopViolently )\n{\npulse.suicideAfterCurrentCycle();\npulseThread.interrupt();\nif (!stopViolently )\n{\nwaitForRunningTasks();\n}\npulse = null;\npulseThread = null;\n}", "4758": "@Override\npublic void createPartControl( Composite parent )\n{\nviewer = new TreeViewer( parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER );\n// Initializing ContentProvider and LabelProvider\nviewer.setContentProvider( new BrowserViewContentProvider() );\nviewer.setLabelProvider( new BrowserViewLabelProvider() );\n// Adding DoubleClick behavior\nviewer.addDoubleClickListener( new IDoubleClickListener()\n{\n            public void doubleClick( DoubleClickEvent event )\n{\n// What we get from the treeViewer is a StructuredSelection\nStructuredSelection selection = ( StructuredSelection ) event.getSelection();\n// Here's the real object\nObject objectSelection = selection.getFirstElement();\nviewer.setExpandedState( objectSelection,!viewer.getExpandedState( objectSelection ) );\n}\n        } );\n// Creating the controller, registering the view to the controller and creating the Actions\ncontroller = BrowserViewController.getInstance();\ncontroller.setView( this );\ncontroller.createActions();\n// Registring the view as a Listener for Connections changes\nConnections.getInstance().addListener( this );\n// Registering the Viewer, so other views can be notified when the viewer selection changes\ngetSite().setSelectionProvider( viewer );\ncreateContextMenu();\ncreateToolbarButtons();\n// Creating the First Node and displaying Connections\nviewer.setInput( TreeViewerRootNode.getInstance() );\n}", "4762": "@Override\npublic void markBlockChanged(Chunk chunk, BlockPos position) {\nif (chunk.getSections()[position.getY() >> ChunkStore.CHUNK_SHIFTS]!= null) {\n((ServerChunkProvider) getWorld().getChunkProvider()).markBlockChanged(position);\n}\n}", "4767": "private synchronized void processCurrentCommand() {\ntry {\nHostCommand command = host.getCurrentCommand();\n// If there is no current command, move on to the next one.\nif (command == null) {\ncommand = host.nextCommand();\n}\n// If there is a command available, process it.\nif (command!= null) {\nprocessCommand(command, host.getState());\n}\n} catch (IOException e) {\nLOG.error(\"Failed to process current command.\", e);\n}\n}", "4770": "public void merge(JBossGenericBeanMetaData override, MessageDrivenBeanMetaData original)\n{\nsuper.merge(override, original);\nif(override!= null && override.getAcknowledgeMode()!= null)\nthis.acknowledgeMode = override.getAcknowledgeMode();\nelse if(original!= null)\nthis.acknowledgeMode = original.acknowledgeMode;\nif((override!= null && override.getActivationConfig()!= null) || (original!= null && original.activationConfig!= null))\n{\nactivationConfig = new ActivationConfigMetaData();\nactivationConfig.merge(override!= null? override.getActivationConfig() : null, original!= null? original.activationConfig : null);\n}\nif(override!= null && override.getDestinationJndiName()!= null) {\nif(activationConfig == null ) {\nactivationConfig = new ActivationConfigMetaData();\n}\nActivationConfigPropertyMetaData destination = null;\nif(activationConfig.getActivationConfigProperties() == null) {\nactivationConfig.setActivationConfigProperties(new ActivationConfigPropertiesMetaData());\n}\nfor(ActivationConfigPropertyMetaData prop : activationConfig.getActivationConfigProperties()) {\nif(prop.getActivationConfigPropertyName().equals(\"destination\")) {\ndestination = prop;\nbreak;\n}\n}\nif(destination == null) {\ndestination = new ActivationConfigPropertyMetaData();\ndestination.setActivationConfigPropertyName(\"destination\");\nactivationConfig.getActivationConfigProperties().add(destination);\n}\ndestination.setValue(override.getDestinationJndiName());\n}\nif((override!= null && override.getAroundInvokes()!= null) || (original!= null && original.aroundInvokes!= null))\n{\naroundInvokes = new AroundInvokesMetaData();\naroundInvokes.merge(override!= null? override.getAroundInvokes() : null, original!= null? original.aroundInvokes : null);\n}\nif(override!= null && override.getMessageDestinationLink()!= null)\nthis.messageDestinationLink = override.getMessageDestinationLink();\nelse if(original!= null)\nthis.messageDestinationLink = original.messageDestinationLink;\nif(override!= null && override.getMessageDestinationType()!= null)\nthis.messageDestinationType = override.getMessageDestinationType();\nelse if(original!= null)\nthis.messageDestinationType = original.messageDestinationType;\nif(override!= null && override.getMessageSelector()!= null)\nthis.messageSelector = override.getMessageSelector();\nelse if(original!= null)\nthis.messageSelector = original.messageSelector;\nif(override!= null && override.getMessagingType()!= null)\nthis.messagingType = override.getMessagingType();\nelse if(original!= null)\nthis.messagingType = original.messagingType;\nif(override!= null && override.getSubscriptionDurability()!= null)\nthis.subscriptionDurability = override.getSubscriptionDurability();\nelse if(original!= null)\nthis.subscriptionDurability = original.subscriptionDurability;\nif(override!= null && override.getTimeoutMethod()!= null)\nthis.timeoutMethod = override.getTimeoutMethod();\nelse if(original!= null)\nthis.timeoutMethod = original.timeoutMethod;\nif(override!= null && override.getTransactionType()!= null)\nthis.transactionType = override.getTransactionType();\nelse if(original!= null)\nthis.transactionType = original.transactionType;\n}", "4774": "@Override\npublic void playSound(Location location, Sound sound, float volume, float pitch) {\nif (location == null || sound == null) return;\nfor (Player player : getRawPlayers()) {\nif (player.getLocation().distanceSquared(location) <= 24 * 24) {\nplayer.playSound(location, sound, volume, pitch);\n}\n}\n}", "4777": "public void evaluate(RDFHandler handler) throws QueryEvaluationException,\n\t\t\tRDFHandlerException {\nevaluate(new AGRDFHandler(RDFFormat.NTRIPLES, handler, httpCon.getValueFactory(),httpCon.getHttpRepoClient().getAllowExternalBlankNodeIds()));\n}", "4778": "@Override\npublic void showNotification(final InAppNotification notification, final Activity parent) {\nif (null == notification) {\nreturn;\n}\nif (notification.getType() == InAppNotification.Type.TAKEOVER) {\nshowTakeoverInAppNotif(parent, notification);\n} else {\nshowMiniInAppNotif(parent, notification);\n}\ntrack(\"$campaign_delivery\", notification.getCampaignProperties());\n}", "4780": "private void initializeMap() {\nif(mTourItem.getPath()!= null) {\nmSpatialReferenceWGS84 = SpatialReference.create(WGS84_WKID);\nmSpatialReferenceWebMerc = SpatialReference.create(WEBMERC_WKID);\nmView.findViewById(R.id.tourDirectionsMapContainer).setVisibility(View.VISIBLE);\nmMapImageView = (ResizableImageView) mView.findViewById(R.id.tourDirectionsMapIV);\nfinal List<GeoPoint> geoPoints = mTourItem.getPath().getGeoPoints();\nGeoRect geoRect = new GeoRect(geoPoints);\nGeoPoint center = geoRect.getCenter();\nmCenterPoint = (com.esri.core.geometry.Point)GeometryEngine.project(new com.esri.core.geometry.Point(center.getLongitudeE6()/1000000., center.getLatitudeE6()/1000000.), \n\t\t\t\t\tmSpatialReferenceWGS84, mSpatialReferenceWebMerc);\nmMapImageView.setOnSizeChangedListener(new ResizableImageView.OnSizeChangedListener() {\t\n\t\t\t\t@Override\npublic void onSizeChanged(final int w, final int h, int oldw, int oldh) {\nif (w == 0 || h == 0) {\n// map not ready to be drawn\nreturn;\n}\n// add a padding (subtract from image size)\nint padding = AttributesParser.parseDimension(\"1dip\", mContext);\nint width = w - 2 * padding;\nint height = h - 2 * padding;\nString url = getMapURL( width, height);\nmMapImageView.setURL(url);\n// add the current location dot overlay\nmMapImageView.setOverlay(new ResizableImageView.Overlay() {\n\t\t\t\t\t\t@Override\npublic void draw(Canvas canvas) {\n// draw single segment\ndrawGeoPointsPath(canvas, R.dimen.tourSingleSegmentPathWidth, geoPoints, w, h);\n// draw complete path\ndrawGeoPointsPath(canvas, R.dimen.tourPathWidth, mTour.getPathGeoPoints(), w, h);\n// draw stop markers\nBitmapDrawable firstImage = (BitmapDrawable) mContext.getResources().getDrawable(R.drawable.map_starting_arrow);\nBitmapDrawable lastImage = (BitmapDrawable) mContext.getResources().getDrawable(R.drawable.map_ending_arrow);\ndrawArrow(canvas, geoPoints.get(0), geoPoints.get(1), firstImage, true, w, h);\ndrawArrow(canvas, geoPoints.get(geoPoints.size()-1), geoPoints.get(geoPoints.size()-2), lastImage, false, w, h);\nif(mLocation!= null) {\nGeoPoint location = new GeoPoint((int) (mLocation.getLatitude() * 1000000), (int) (mLocation.getLongitude() * 1000000));\nPoint center = getPoint(location, w, h);\n// draw error circle\nPaint errorCirclePaint = new Paint();\nerrorCirclePaint.setARGB(127, 0, 0, 255);\nerrorCirclePaint.setAntiAlias(true);\nfloat errorRadius = canvasDrawer.metersToPixels(mLocation.getAccuracy(), location);\n// do not show location if not on map or error radius is bigger than map\nif(\n\t\t\t\t\t\t\t\t\tcenter.x < 0 ||\ncenter.x > w ||\ncenter.y < 0 ||\ncenter.y > h ||\nerrorRadius * 2 > Math.max(w, h) ) {\nreturn;\n}\ncanvas.drawCircle(center.x, center.y, errorRadius, errorCirclePaint);\n// draw bullseye\nPaint centerPaint = new Paint();\ncenterPaint.setAntiAlias(true);\ncenterPaint.setARGB(255, 0, 0, 255);\ncanvas.drawCircle(center.x, center.y, 5, centerPaint);\n}\n}\n\t\t\t\t\t});\n}\n\t\t\t});\nif(mMapImageView.getHeight() > 0) {\nmMapImageView.notifyOnSizeChangedListener();\n}\n}\n}", "4787": "public void notifyHostEmulationData(byte[] data) {\nLog.d(TAG, \"notifyHostEmulationData\");\nString selectAid = findSelectAid(data);\nComponentName resolvedService = null;\nsynchronized (mLock) {\nif (mState == STATE_IDLE) {\nLog.e(TAG, \"Got data in idle state.\");\nreturn;\n} else if (mState == STATE_W4_DEACTIVATE) {\nLog.e(TAG, \"Dropping APDU in STATE_W4_DECTIVATE\");\nreturn;\n}\nif (selectAid!= null) {\nAidResolveInfo resolveInfo = mAidCache.resolveAidPrefix(selectAid);\nif (resolveInfo == null || resolveInfo.services.size() == 0) {\n// Tell the remote we don't handle this AID\nNfcService.getInstance().sendData(AID_NOT_FOUND);\nreturn;\n}\nmLastSelectedAid = resolveInfo.aid;\nif (resolveInfo.defaultService!= null) {\n// Resolve to default\nresolvedService = resolveInfo.defaultService.getComponent();\n// Check if resolvedService requires unlock\nif (resolveInfo.defaultService.requiresUnlock() &&\nmKeyguard.isKeyguardLocked() && mKeyguard.isKeyguardSecure()) {\nString category = mAidCache.getCategoryForAid(resolveInfo.aid);\n// Just ignore all future APDUs until next tap\nmState = STATE_W4_DEACTIVATE;\nlaunchTapAgain(resolvedService, category);\nreturn;\n}\n} else {\n// We have no default, and either one or more services.\n// Ask the user to confirm.\n// Get corresponding category\nString category = mAidCache.getCategoryForAid(resolveInfo.aid);\n// Just ignore all future APDUs until we resolve to only one\nmState = STATE_W4_DEACTIVATE;\nlaunchResolver((ArrayList<ApduServiceInfo>)resolveInfo.services, null, category);\nreturn;\n}\n}\nswitch (mState) {\ncase STATE_W4_SELECT:\nif (selectAid!= null) {\nMessenger existingService = bindServiceIfNeededLocked(resolvedService);\nif (existingService!= null) {\nLog.d(TAG, \"Binding to existing service\");\nmState = STATE_XFER;\nsendDataToServiceLocked(existingService, data);\n} else {\n// Waiting for service to be bound\nLog.d(TAG, \"Waiting for new service.\");\n// Queue SELECT APDU to be used\nmSelectApdu = data;\nmState = STATE_W4_SERVICE;\n}\n} else {\nLog.d(TAG, \"Dropping non-select APDU in STATE_W4_SELECT\");\nNfcService.getInstance().sendData(UNKNOWN_ERROR);\n}\nbreak;\ncase STATE_W4_SERVICE:\nLog.d(TAG, \"Unexpected APDU in STATE_W4_SERVICE\");\nbreak;\ncase STATE_XFER:\nif (selectAid!= null) {\nMessenger existingService = bindServiceIfNeededLocked(resolvedService);\nif (existingService!= null) {\nsendDataToServiceLocked(existingService, data);\nmState = STATE_XFER;\n} else {\n// Waiting for service to be bound\nmSelectApdu = data;\nmState = STATE_W4_SERVICE;\n}\n} else if (mActiveService!= null) {\n// Regular APDU data\nsendDataToServiceLocked(mActiveService, data);\n} else {\n// No SELECT AID and no active service.\nLog.d(TAG, \"Service no longer bound, dropping APDU\");\n}\nbreak;\n}\n}\n}", "4789": "private void setKeyboardMode(int mode, int imeOptions, boolean enableVoice, boolean isSymbols) {\nif (mInputView == null) return;\nmMode = mode;\nmImeOptions = imeOptions;\nmakeSymbolsKeyboardIds();\nif (enableVoice!= mHasVoice) {\nsetVoiceMode(enableVoice, mVoiceOnPrimary);\n}\nmIsSymbols = isSymbols;\nmInputView.setPreviewEnabled(mInputMethodService.getPopupOn());\nKeyboardId id = getKeyboardId(mode, imeOptions, isSymbols);\nLatinKeyboard keyboard = null;\nkeyboard = getKeyboard(id);\nif (mode == MODE_PHONE) {\nmInputView.setPhoneKeyboard(keyboard);\n}\nmCurrentId = id;\nmInputView.setKeyboard(keyboard);\nkeyboard.setShifted(false);\nkeyboard.setShiftLocked(keyboard.isShiftLocked());\nkeyboard.setImeOptions(mInputMethodService.getResources(), mode, imeOptions);\nkeyboard.setColorOfSymbolIcons(mIsAutoCompletionActive, isBlackSym());\n// Update the settings key state because number of enabled IMEs could have been changed\nupdateSettingsKeyState(PreferenceManager.getDefaultSharedPreferences(mInputMethodService));\n}", "4793": "public void removeWeblogEntry(WeblogEntry entry) throws WebloggerException {\nWeblog weblog = entry.getWebsite();\nCommentSearchCriteria csc = new CommentSearchCriteria();\ncsc.setEntry(entry);\n// remove comments\nList<WeblogEntryComment> comments = getComments(csc);\nfor (WeblogEntryComment comment : comments) {\nthis.strategy.remove(comment);\n}\n// remove tags aggregates\nif (entry.getTags()!= null) {\nfor (Iterator it = entry.getTags().iterator(); it.hasNext(); ) {\nWeblogEntryTag tag = (WeblogEntryTag) it.next();\nupdateTagCount(tag.getName(), entry.getWebsite(), -1);\nit.remove();\nthis.strategy.remove(tag);\n}\n}\n// remove attributes\nif (entry.getEntryAttributes()!= null) {\nfor (Iterator it = entry.getEntryAttributes().iterator(); it.hasNext(); ) {\nWeblogEntryAttribute att = (WeblogEntryAttribute) it.next();\nit.remove();\nthis.strategy.remove(att);\n}\n}\n// remove entry\nthis.strategy.remove(entry);\n// update weblog last modified date.  date updated by saveWebsite()\nif (entry.isPublished()) {\nroller.getWeblogManager().saveWeblog(weblog);\n}\n// remove entry from cache mapping\nthis.entryAnchorToIdMap.remove(entry.getWebsite().getHandle()+\":\"+entry.getAnchor());\n}", "4794": "Widget asWidget() {\nVerticalPanel layout = new VerticalPanel();\nlayout.setStyleName(\"fill-layout-width\");\nfinal Form<HttpConnector> form = new Form<HttpConnector>(HttpConnector.class);\nTextBoxItem name = new TextBoxItem(\"name\", \"Name\");\nTextBoxItem socket = new TextBoxItem(\"socketBinding\", \"Socket Binding\") {\n\n            private String errOrig;\n@Override\npublic boolean validate(String value) {\nboolean parentValid = super.validate(value);\nboolean bindingValid = true;\nif(parentValid)\n{\nfor(HttpConnector existing : connectors)\n{\nif(existing.getSocketBinding().equals(value))\n{\nerrOrig = getErrMessage();\nsetErrMessage(\"Socket binding already in use\");\nbindingValid = false;\n}\n}\n}\nreturn parentValid && bindingValid;\n}\n        };\nComboBoxItem protocol = new ComboBoxItem(\"protocol\", \"Protocol\");\nComboBoxItem scheme = new ComboBoxItem(\"scheme\", \"Scheme\");\nprotocol.setDefaultToFirstOption(true);\nprotocol.setValueMap(new String[]{\"HTTP/1.1\", \"AJP/1.3\"});\nscheme.setDefaultToFirstOption(true);\nscheme.setValueMap(new String[]{\"http\", \"https\"});\nCheckBoxItem enabled = new CheckBoxItem(\"enabled\", \"Enabled?\");\nenabled.setValue(Boolean.TRUE);\nform.setFields(name,socket,protocol,scheme, enabled);\nfinal FormHelpPanel helpPanel = new FormHelpPanel(\n                new FormHelpPanel.AddressCallback() {\n                    @Override\npublic ModelNode getAddress() {\nModelNode address = Baseadress.get();\naddress.add(\"subsystem\", \"web\");\naddress.add(\"connector\", \"*\");\nreturn address;\n}\n                }, form\n        );\nlayout.add(helpPanel.asWidget());\nlayout.add(form.asWidget());\nDialogueOptions options = new DialogueOptions(\n                new ClickHandler() {\n\n                    @Override\npublic void onClick(ClickEvent event) {\nFormValidation validation = form.validate();\nif(!validation.hasErrors())\npresenter.onCreateConnector(form.getUpdatedEntity());\n}\n                },\n                new ClickHandler() {\n\n                    @Override\npublic void onClick(ClickEvent event) {\npresenter.closeDialogue();\n}\n                }\n        );\nlayout.add(options);\nreturn new WindowContentBuilder(layout, options).build();\n}", "4798": "@SuppressWarnings(\"unchecked\")\nprivate void setupFields(\n      BSPPeer<Writable, Writable, Writable, Writable, Writable, Writable, Writable, Writable, GraphJobMessage> peer)\nthrows IOException {\nthis.peer = peer;\nthis.conf = peer.getConfiguration();\nmaxIteration = peer.getConfiguration().getInt(\"hama.graph.max.iteration\",\n        -1);\nGraphJobRunner.<V, E, M> initClasses(conf);\npartitioner = (Partitioner<V, M>) org.apache.hadoop.util.ReflectionUtils\n.newInstance(\n            conf.getClass(\"bsp.input.partitioner.class\", HashPartitioner.class),\n            conf);\nif (!conf.getClass(MESSAGE_COMBINER_CLASS_KEY, Combiner.class).equals(\n        Combiner.class)) {\nLOG.debug(\"Combiner class: \" + conf.get(MESSAGE_COMBINER_CLASS_KEY));\ncombiner = (Combiner<M>) org.apache.hadoop.util.ReflectionUtils\n.newInstance(conf.getClass(\"hama.vertex.message.combiner.class\",\n              Combiner.class), conf);\n}\nClass<?> outputWriter = conf.getClass(\n        GraphJob.VERTEX_OUTPUT_WRITER_CLASS_ATTR, VertexOutputWriter.class);\nvertexOutputWriter = (VertexOutputWriter<Writable, Writable, V, E, M>) ReflectionUtils\n.newInstance(outputWriter);\naggregationRunner = new AggregationRunner<V, E, M>();\naggregationRunner.setupAggregators(peer);\nvertices = new ListVerticesInfo();\nvertices.init(this, conf, peer.getTaskId());\n}", "4799": "private void runInAppCallback(final InAppNotification tryNotification, final InAppNotificationCallbacks callbacks) {\nfinal Runnable task = new Runnable() {\n            @Override\npublic void run() {\nInAppNotification reportNotification = null;\nif (null!= tryNotification) {\nfinal String imageUrl = tryNotification.getImageUrl();\nfinal ServerMessage imageMessage = newPoster();\nfinal ServerMessage.Result result = imageMessage.get(imageUrl, null);\nif (result.getStatus()!= ServerMessage.Status.SUCCEEDED) {\n// Shouldn't drop this notification on the floor if this is a connectivity issue!\nLog.i(LOGTAG, \"Could not access image at \" + imageUrl);\n} else {\nfinal byte[] imageBytes = result.getResponseBytes();\nfinal Bitmap image = BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.length);\nif (null == image) {\nLog.w(LOGTAG, \"Notification referred to bad or corrupted image at \" + imageUrl);\n} else {\nreportNotification = tryNotification;\n// SET IMAGE HERE! TODO TODO TODO\n}\n}\n}\ncallbacks.foundNotification(reportNotification);\n}\n        };\nrunOnIsolatedThread(task);\n}", "4802": "public void updateProtection(LoadBalancerEndpointConfiguration config, StingrayRestClient client, LoadBalancer loadBalancer, Protection protection) throws InsufficientRequestException, StmRollBackException {\nString vsName = ZxtmNameBuilder.genVSName(loadBalancer);\nLOG.debug(String.format(\"Updating protection class on '%s'...\", vsName));\nProtection curProtection = null;\ntry {\ncurProtection = client.getProtection(vsName);\n} catch (StingrayRestClientObjectNotFoundException e) {\nLOG.warn(String.format(\"Object not found when updating virtual server: %s, this is expected...\", vsName));\n} catch (StingrayRestClientException e) {\nLOG.error(String.format(\"Error when retrieving pool: %s: ignoring...\", vsName));\n}\ntry {\nclient.updateProtection(vsName, protection);\n} catch (Exception ex) {\nLOG.error(String.format(\"Error updating virtual server: %s Rolling back! \\n Exception: %s Trace: %s\",\n                    vsName, ex.getCause().getMessage(), Arrays.toString(ex.getCause().getStackTrace())));\nrollbackProtection(client, loadBalancer, curProtection);\n}\n}", "4804": "@Subscribe\npublic void syncStateChanged(final SyncPendingMessagesState state) {\nmState = state;\nif (mState.isInitialState()) {\nreturn;\n}\nif (state.isError()) {\ncreateNotification(R.string.sync_in_completed,\n                    state.getNotification(getResources()), getPendingIntent());\n}\nif (state.isRunning()) {\nif (state.syncType == MANUAL) {\nupdateSyncStatusNotification(state);\n}\n} else {\nlog(state.isCanceled()? getString(R.string.canceled) : getString(R.string.done));\nstopForeground(true);\nstopSelf();\n}\n}", "4807": "@Override\npublic void onChange(boolean selfChange) {\nmSortOrder = -1;\nmDisplayOrder = -1;\nif (selfChange) {\nmParentContext.onChange(this);\n}\n}", "4811": "private void appendPropertiesToReactorProjects() {\nfor (MavenProject mavenProject : reactorProjects) {\nlog.info(\"{}] project {}\", mavenProject.getName(), mavenProject.getName());\npublishPropertiesInto(mavenProject.getProperties());\nmavenProject.setContextValue(CONTEXT_KEY, properties);\n}\n}", "4812": "@Override\npublic void write(final int b) throws IOException {\nif (buffer == null) {\nbuffer = ByteBuffer.wrap(new byte[] {(byte) b });\n}\nbuffer.clear();\nbuffer.put((byte) b);\nchannel.write(buffer);\ncompressedCrc32.update(b);\nfileBytesWritten++;\n}", "4813": "public void stateDestroyed(ItemState destroyed) {\n// underlying state has been permanently destroyed\nif (isTransient || status!= STATUS_EXISTING) {\nstatus = STATUS_STALE_DESTROYED;\n} else {\nstatus = STATUS_EXISTING_REMOVED;\n}\n// @todo propagate event to our listeners too?\n}", "4816": "@Override\nprotected void onCreate(Bundle savedInstanceState) {\ngetMetaData();\nsuper.onCreate(savedInstanceState);\nif (getActivity().getResources().getBoolean(R.bool.header_show_on_create)) {\nhighlightHeader();\n}\n}", "4819": "protected void generateJarArchive( WarPackagingContext context )\nthrows MojoExecutionException\n{\nfinal String archiveName = context.getProject().getBuild().getFinalName() + \".jar\";\nfinal String targetFilename = LIB_PATH + archiveName;\nif ( context.getWebappStructure().registerFile( Overlay.currentProjectInstance().getId(), targetFilename ) )\n{\nfinal File libDirectory = new File( context.getWebappDirectory(), LIB_PATH );\nfinal File jarFile = new File( libDirectory, archiveName );\nfinal ClassesPackager packager = new ClassesPackager();\npackager.packageClasses( context.getClassesDirectory(), jarFile, context.getJarArchiver(),\n                                     context.getProject(), context.getArchive() );\n}\nelse\n        {\ncontext.getLog().warn(\n                \"Could not generate archive classes file[\" + targetFilename + \"] has already been copied.\" );\n}\n}", "4820": "@Override\npublic void setProperty(SecurityContext securityContext, GraphObject obj, List<T> collection) throws FrameworkException {\nif (obj instanceof AbstractNode) {\nAbstractNode sourceNode = (AbstractNode)obj;\nif (collection!= null &&!collection.isEmpty()) {\nfor (GraphObject targetNode : collection) {\nif (targetNode!= null) {\ncreateRelationship(securityContext, sourceNode, (AbstractNode)targetNode);\n}\n}\n} else {\n// new value is null\nList<T> existingCollection = getProperty(securityContext, obj, true);\n// do nothing if value is already null\nif (existingCollection == null || (existingCollection!= null && existingCollection.isEmpty())) {\nreturn;\n}\nfor (GraphObject targetNode : existingCollection) {\nremoveRelationship(securityContext, sourceNode, (AbstractNode)targetNode);\n}\n}\n} else {\nlogger.log(Level.WARNING, \"Property {0} is registered on illegal type {1}\", new Object[] { this, obj.getClass() } );\n}\n}", "4822": "@Override\npublic void loadServerGroups(final AsyncCallback<List<ServerGroupRecord>> callback) {\nfinal ModelNode operation = new ModelNode();\noperation.get(OP).set(ModelDescriptionConstants.READ_CHILDREN_NAMES_OPERATION);\noperation.get(\"child-type\").set(\"server-group\");\noperation.get(ModelDescriptionConstants.ADDRESS).setEmptyList();\ndispatcher.execute(new DMRAction(operation), new AsyncCallback<DMRResponse>() {\n            @Override\npublic void onFailure(Throwable caught) {\ncallback.onFailure(caught);\n}\n@Override\npublic void onSuccess(DMRResponse result) {\nModelNode response = ModelNode.fromBase64(result.getResponseText());\nList<ModelNode> payload = response.get(\"result\").asList();\nList<ServerGroupRecord> records = new ArrayList<ServerGroupRecord>(payload.size());\nfor(int i=0; i<payload.size(); i++)\n{\nServerGroupRecord record = factory.serverGroup().as();\nrecord.setGroupName(payload.get(i).asString());\nrecord.setProfileName(payload.get(i).asString());\nrecords.add(record);\n}\ncallback.onSuccess(records);\n}\n        });\n}", "4829": "@Override\npublic void doOnMessage(final Message message) throws Exception {\nLOG.debug(\"Entering \" + getClass());\nLOG.debug(message);\nLoadBalancer queueLb = getLoadbalancerFromMessage(message);\nLoadBalancer dbLoadBalancer;\ntry {\ndbLoadBalancer = loadBalancerService.getWithUserPages(queueLb.getId(), queueLb.getAccountId());\n} catch (EntityNotFoundException enfe) {\nString alertDescription = String.format(\"Load balancer '%d' not found in database.\", queueLb.getId());\nLOG.error(alertDescription, enfe);\nnotificationService.saveAlert(queueLb.getAccountId(), queueLb.getId(), enfe, DATABASE_FAILURE.name(), alertDescription);\nsendErrorToEventResource(queueLb);\nreturn;\n}\ntry {\nif (isRestAdapter()) {\nLOG.debug(\"Creating load balancer in STM...\");\nUserPages up = dbLoadBalancer.getUserPages();\nLoadBalancer lb = new LoadBalancer();\nlb = dbLoadBalancer;\nlb.setUserPages(up);\nreverseProxyLoadBalancerStmService.createLoadBalancer(lb);\nLOG.debug(\"Successfully created a load balancer in STM.\");\n} else {\nLOG.debug(\"Creating load balancer in ZXTM...\");\nreverseProxyLoadBalancerService.createLoadBalancer(dbLoadBalancer);\nLOG.debug(\"Successfully created a load balancer in ZXTM.\");\n}\n} catch (Exception e) {\ndbLoadBalancer.setStatus(ERROR);\nNodesHelper.setNodesToStatus(dbLoadBalancer, OFFLINE);\nloadBalancerService.update(dbLoadBalancer);\nString alertDescription = String.format(\"An error occurred while creating loadbalancer '%d' in STM.\", dbLoadBalancer.getId());\nLOG.error(alertDescription, e);\nnotificationService.saveAlert(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), e, ZEUS_FAILURE.name(), alertDescription);\nsendErrorToEventResource(queueLb);\nloadBalancerStatusHistoryService.save(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), LoadBalancerStatus.ERROR);\n// Notify usage processor\nCalendar usageEventTime = Calendar.getInstance();\ntry {\nusageEventCollection.processZeroUsageEvent(dbLoadBalancer, UsageEvent.CREATE_LOADBALANCER, usageEventTime);\n} catch (UsageEventCollectionException uex) {\nLOG.error(String.format(\"Collection and processing of the usage event failed for load balancer: %s \" +\n\":: Exception: %s\", dbLoadBalancer.getId(), uex));\n}\nreturn;\n}\nCalendar usageEventTime = Calendar.getInstance();\ntry {\n// Notify usage processor\nusageEventCollection.processZeroUsageEvent(dbLoadBalancer, UsageEvent.CREATE_LOADBALANCER, usageEventTime);\n} catch (UsageEventCollectionException uex) {\nLOG.error(String.format(\"Collection and processing of the usage event failed for load balancer: %s \" +\n\":: Exception: %s\", dbLoadBalancer.getId(), uex));\n}\n// Update load balancer in DB\ndbLoadBalancer.setStatus(ACTIVE);\nNodesHelper.setNodesToStatus(dbLoadBalancer, ONLINE);\ndbLoadBalancer.setProvisioned(usageEventTime);\ndbLoadBalancer = loadBalancerService.update(dbLoadBalancer);\n//Set status history record\nloadBalancerStatusHistoryService.save(queueLb.getAccountId(), queueLb.getId(), LoadBalancerStatus.ACTIVE);\naddAtomEntryForLoadBalancer(queueLb, dbLoadBalancer);\naddAtomEntriesForNodes(queueLb, dbLoadBalancer);\naddAtomEntriesForVips(queueLb, dbLoadBalancer);\naddAtomEntryForHealthMonitor(queueLb, dbLoadBalancer);\naddAtomEntryForSessionPersistence(queueLb, dbLoadBalancer);\naddAtomEntryForConnectionLogging(queueLb, dbLoadBalancer);\naddAtomEntryForConnectionLimit(queueLb, dbLoadBalancer);\naddAtomEntriesForAccessList(queueLb, dbLoadBalancer);\nLOG.info(String.format(\"Created load balancer '%d' successfully.\", dbLoadBalancer.getId()));\n}", "4830": "public static void writeProduct(Product product, File file, String formatName, ProgressMonitor pm) {\nWriteOp writeOp = new WriteOp(product, file, formatName);\nProduct outputProduct = writeOp.getTargetProduct();\nDimension defaultTileSize = product.getPreferredTileSize();\nif (defaultTileSize == null) {\ndefaultTileSize = JAI.getDefaultTileSize();\n}\nfinal int rasterHeight = outputProduct.getSceneRasterHeight();\nfinal int rasterWidth = outputProduct.getSceneRasterWidth();\nRectangle productBounds = new Rectangle(rasterWidth, rasterHeight);\nint numXTiles = MathUtils.ceilInt(productBounds.width / (double) defaultTileSize.width);\nint numYTiles = MathUtils.ceilInt(productBounds.height / (double) defaultTileSize.height);\nfinal Band[] bands = outputProduct.getBands();\npm.beginTask(\"Writing product...\", numXTiles * numYTiles * bands.length * 2);\ntry {\nfor (int tileY = 0; tileY < numYTiles; tileY++) {\nfor (int tileX = 0; tileX < numXTiles; tileX++) {\nwriteOp.checkForCancelation(pm);\nRectangle tileRectangle = new Rectangle(tileX* defaultTileSize.width, tileY* defaultTileSize.height, defaultTileSize.width,\n                                                      defaultTileSize.height);\nRectangle intersection = productBounds\n.intersection(tileRectangle);\nfor (Band band : bands) {\nTile tile = writeOp.getSourceTile(band, intersection, SubProgressMonitor.create(pm, 1));\nwriteOp.computeTile(band, tile, SubProgressMonitor.create(pm, 1));\n}\n}\n}\n} finally {\npm.done();\n}\n}", "4834": "private void processViolations()\n{\nCollections.sort( violations, new Comparator()\n{\n            public int compare( Object o1, Object o2 )\n{\nreturn ( (RuleViolation) o1 ).getLine() - ( (RuleViolation) o2 ).getLine();\n}\n        } );\nfor ( Iterator it = violations.iterator(); it.hasNext(); )\n{\nRuleViolation ruleViolation = (RuleViolation) it.next();\nsink.tableRow();\nsink.tableCell();\nsink.text( ruleViolation.getDescription() );\nsink.tableCell_();\nsink.tableCell();\nsink.text( ruleViolation.getLine() );\nsink.tableCell_();\nsink.tableRow_();\n}\nviolations.clear();\n}", "4836": "public void init() throws Exception {\nep.setName(getName());\nep.setHandler(cHandler);\ntry {\nep.init();\nsslImplementation = new JSSEImplementation();\n} catch (Exception ex) {\nlog.error(sm.getString(\"http11protocol.endpoint.initerror\"), ex);\nthrow ex;\n}\nif(log.isInfoEnabled())\nlog.info(sm.getString(\"http11protocol.init\", getName()));\n}", "4837": "@Override\nprotected void registerTask(AbstractNioChannel channel, ChannelFuture future) {\nboolean server =!(channel instanceof NioClientSocketChannel);\nSocketAddress localAddress = channel.getLocalAddress();\nSocketAddress remoteAddress = channel.getRemoteAddress();\nif (localAddress == null || remoteAddress == null) {\nif (future!= null) {\nfuture.setFailure(new ClosedChannelException());\n}\nclose(channel, succeededFuture(channel));\nreturn;\n}\ntry {\nif (server) {\nchannel.getJdkChannel().configureBlocking(false);\n}\nboolean registered = channel.getJdkChannel().isRegistered();\nif (!registered) {\nsynchronized (channel.interestOpsLock) {\nchannel.getJdkChannel().register(\n                            selector, channel.getRawInterestOps(), channel);\n}\n} else {\nsetInterestOps(channel, future, channel.getRawInterestOps());\n}\nif (future!= null) {\n((NioSocketChannel) channel).setConnected();\nfuture.setSuccess();\n}\n} catch (IOException e) {\nif (future!= null) {\nfuture.setFailure(e);\n}\nclose(channel, succeededFuture(channel));\nif (!(e instanceof ClosedChannelException)) {\nthrow new ChannelException(\n                        \"Failed to register a socket to the selector.\", e);\n}\n}\nif (server ||!((NioClientSocketChannel) channel).boundManually) {\nfireChannelBound(channel, localAddress);\n}\nfireChannelConnected(channel, remoteAddress);\n}", "4838": "@Override\nprotected final void doBootstrap(final Context context, final Intent intent)\nthrows WebSMSException {\nLog.d(TAG, \"bootstrap\");\nif (inBootstrap) {\nthrow new WebSMSException(\"Already bootstrapped\");\n}\nif (!Preferences.needBootstrap(context)) {\nLog.d(TAG, \"skip bootstrap\");\nreturn;\n}\ninBootstrap = true;\nStringBuilder packetData = openBuffer(context, \"GET_CUSTOMER\", \"1.10\",\n\t\t\t\tfalse);\nfinal SharedPreferences p = PreferenceManager\n.getDefaultSharedPreferences(context);\nwritePair(packetData, \"email_address\", p.getString(\n\t\t\t\tPreferences.PREFS_MAIL, \"\"));\nwritePair(packetData, \"password\", p.getString(\n\t\t\t\tPreferences.PREFS_PASSWORD, \"\"));\nwritePair(packetData, \"gmx\", \"1\");\nthis.sendData(context, closeBuffer(packetData));\n}", "4841": "private static synchronized LocalMetadataRepository getLocalMetadataRepository(MavenContext context,\n            LocalRepositoryP2Indices localRepoIndices) {\nif (localMetadataRepository == null) {\nFile localMavenRepoRoot = context.getLocalRepositoryRoot();\nRepositoryReader contentLocator = new LocalRepositoryReader(localMavenRepoRoot);\nlocalMetadataRepository = new LocalMetadataRepository(localMavenRepoRoot.toURI(),\n                    localRepoIndices.getMetadataIndex(), contentLocator);\nString localArtifactHandling = context.getSessionProperties().getProperty(\"tycho.localArtifacts\");\nif (\"ignore\".equalsIgnoreCase(localArtifactHandling)) {\ncontext.getLogger().debug(\n                        \"tycho.localArtifacts=\" + localArtifactHandling + \" -> ignoring locally built artifacts\");\nlocalMetadataRepository.setIncludeInTargetPlatform(false);\n}\n}\nreturn localMetadataRepository;\n}", "4850": "@Override\npublic void forEach(IntProcedure proc, int from, int to) throws ContradictionException {\nto = Math.min(to, rem.length);\nfor (int i = from; i < to; i++) {\nproc.execute(rem[i]);\n}\n}", "4851": "private void dialogChanged()\n{\n// Name\nif ( nameText.getText().equals( \"\" ) )\n{\ndisplayErrorMessage( \"A name must be specified.\" );\nreturn;\n}\nif (!nameText.getText().equals( projectNameText.getText() ) )\n{\ndisplayErrorMessage( \"A name must be specified. The existing project name is already used.\" );\nreturn;\n}\ndisplayErrorMessage( null );\n}", "4856": "@Command(\n        aliases = { \"cs\" },\n        usage = \"<filename> [args...]\",\n        desc = \"Execute a CraftScript\",\n        min = 1,\n        max = -1\n    )\n@CommandPermissions(\"worldedit.scripting.execute\")\n@Logging(ALL)\npublic static void execute(CommandContext args, WorldEdit we,\n            LocalSession session, LocalPlayer player, EditSession editSession)\nthrows WorldEditException {\nString[] scriptArgs = args.getSlice(1);\nsession.setLastScript(args.getString(0));\nFile dir = we.getWorkingDirectoryFile(we.getConfiguration().scriptsDir);\nFile f = we.getSafeOpenFile(player, dir, args.getString(0), \"js\",\n                new String[] {\"js\"});\nwe.runScript(player, f, scriptArgs);\n}", "4857": "public void deleteTag(long[] factIds, String tag)\n{\nAnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deckPath);\nArrayList<String> factTagsList = factTags(factIds);\nlong tagId = tagId(tag, false);\nfor(int i = 0; i < factTagsList.size(); i++)\n{\nString factTags = factTagsList.get(i);\nString newTags = factTags;\nint tagIdx = factTags.indexOf(tag);\nif ((tagIdx == 0) && (factTags.length() > tag.length())) {\n// tag is the first element of many, remove \"tag,\"\nnewTags = factTags.substring(tag.length() + 1, factTags.length());\n} else if ((tagIdx > 0) && (tagIdx + tag.length() == factTags.length())) {\n// tag is the last of many elements, remove \",tag\"\nnewTags = factTags.substring(0, tagIdx - 1);\n} else if (tagIdx > 0) {\n// tag is enclosed between other elements, remove \",tag\"\nnewTags = factTags.substring(0, tagIdx -1) + factTags.substring(tag.length(), factTags.length());\n} else if (tagIdx == 0) {\n// tag is the only element\nnewTags = \"\";\n}\nLog.i(TAG, \"old tags = \" + factTags);\nLog.i(TAG, \"new tags = \" + newTags);\nif (newTags.length() < factTags.length()) {\nankiDB.database.execSQL(\n\t\t\t\t\t\t\"update facts set \" +\n\"tags = \\\"\" + newTags + \"\\\", \" +\n\"modified = \" + String.format(ENGLISH_LOCALE, \"%f\", (double) (System.currentTimeMillis() / 1000.0)) +\n\" where id = \" + factIds[i]);\n}\n}\nArrayList<String> cardIdList = ankiDB.queryColumn(\n\t\t\t\tString.class, \n\t\t\t\t\"select id from cards where factId in \" + Utils.ids2str(factIds), \n\t\t\t\t0);\nfor (int i = 0; i < cardIdList.size(); i++)\n{\nString cardId = cardIdList.get(i);\nankiDB.database.execSQL(\"delete from cardTags\" +\n\" WHERE cardId = \" + cardId +\n\" and tagId = \" + tagId +\n\" and src = 0\");\n}\nfor (int i = 0; i < factIds.length; i++) {\nlong factId = factIds[i];\nankiDB.database.execSQL(\"delete from facts\" +\n\" WHERE id = \" + factId +\n\" and tagId = \" + tagId +\n\" and src = 0\");\n}\nflushMod();\n}", "4862": "private static void matchSubElements(ModelNode descriptionModel, List<String> fieldNames, SafeHtmlBuilder html) {\nif(fieldNames.isEmpty()) return; // nothing left todo\nif (descriptionModel.hasDefined(RESULT))\ndescriptionModel = descriptionModel.get(RESULT).asObject();\ntry {\n// visit child elements\nif (descriptionModel.hasDefined(\"children\")) {\nList<Property> children = descriptionModel.get(\"children\").asPropertyList();\nfor(Property child : children )\n{\nModelNode childDesc = child.getValue();\nfor (Property modDescProp : childDesc.get(MODEL_DESCRIPTION).asPropertyList()) {\nmatchSubElements(childDesc.get(MODEL_DESCRIPTION, modDescProp.getName()), fieldNames, html);\n}\n}\n}\n// match attributes\nif(descriptionModel.hasDefined(ATTRIBUTES))\n{\nList<Property> elements = descriptionModel.get(ATTRIBUTES).asPropertyList();\nfor(Property element : elements)\n{\nString childName = element.getName();\nModelNode value = element.getValue();\nif(fieldNames.contains(childName))\n{\n// make sure it's not processed twice\nfieldNames.remove(childName);\nhtml.appendHtmlConstant(\"<tr class='help-field-row'>\");\nhtml.appendHtmlConstant(\"<td class='help-field-name'>\");\nhtml.appendEscaped(childName).appendEscaped(\": \");\nhtml.appendHtmlConstant(\"</td>\");\nhtml.appendHtmlConstant(\"<td class='help-field-desc'>\");\nhtml.appendEscaped(value.get(\"description\").asString());\nhtml.appendHtmlConstant(\"</td>\");\nhtml.appendHtmlConstant(\"</tr>\");\n}\n}\n}\n} catch (IllegalArgumentException e) {\nLog.error(\"Failed to read help descriptionModel\", e);\n}\n}", "4864": "public void doStatistics(final StaplerRequest request, final StaplerResponse response, final AnnotationContainer container) throws IOException {\nString parameter = request.getParameter(\"object\");\nif (parameter.startsWith(\"category.\")) {\nSet<FileAnnotation> annotations = container.getCategory(StringUtils.substringAfter(parameter, \"category.\"));\nrenderPriorititesChart(request, response, new DefaultAnnotationContainer(annotations), container.getAnnotationBound());\n}\nelse if (parameter.startsWith(\"type.\")) {\nSet<FileAnnotation> annotations = container.getType(StringUtils.substringAfter(parameter, \"type.\"));\nrenderPriorititesChart(request, response, new DefaultAnnotationContainer(annotations), container.getAnnotationBound());\n}\nelse if (parameter.startsWith(\"file.\")) {\nAnnotationContainer annotations = container.getFile(Integer.valueOf(StringUtils.substringAfter(parameter, \"file.\")));\nrenderPriorititesChart(request, response, annotations, container.getAnnotationBound());\n}\nelse if (parameter.startsWith(\"package.\")) {\nAnnotationContainer annotations = container.getPackage(StringUtils.substringAfter(parameter, \"package.\"));\nrenderPriorititesChart(request, response, annotations, container.getAnnotationBound());\n}\nelse if (parameter.startsWith(\"module.\")) {\nString moduleName = StringUtils.substringAfter(parameter, \"module.\");\nAnnotationProvider annotations;\nif (container.containsModule(moduleName)) {\nannotations = container.getModule(moduleName);\n}\nelse {\nannotations = new DefaultAnnotationContainer();\n}\nrenderPriorititesChart(request, response, annotations, container.getAnnotationBound());\n}\n}", "4866": "private static void validateCompositeTemplate(final ClusterState state,\n                                                  final String templateName,\n                                                  final ComposableIndexTemplate template,\n                                                  final IndicesService indicesService,\n                                                  final NamedXContentRegistry xContentRegistry) throws Exception {\nfinal ClusterState stateWithTemplate = ClusterState.builder(state)\n.metadata(Metadata.builder(state.metadata()).put(templateName, template))\n.build();\nfinal String temporaryIndexName = \"validate-template-\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\nSettings resolvedSettings = resolveSettings(stateWithTemplate.metadata(), templateName);\n// use the provided values, otherwise just pick valid dummy values\nint dummyPartitionSize = IndexMetadata.INDEX_ROUTING_PARTITION_SIZE_SETTING.get(resolvedSettings);\nint dummyShards = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS,\n            dummyPartitionSize == 1? 1 : dummyPartitionSize + 1);\nint shardReplicas = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n// Create the final aggregate settings, which will be used to create the temporary index metadata to validate everything\nSettings finalResolvedSettings = Settings.builder()\n.put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n.put(resolvedSettings)\n.put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, dummyShards)\n.put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, shardReplicas)\n.put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n.build();\n// Validate index metadata (settings)\nfinal ClusterState stateWithIndex = ClusterState.builder(stateWithTemplate)\n.metadata(Metadata.builder(stateWithTemplate.metadata())\n.put(IndexMetadata.builder(temporaryIndexName).settings(finalResolvedSettings))\n.build())\n.build();\nfinal IndexMetadata tmpIndexMetadata = stateWithIndex.metadata().index(temporaryIndexName);\nindicesService.withTempIndexService(tmpIndexMetadata,\n            tempIndexService -> {\n// Validate aliases\nMetadataCreateIndexService.resolveAndValidateAliases(temporaryIndexName, Collections.emptySet(),\n                    MetadataIndexTemplateService.resolveAliases(stateWithIndex.metadata(), templateName), stateWithIndex.metadata(),\n                    new AliasValidator(),\n                    // the context is only used for validation so it's fine to pass fake values for the\n// shard id and the current timestamp\nxContentRegistry, tempIndexService.newQueryShardContext(0, null, () -> 0L, null));\n// Parse mappings to ensure they are valid after being composed\nList<CompressedXContent> mappings = resolveMappings(stateWithIndex, templateName);\ntry {\nMap<String, Object> finalMappings = MetadataCreateIndexService.parseV2Mappings(\"{}\", mappings, xContentRegistry);\nMapperService dummyMapperService = tempIndexService.mapperService();\nif (finalMappings.isEmpty() == false) {\nassert finalMappings.size() == 1 : finalMappings;\ndummyMapperService.merge(MapperService.SINGLE_MAPPING_NAME, mapping, MergeReason.INDEX_TEMPLATE);\nfinalMappings.put(MapperService.SINGLE_MAPPING_NAME, finalMappings, MergeReason.MAPPING_UPDATE);\n}\nif (template.getDataStreamTemplate()!= null) {\nString tsFieldName = template.getDataStreamTemplate().getTimestampField();\nvalidateTimestampFieldMapping(tsFieldName, dummyMapperService);\n}\n} catch (Exception e) {\nthrow new IllegalArgumentException(\"invalid composite mappings for [\" + templateName + \"]\", e);\n}\nreturn null;\n});\n}", "4867": "public void createDropDown(DropDownPreference preference) {\nfinal DropDownPreference simPref = preference;\nfinal String keyPref = simPref.getKey();\nfinal boolean askFirst = keyPref.equals(KEY_CALLS) || keyPref.equals(KEY_SMS);\nsimPref.clearItems();\nif (askFirst) {\nsimPref.addItem(getResources().getString(\n                    R.string.sim_calls_ask_first_prefs_title), null);\n}\nfinal int subAvailableSize = mAvailableSubInfos.size();\nfor (int i = 0; i < subAvailableSize; ++i) {\nfinal SubInfoRecord sir = mAvailableSubInfos.get(i);\nif(sir!= null){\nsimPref.addItem(sir.mDisplayName, sir);\n}\n}\nsimPref.setCallback(new DropDownPreference.Callback() {\n            @Override\npublic boolean onItemSelected(int pos, Object value) {\nfinal long subId = value == null? 0 : ((SubInfoRecord)value).mSubId;\nif (simPref.getKey().equals(KEY_CELLULAR_DATA)) {\nSubscriptionManager.setDefaultDataSubId(subId);\n} else if (simPref.getKey().equals(KEY_CALLS)) {\nSubscriptionManager.setDefaultVoiceSubId(subId);\n} else if (simPref.getKey().equals(KEY_SMS)) {\nSubscriptionManager.setDefaultSMSSubId(subId);\n}\nreturn true;\n}\n        });\n}", "4870": "private void addHeader(LayoutContainer container) {\nLayoutContainer header = new LayoutContainer() {\n            {\nsetId(\"st-header\");\naddText(\"Sonatype Nexus\").setId(\"st-logo\");\n}\n        };\nLayoutContainer rightSide = new LayoutContainer() {\n            {\nsetId(\"st-right-side\");\n}\n        };\nusername = new Text() {\n            {\nsetTagName(\"span\");\nsetId(\"st-username\");\n}\n        };\nloginLink = new Text() {\n            {\nsetTagName(\"span\");\nsetId(\"st-login-link\");\nExt.get('login-link').on('click', Sonatype.repoServer.RepoServer.loginHandler, Sonatype.repoServer.RepoServer);\n}\n        };\nversion = new Text() {\n            {\nsetId(\"st-version\");\n}\n        };\nrightSide.add(username);\nrightSide.add(loginLink);\nrightSide.add(version);\nheader.add(rightSide);\nBorderLayoutData headerLayoutData = new BorderLayoutData(LayoutRegion.NORTH) {\n            {\nsetMargins(new Margins(5, 5, 5, 5));\nsetSize(30);\n}\n        };\ncontainer.add(header, headerLayoutData);\ngetServerVersion();\nupdateLoginStatus();\n}", "4871": "private void renderElement( Element ce, StringBuffer sb )\n{\nString endEl = \"\";\nfor( int i = 0; i < ELEMENTS.length; i+=3 )\n{\nif( ELEMENTS[i].equals(ce.getName()) )\n{\nsb.append( ELEMENTS[i+1] );\nendEl = ELEMENTS[i+2];\n}\n}\nif( UL.equals(ce.getName()) )\n{\nm_listCount++;\nm_listChar = '*';\n}\nelse if( OL.equals(ce.getName()) )\n{\nm_listCount++;\nm_listChar = '#';\n}\nelse if( LI.equals(ce.getName()) )\n{\nfor(int i = 0; i < m_listCount; i++ ) sb.append( m_listChar );\nsb.append(\" \");\n}\nelse if( A.equals(ce.getName()) )\n{\nString href = ce.getAttributeValue(\"href\");\nString text = ce.getText();\nif( href.equals(text) )\n{\nsb.append(\"[[\"+href+\"]]\");\n}\nelse\n            {\nsb.append(\"[[\"+href+\"|\"+text+\"]]\");\n}\n// Do not render anything else \nreturn;\n}\nelse if( PRE.equals(ce.getName()) )\n{\nsb.append(\"{{{\");\nsb.append( ce.getText() );\nsb.append(\"}}}\");\nreturn;\n}\n//\n//  Go through the children\n//\nfor( Iterator i = ce.getContent().iterator(); i.hasNext(); )\n{\nContent c = (Content)i.next();\nif( c instanceof PluginContent )\n{\nPluginContent pc = (PluginContent)c;\nint idx = 1;\nsb.append( \"<<\"+pc.getPluginName()+\" \"+idx+\">>\" );\n}\nelse if( c instanceof Text )\n{\nsb.append( ((Text)c).getText() );\n}\nelse if( c instanceof Element )\n{\nrenderElement( (Element)c, sb );\n}\n}\nif( UL.equals(ce.getName()) || OL.equals(ce.getName()) )\n{\nm_listCount--;\n}\nelse if( P.equals(ce.getName()) )\n{\nsb.append(\"\\n\");\n}\nsb.append(endEl);\n}", "4876": "@Override\npublic void onScanWifiDppSuccess(String publicKey, String information) {\nif (mWifiDppManager!= null) {\nmWifiDppManager.onScanWifiDppSuccess(publicKey, information);\n}\n}", "4878": "@Override\npublic void saveTransportReceipt(TransmissionEvidence transportReceipt) {\nlog.info(\"Saving the transport receipt.\");\n// TODO: implement the persistence of the TransmissionEvidence\nlog.warn(\"TRANSPORT RECEIPT PERSISTENCE NOT IMPLEMENTED YET!\");\n}", "4879": "private void checkChunkUpdates(Point currentPosition) {\n// Recalculating these\npriorityChunkSendQueue.clear();\nchunkSendQueue.clear();\nchunkFreeQueue.clear();\nchunkInitQueue.clear();\nWorld world = currentPosition.getWorld();\nint bx = (int) currentPosition.getX();\nint by = (int) currentPosition.getY();\nint bz = (int) currentPosition.getZ();\nPoint playerChunkBase = Chunk.pointToBase(currentPosition);\nfor (Point p : initializedChunks) {\nif (p.getManhattanDistance(playerChunkBase) > blockViewDistance) {\nchunkFreeQueue.add(p);\n}\n}\nint cx = bx >> Chunk.CHUNK_SIZE_BITS;\nint cy = by >> Chunk.CHUNK_SIZE_BITS;\nint cz = bz >> Chunk.CHUNK_SIZE_BITS;\nfor (int x = cx - viewDistance; x < cx + viewDistance; x++) {\nfor (int y = cy - viewDistance; y < cy + viewDistance; y++) {\nfor (int z = cz - viewDistance; z < cz + viewDistance; z++) {\nPoint base = new Point(world, x << Chunk.CHUNK_SIZE_BITS, y << Chunk.CHUNK_SIZE_BITS, z << Chunk.CHUNK_SIZE_BITS);\ndouble distance = base.getManhattanDistance(playerChunkBase);\nif (distance <= blockViewDistance) {\nif (!activeChunks.contains(base)) {\nif (distance <= targetSize) {\npriorityChunkSendQueue.add(base);\n} else {\nchunkSendQueue.add(base);\n}\n}\nif (!initializedChunks.contains(base)) {\nchunkInitQueue.add(base);\n}\n}\n}\n}\n}\n}", "4883": "@Test\npublic void testRemoveJpaEntityWithMongoDocument() {\nTransactionTemplate txTemplate = new TransactionTemplate(transactionManager);\ntxTemplate.execute(new TransactionCallback<Person>() {\n      public Person doInTransaction(TransactionStatus status) {\nPerson p2 = new Person(\"Thomas\", 20);\nResume r2 = new Resume();\nr2.addEducation(\"Skanstulls High School, 1975\");\nr2.addJob(\"DiMark, DBA, 1990-2000\");\np2.setResume(r2);\np2.setId(2L);\nentityManager.persist(p2);\nPerson p3 = new Person(\"Thomas\", 20);\nResume r3 = new Resume();\nr3.addEducation(\"Univ. of Stockholm, 1980\");\nr3.addJob(\"VMware, Developer, 2007-\");\np3.setResume(r3);\np3.setId(3L);\nentityManager.persist(p3);\nreturn null;\n}\n    });\ntxTemplate.execute(new TransactionCallback<Person>() {\n      public Person doInTransaction(TransactionStatus status) {\nfinal Person found2 = entityManager.find(Person.class, 2L);\nfinal Person found3 = entityManager.find(Person.class, 3L);\nentityManager.remove(found2);\nreturn null;\n}\n    });\nfinal Person found2 = entityManager.find(Person.class, 2L);\nfinal Person found3 = entityManager.find(Person.class, 3L);\nassertThat(found2).isNull();\nassertThat(found3).isNull();\n}", "4885": "@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\nsuper.onActivityResult(requestCode, resultCode, data);\nif (requestCode == Apg.ENCRYPT_MESSAGE\n|| requestCode == Apg.SELECT_PUBLIC_KEYS\n|| requestCode == Apg.SELECT_SECRET_KEY)\n{\nApg apg = Apg.getInstance();\napg.onActivityResult(this, requestCode, resultCode, data);\nString encryptedData = apg.getEncryptedData();\n} else if(requestCode == RESULT_ID_TAGGER) {\nif(resultCode == Activity.RESULT_OK) {\nString ir = data.getStringExtra(\"imageRegion\");\n// loop through image regions to find the matching image region, and set its subject\n// is this sloppy?  i don't know!!!  other suggestions welcome :)\nfor(ImageRegion m : imageRegions) {\nif(ir.compareTo(m.toString()) == 0) {\nm.addSubjectId(data.getStringExtra(\"addedSubject\"), Integer.parseInt(data.getStringExtra(\"subjectConsent\")));\n}\n}\nmdh.registerSubject(data.getStringExtra(\"addedSubject\"),\n\t\t\t\t\t\tInteger.parseInt(data.getStringExtra(\"subjectConsent\")),\n\t\t\t\t\t\tnull, mdh.getImageRegionResource(), data.getStringExtra(\"imageRegion\"));\n}\n} else if(requestCode == RESULT_ENCRYPT_TAGGER) {\nif(resultCode == Activity.RESULT_OK) {\nApg apg = Apg.getInstance();\napg.onActivityResult(this, requestCode, resultCode, data);\nString encryptedData = apg.getEncryptedData();\napg.decrypt(encryptedData);\n}\n}\n}", "4889": "@Test\npublic void testDisplayQuotePMPage() throws NotFoundException {\nPrivateMessage pm = new PrivateMessage();\nwhen(pmService.get(PM_ID)).thenReturn(pm);\nwhen(pmDtoBuilder.getQuoteDtoFor(pm)).thenReturn(pmDto);\nModelAndView mav = controller.displayQuotePMPage(PM_ID);\nverify(pmService).get(PM_ID);\nverify(pmDtoBuilder).getQuoteDtoFor(pm);\nassertViewName(mav, \"pm/pmForm\");\nassertAndReturnModelAttributeOfType(mav, \"privateMessageDto\", PrivateMessageDto.class);\n}", "4891": "private void addKeyInfo(final int codePoint, final Keyboard keyboard) {\nfor (final Key key : keyboard.mKeys) {\nif (key.mCode == codePoint) {\nfinal int x = key.mX + key.mWidth / 2;\nfinal int y = key.mY + key.mHeight / 2;\nadd(codePoint, new int[] { key.mCode }, x, y);\nreturn;\n}\n}\nadd(codePoint, new int[] { codePoint },\n                WordComposer.NOT_A_COORDINATE, WordComposer.NOT_A_COORDINATE);\n}", "4892": "public void actionPerformed(ActionEvent e) {\nif (jcpPanel.getEmptyFrameWithModel()!= null) {\njcpPanel.getEmptyFrameWithModel().show();\n}\n}", "4894": "@VisibleForTesting\nvoid appendUriPath(HttpRequest request, StringBuilder toSign) {\ntoSign.append(request.getEndpoint().getRawPath());\n//...however, there are a few exceptions that must be included in the signed URI.\nif (request.getEndpoint().getQuery()!= null) {\nStringBuilder paramsToSign = new StringBuilder(\"?\");\nString[] params = request.getEndpoint().getQuery().split(\"&\");\nfor (String param : params) {\nString[] paramNameAndValue = param.split(\"=\");\nif (\"acl\".equals(paramNameAndValue[0])) {\nparamsToSign.append(\"acl\");\n}\nrequest.getEndpoint().getQuery().replaceAll(param, \"\");\n}\nif (paramsToSign.length() > 1) {\ntoSign.append(paramsToSign);\n}\n}\n}", "4901": "protected void addDefaultConverters() {\naddConverter(new StringToByte());\naddConverter(new StringToBoolean());\naddConverter(new StringToCharacter());\naddConverter(new StringToShort());\naddConverter(new StringToInteger());\naddConverter(new StringToLong());\naddConverter(new StringToFloat());\naddConverter(new StringToDouble());\naddConverter(new StringToBigInteger());\naddConverter(new StringToBigDecimal());\naddConverter(new StringToLocale());\naddConverter(new StringToEnum());\naddConverter(new NumberToNumber());\naddConverter(new ObjectToCollection(this));\naddConverter(new CollectionToCollection(this));\n}", "4904": "public void registerNodes() {\nPluginPreferenceToolFinder toolFinder = PluginPreferenceToolFinder\n.getInstance();\nIPreferenceStore store = GenericNodesPlugin.getDefault()\n.getPreferenceStore();\nPluginPreferenceToolFinder.getInstance().init(store);\nString knimelessPackageName = getKNIMELessPackageName();\nfor (String nodeName : this.getNodeNames()) {\ntoolFinder.registerTool(new ExternalTool(knimelessPackageName,\n\t\t\t\t\tnodeName));\n}\n// registerExtractedBinaries\nregisterExtractedBinaries();\n}", "4905": "@Override\npublic void start() {\nint release = getContext().getRelease().getReleaseNumber();\ntry {\nFile base = new File(\"./data/fs/\" + release + \"/\");\nfor (int i = 0; i < THREADS_PER_REQUEST_TYPE; i++) {\nworkers.add(new JagGrabRequestWorker(dispatcher, new IndexedFileSystem(base, true)));\nworkers.add(new OnDemandRequestWorker(dispatcher, new IndexedFileSystem(base, true)));\nworkers.add(new HttpRequestWorker(dispatcher, new IndexedFileSystem(base, true)));\n}\nfor (RequestWorker<?,?> worker : workers) {\nservice.submit(worker);\n}\n} catch (Exception ex) {\nthrow new RuntimeException(ex);\n}\n}", "4907": "@SuppressWarnings(\"unchecked\")\npublic void notify(T event)\n{\nAbstractBean<Object> baseComponent = (AbstractBean<Object>) bean;\nAbstractBean<Object> specializedComponent = null;\nObject object = null;\ntry\n        {\nBeanManagerImpl manager = ActivityManager.getInstance().getCurrentActivity();\nspecializedComponent = (AbstractBean<Object>)WebBeansUtil.getMostSpecializedBean(manager, baseComponent);\nContext context = manager.getContext(specializedComponent.getScopeType());\nif(this.ifExist)\n{\nobject = context.get(specializedComponent);\n}\nelse\n            {\nobject = manager.getInstance(specializedComponent);\n}\nif (this.ifExist && object == null)\n{\nreturn;\n}\nif (object!= null)\n{\nObject[] args = null;\nList<Object> argsObjects = getMethodArguments(event);\nargs = new Object[argsObjects.size()];\nargs = argsObjects.toArray(args);\nif (!this.observerMethod.isAccessible())\n{\nthis.observerMethod.setAccessible(true);\n}\n//Static or not\nif (Modifier.isStatic(this.observerMethod.getModifiers()))\n{\nobject = null;\n}\n//Invoke Method\nthis.observerMethod.invoke(object, args);\n}\n}\ncatch (Exception e)\n{\nif (!getType().equals(TransactionalObserverType.NONE))\n{\nlogger.error(\"Error is occured while notifying observer in class : \" + observerMethod.getDeclaringClass().getName() + \" in method : \" + observerMethod.getName(), e);\n}\nelse\n            {\nthrow new WebBeansException(e.getCause());\n}\n}\nfinally\n        {\nif (baseComponent.getScopeType().equals(Dependent.class))\n{\nbaseComponent.destroy(object,null);\n}\n}\n}", "4908": "public void testOpenWithNonWritableFile() throws Exception {\nwriter = new FlatFileItemWriter<String>();\nwriter.setFieldSetCreator(new PassThroughFieldSetCreator<String>());\nFileSystemResource file = new FileSystemResource(\"target/no-such-file.foo\");\nwriter.setResource(file);\nnew File(file.getFile().getParent()).mkdirs();\nfile.getFile().createNewFile();\nAssert.state(file.exists(), \"Test file must exist\");\nAssert.state(file.getFile().setReadOnly(), \"Test file set to read-only\");\nwriter.afterPropertiesSet();\ntry {\nwriter.open(executionContext);\nfail(\"Expected IllegalStateException\");\n}\ncatch (IllegalStateException e) {\nString message = e.getMessage();\nassertTrue(\"Message does not contain 'writable': \" + message, message.indexOf(\"writable\") >= 0);\n}\n}", "4910": "@Override\npublic void addFieldWithTokenStreamData(LuceneFieldContext context) {\nGenericRecord field = createNormalField( \"TokenStreamField\", context );\nfield.put( \"value\", context.getTokenStream().getStream() );\nSerializableTermVector termVector = context.getTermVector();\nbyte[] data = SerializationHelper.toByteArray( termVector );\nfield.put( \"termVector\", ByteBuffer.wrap( data ) );\nfieldables.add( field );\n}", "4918": "private void restoreApplicationData() {\nSharedPreferences settings = mContext.getSharedPreferences(OPP_PREFERENCE_FILE, 0);\nmSendingFlag = settings.getBoolean(SENDING_FLAG, false);\nmMimeTypeOfSendigFile = settings.getString(MIME_TYPE, null);\nmUriOfSendingFile = settings.getString(FILE_URI, null);\nmMimeTypeOfSendigFiles = settings.getString(MIME_TYPE_MULTIPLE, null);\nmMultipleFlag = settings.getBoolean(MULTIPLE_FLAG, false);\nif (V) Log.v(TAG, \"restoreApplicationData! \" + mSendingFlag + mMultipleFlag\n+ mMimeTypeOfSendigFile + mUriOfSendingFile);\nString strUris = settings.getString(FILE_URIS, null);\nmUrisOfSendingFiles = strUris;\n}", "4919": "public static void main(String[] args)\n{\nif (args.length < 1)\n{\nSystem.out.println(\n                \"You must specify a comma-delimited list of paths to search \" +\n\"for unit tests\");\nSystem.exit(0);\n}\ninitializeLogging(args);\ninitializeManager(args);\n// end : added - 11 July 2001\nlogprop(\"java.version\");\nlogprop(\"java.vendor\");\nlogprop(\"java.home\");\nlogprop(\"user.home\");\nlogprop(\"user.dir\");\nlogprop(\"os.name\");\nlogprop(\"os.version\");\nlogprop(\"os.arch\");\nlogprop(\"java.class.version\");\nlogprop(\"java.class.path\");\nString cp = System.getProperty(\"java.class.path\");\nString cpe[]= JMeterUtils.split(cp,\";\",\"\");\nStringBuffer sb = new StringBuffer(3000);\nfor (int i=0;i<cpe.length;i++){\nsb.append(cpe[i]);\nsb.append(\"\\n\");\n}\nlog.info(sb.toString());\n//++\n// GUI tests throw the error \n// testArgumentCreation(org.apache.jmeter.config.gui.ArgumentsPanel$Test)java.lang.NoClassDefFoundError\n// \tat java.lang.Class.forName0(Native Method)\n// \tat java.lang.Class.forName(Class.java:141)\n// \tat java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment(GraphicsEnvironment.java:62)\n//\n//  Try to find out why this is...\nString e = \"java.awt.headless\";\nString g=\"java.awt.graphicsenv\";\nSystem.out.println(\"+++++++++++\");\nSystem.out.println(e+\"=\"+System.getProperty(e));\nString n=System.getProperty(g);\nSystem.out.println(g+\"=\"+n);\n//\n//\t\ttry {//\n//\t\t\tClass c = Class.forName(n);\n//\t\t\tSystem.out.println(\"Found class:  \"+n);\n////\t\t\tc.newInstance();\n////\t\t\tSystem.out.println(\"Instantiated: \"+n);\n//\t\t} catch (Exception e1) {\n//\t\t\tSystem.out.println(\"Error finding class \"+n+\" \"+e1);\n//\t\t} catch (java.lang.InternalError e1){\n//\t\t\tSystem.out.println(\"Error finding class \"+n+\" \"+e1);\n//\t\t}\n//\nSystem.out.println(\"------------\");\n// don't call isHeadless() here, as it has a side effect.\n//--\nSystem.out.println(\"Creating test suite\");\nTestSuite suite = suite(args[0]);\nSystem.out.println(\"Starting test run\");\n// Jeremy Arnold: This method used to attempt to write results to\n// a file, but it had a bug and instead just wrote to System.out.\n// Since nobody has complained about this behavior, I'm changing\n// the code to not attempt to write to a file, so it will continue\n// behaving as it did before.  It would be simple to make it write\n// to a file instead if that is the desired behavior.\nTestRunner.run(suite);\n//++\n//      Recheck settings:\nSystem.out.println(\"+++++++++++\");\n//\t\tSystem.out.println(e+\"=\"+System.getProperty(e));\n//\t\tSystem.out.println(g+\"=\"+System.getProperty(g));\n//\t\tSystem.out.println(\"Headless? \"+java.awt.GraphicsEnvironment.isHeadless());//JDK 1.4\n//\t\ttry {\n//\t\t\tClass c = Class.forName(n);\n//\t\t\tSystem.out.println(\"Found class:  \"+n);\n//\t\t\tc.newInstance();\n//\t\t\tSystem.out.println(\"Instantiated: \"+n);\n//\t\t} catch (Exception e1) {\n//\t\t\tSystem.out.println(\"Error with class \"+n+\" \"+e1);\n//\t\t} catch (java.lang.InternalError e1){\n//\t\t    System.out.println(\"Error with class \"+n+\" \"+e1);\n//\t\t}\n//\nSystem.out.println(\"------------\");\n// don't call isHeadless", "4922": "@Inject\npublic void init() {\nIdentityConfigurationBuilder builder;\nif (!identityConfigInstance.isUnsatisfied()) {\nIdentityConfiguration identityConfiguration = identityConfigInstance.get();\nbuilder = new IdentityConfigurationBuilder(Arrays.asList(identityConfiguration));\n} else if (identityConfigInstance.isAmbiguous()) {\nthrow new SecurityConfigurationException(\"Multiple IdentityConfiguration beans found, can not \"\n+ \"configure IdentityManagerFactory\");\n} else {\nbuilder = new IdentityConfigurationBuilder();\n}\nthis.identityConfigEvent.fire(new IdentityConfigurationEvent(builder));\nthis.factory = new DefaultPartitionManager(builder.build());\n}", "4926": "private static List<IBrixTab> getTabs(final IModel<BrixNode> nodeModel)\n{\nList<IBrixTab> tabs = new ArrayList<IBrixTab>();\ntabs.add(new CachingAbstractTab(new Model<String>(\"View\"))\n{\n\n            @Override\npublic Panel newPanel(String panelId)\n{\nreturn new ViewTab(panelId, nodeModel);\n}\n@Override\npublic boolean isVisible()\n{\nreturn hasViewPermission(nodeModel);\n}\n\n        });\ntabs.add(new CachingAbstractTab(new Model<String>(\"Tiles\"))\n{\n\n            @Override\npublic Panel newPanel(String panelId)\n{\nreturn new TilesPanel(panelId, nodeModel);\n}\n@Override\npublic boolean isVisible()\n{\nreturn hasEditPermission(nodeModel);\n}\n\n        });\ntabs.add(new CachingAbstractTab(new Model<String>(\"Variables\"))\n{\n\n            @Override\npublic Panel newPanel(String panelId)\n{\nreturn new VariablesPanel(panelId, nodeModel);\n}\n@Override\npublic boolean isVisible()\n{\nreturn hasEditPermission(nodeModel);\n}\n\n        });\nreturn tabs;\n}", "4927": "public void produce( final DataConsumer pReceiver ) throws IOException {\nInputStream is = new BufferedInputStream(new FileInputStream(archive));\nCompressorInputStream compressorInputStream = null;\ntry {\nfinal String fn = archive.getName();\nif (fn.endsWith(\"gz\")) {\ncompressorInputStream = new CompressorStreamFactory().createCompressorInputStream(\"gz\", is);\n} else if (fn.endsWith(\"bz2\")){\ncompressorInputStream = new CompressorStreamFactory().createCompressorInputStream(\"bzip2\", is);\n}\ncompressorInputStream = new CompressorStreamFactory().createCompressorInputStream(is);\n} catch(CompressorException e) {\n}\nif (compressorInputStream!= null) {\nis = new BufferedInputStream(compressorInputStream);\n}\nArchiveInputStream archiveInputStream = null;\ntry {\narchiveInputStream = new ArchiveStreamFactory().createArchiveInputStream(is);\n} catch(ArchiveException e) {\nthrow new IOException(\"Unsupported archive format : \" + archive, e);\n}\nEntryConverter converter = null;\nif (archiveInputStream instanceof TarArchiveInputStream) {\nconverter = new EntryConverter() {\n    \t        public TarEntry convert(ArchiveEntry entry) {\nTarArchiveEntry src = (TarArchiveEntry)entry;\nTarEntry dst = new TarEntry(src.getName());\ndst.setSize(src.getSize());\ndst.setGroupName(src.getGroupName());\ndst.setGroupId(src.getGroupId());\ndst.setUserId(src.getUserId());\ndst.setMode(src.getMode());\ndst.setModTime(src.getModTime());\nreturn dst;\n}\n            };\n} else if (archiveInputStream instanceof ZipArchiveInputStream) {\nconverter = new EntryConverter() {\n    \t        public TarEntry convert(ArchiveEntry entry) {\nZipArchiveEntry src = (ZipArchiveEntry)entry;\nTarEntry dst = new TarEntry(src.getName());\ndst.setSize(src.getSize());\ndst.setMode(src.getUnixMode());\ndst.setModTime(src.getTime());\nreturn dst;\n}\n            };\n} else {\nthrow new IOException(\"Unsupported archive format : \" + archive);\n}\ntry {\nwhile(true) {\nArchiveEntry archiveEntry = archiveInputStream.getNextEntry();\nif (archiveEntry == null) {\nbreak;\n}\nif (!isIncluded(archiveEntry.getName())) {\ncontinue;\n}\nTarEntry entry = converter.convert(archiveEntry);\nentry = map(entry);\nif (entry.isDirectory()) {\npReceiver.onEachDir(entry.getName(), entry.getLinkName(), entry.getUserName(), entry.getUserId(), entry.getGroupName(), entry.getGroupId(), entry.getMode(), entry.getSize());\ncontinue;\n}\npReceiver.onEachFile(archiveInputStream, entry.getName(), entry.getLinkName(), entry.getUserName(), entry.getUserId(), entry.getGroupName(), entry.getGroupId(), entry.getMode(), entry.getSize());\n}\n} finally {\nif (archiveInputStream!= null) {\narchiveInputStream.close();\n}\n}\n}", "4930": "public void classDescriptionNeededForEntityName(NSNotification n) {\nlog.debug(\"classDescriptionNeededForEntityName: \" + (String)n.object());\nString name = (String)n.object();\nEOEntity e = EOModelGroup.defaultGroup().entityNamed(name);\nif(e == null) log.error(\"Entity \" + name + \" not found in the default model group!\");\nregisterDescriptionForEntity(e);\n}", "4932": "public void inject(Context ctx, View root, Object target) {\nlong start = System.currentTimeMillis();\nfinal Class<?> cls = target.getClass();\nList<Field> fields = listAnnotatedFields(cls);\nfor (Field field : fields) {\nfor (Annotation ann : field.getAnnotations()) {\nboolean success = inject(ctx, root, target, ann, field);\nif (!success) {\nbreak;\n}\n}\n}\nlong end = System.currentTimeMillis() - start;\nL.d(String.format(\"Injected on %s in %d ms.\", cls.getSimpleName(), end));\n}", "4935": "@Override\npublic void close() throws IOException {\nif (isNetcdfFile()) {\ncloseNetcdfFile();\n}\nsuper.close();\n}", "4940": "private void unregisterEntityManagerFactories() {\n//If we have registrations then unregister them\nif(registrations!= null) {\nfor(ServiceRegistration reg : registrations) {\ntry {\nreg.unregister();\n} catch (Exception e) {\nlogger.error(e, \"Error unregistering service factory %s\", reg.getBeanName());\n}\n}\n// remember to set registrations to be null\nregistrations = null;\n}\n}", "4942": "public void testStyle()\n{\ntypeText(\"foobar\");\nselectAllContent();\nassertXHTML(\"foobar<br>\");\napplyStyleTitle1();\nassertXHTML(\"<h1>foobar</h1>\");\napplyStyleTitle2();\nassertXHTML(\"<h2>foobar</h2>\");\napplyStyleTitle3();\nassertXHTML(\"<h3>foobar</h3>\");\napplyStyleTitle4();\nassertXHTML(\"<h4>foobar</h4>\");\napplyStyleTitle5();\nassertXHTML(\"<h5>foobar</h5>\");\napplyStyleNormal();\nassertXHTML(\"<p>foobar</p>\");\n}", "4943": "@Override\npublic void commitTask(final TaskAttemptContext taskContext) {\nLOG.info(\"Committing task.\");\n// Get temporary file.\nPath tempFilePath = getTaskAttemptPath(taskContext);\nLOG.info(\"Committing from temporary file: \" + tempFilePath.toString());\nlong filePos = 0, fileLen;\nFSDataInputStream inputStream = null;\ntry {\nFileSystem fs = FileSystem.get(taskContext.getConfiguration());\ninputStream = fs.open(tempFilePath);\nfileLen = fs.getFileStatus(tempFilePath).getLen();\n} catch (IOException e) {\nLOG.error(\"Could not open temporary file for committing\", e);\ncleanupAfterCommit(inputStream, taskContext);\nreturn;\n}\nint maxDocs = MongoConfigUtil.getBatchSize(\n          taskContext.getConfiguration());\nint curBatchSize = 0;\nDBCollection coll = getDbCollectionByRoundRobin();\nBulkWriteOperation bulkOp = coll.initializeOrderedBulkOperation();\n// Read Writables out of the temporary file.\nBSONWritable bw = new BSONWritable();\nMongoUpdateWritable muw = new MongoUpdateWritable();\nwhile (filePos < fileLen) {\ntry {\n// Determine writable type, and perform corresponding operation\n// on MongoDB.\nint mwType = inputStream.readInt();\nif (MongoWritableTypes.BSON_WRITABLE == mwType) {\nbw.readFields(inputStream);\nbulkOp.insert(new BasicDBObject(bw.getDoc().toMap()));\n} else if (MongoWritableTypes.MONGO_UPDATE_WRITABLE == mwType) {\nmuw.readFields(inputStream);\nDBObject query = new BasicDBObject(muw.getQuery().toMap());\nDBObject modifiers =\n                      new BasicDBObject(muw.getModifiers().toMap());\nif (muw.isMultiUpdate()) {\nif (muw.isUpsert()) {\nbulkOp.find(query).upsert().update(modifiers);\n} else {\nbulkOp.find(query).update(modifiers);\n}\n} else {\nif (muw.isUpsert()) {\nbulkOp.find(query).upsert().updateOne(modifiers);\n} else {\nbulkOp.find(query).updateOne(modifiers);\n}\n}\n} else {\nLOG.error(\"Unrecognized type: \" + mwType);\nbreak;\n}\nfilePos = inputStream.getPos();\n// Write to MongoDB if the batch is full, or if this is the last\n// operation to be performed for the Task.\nif (++curBatchSize >= maxDocs || filePos >= fileLen) {\ntry {\nbulkOp.execute();\n} catch (MongoException e) {\nLOG.error(\"Could not write to MongoDB\", e);\nbreak;\n}\ncoll = getDbCollectionByRoundRobin();\nbulkOp = coll.initializeOrderedBulkOperation();\ncurBatchSize = 0;\n}\n} catch (IOException e) {\nLOG.error(\"Error reading from temporary file\", e);\nbreak;\n}\n}\ncleanupAfterCommit(inputStream, taskContext);\n}", "4952": "private static Filter createFilter(BundleContext context, String applicationName)\nthrows IllegalArgumentException {\nvalidateNotNull(context, \"Context\");\nvalidateNotNull(applicationName, \"applicationName\");\nString filterString =\n            \"(&(\" + OBJECTCLASS + \"=\" + PageMounter.class.getName() + \")\"\n+ \"(\" + APPLICATION_NAME + \"=\" + applicationName + \"))\";\ntry {\nreturn context.createFilter(filterString);\n} catch (InvalidSyntaxException e) {\nthrow new IllegalArgumentException(\"Invalid filter string: \" + filterString, e);\n}\nreturn null;\n}", "4956": "public void setUp() throws Exception {\nkernel = new Kernel(\"test.kernel\", \"simple.geronimo.test\");\nkernel.boot();\nGBeanMBean gbean;\n// Create all the parts\ngbean = new GBeanMBean(\"org.apache.geronimo.security.jaas.JaasLoginService\");\nloginService = new ObjectName(\"geronimo.security:type=JaasLoginService\");\ngbean.setReferencePatterns(\"Realms\", Collections.singleton(new ObjectName(\"geronimo.security:type=SecurityRealm,*\")));\ngbean.setAttribute(\"expiredLoginScanIntervalMillis\", new Integer(50));\ngbean.setAttribute(\"maxLoginDurationMillis\", new Integer(2000));\ngbean.setAttribute(\"algorithm\", \"HmacSHA1\");\ngbean.setAttribute(\"password\", \"secret\");\nkernel.loadGBean(loginService, gbean);\ngbean = new GBeanMBean(\"org.apache.geronimo.security.remoting.jmx.JaasLoginServiceRemotingServer\");\ngbean.setAttribute(\"bindURI\", new URI(\"tcp://0.0.0.0:4242\"));\ngbean.setReferencePattern(\"loginService\", loginService);\nserverStub = new ObjectName(\"geronimo.remoting:target=JaasLoginServiceRemotingServer\");\nkernel.loadGBean(serverStub, gbean);\nkernel.startGBean(loginService);\nkernel.startGBean(serverStub);\ngbean = new GBeanMBean(ServerInfo.GBEAN_INFO);\nserverInfo = new ObjectName(\"geronimo.system:role=ServerInfo\");\ngbean.setAttribute(\"baseDirectory\", \".\");\nkernel.loadGBean(serverInfo, gbean);\nkernel.startGBean(serverInfo);\ngbean = new GBeanMBean(\"org.apache.geronimo.security.jaas.GeronimoLoginConfiguration\");\nloginConfiguration = new ObjectName(\"geronimo.security:type=LoginConfiguration\");\nSet configurations = new HashSet();\nconfigurations.add(new ObjectName(\"geronimo.security:type=SecurityRealm,*\"));\nconfigurations.add(new ObjectName(\"geronimo.security:type=ConfigurationEntry,*\"));\ngbean.setReferencePatterns(\"Configurations\", configurations);\nkernel.loadGBean(loginConfiguration, gbean);\ngbean = new GBeanMBean(\"org.apache.geronimo.security.jaas.LoginModuleGBean\");\ntestCE = new ObjectName(\"geronimo.security:type=LoginModule,name=properties\");\ngbean.setAttribute(\"loginModuleClass\", \"org.apache.geronimo.security.realm.providers.PropertiesFileLoginModule\");\ngbean.setAttribute(\"serverSide\", new Boolean(true));\nProperties props = new Properties();\nprops.put(\"usersURI\", new File(new File(\".\"), \"src/test-data/data/users.properties\").toURI().toString());\nprops.put(\"groupsURI\", new File(new File(\".\"), \"src/test-data/data/groups.properties\").toURI().toString());\ngbean.setAttribute(\"options\", props);\ngbean.setAttribute(\"loginDomainName\", \"PropertiesDomain\");\nkernel.loadGBean(testCE, gbean);\ngbean = new GBeanMBean(\"org.apache.geronimo.security.realm.GenericSecurityRealm\");\ntestRealm = new ObjectName(\"geronimo.security:type=SecurityRealm,realm=properties-realm\");\ngbean.setAttribute(\"realmName\", \"properties-realm\");\nprops = new Properties();\nprops.setProperty(\"LoginModule.1.REQUIRED\",\"geronimo.security:type=LoginModule,name=properties\");\ngbean.setAttribute(\"loginModuleConfiguration\", props);\ngbean.setReferencePatterns(\"ServerInfo\", Collections.singleton(serverInfo));\nkernel.loadGBean(testRealm, gbean);\ngbean = new GBeanMBean(\"org.apache.geronimo.security.jaas.LoginModuleGBean\");\nclientLM = new ObjectName(\"geronimo.security:type=LoginModule,name=properties-client\");\ngbean.setAttribute(\"loginModuleClass\", \"org.apache.geronimo.security.jaas.JaasLoginCoordinator\");\ngbean.setAttribute(\"serverSide\", new Boolean(false));\nprops = new Properties();\nprops.put(\"host\", \"localhost\");\nprops.put(\"port\", \"4242\");\ngbean.setAttribute", "4957": "@Override\npublic void writeObjectId(final ObjectId objectId) {\ncheckPreconditions(\"writeObjectId\", State.VALUE);\nbuffer.write(BsonType.OBJECT_ID.getValue());\nwriteCurrentName();\nbuffer.writeIntBE(objectId.time());\nbuffer.writeIntBE(objectId.machine());\nbuffer.writeIntBE(objectId.inc());\nsetState(getNextState());\n}", "4959": "@Override\npublic void updateEntry(final PersistentEntity persistentEntity, final EntityAccess ea,\n            final Object key, final DBObject entry) {\nmongoTemplate.execute(new DbCallback<Object>() {\n            public Object doInDB(DB con) throws MongoException, DataAccessException {\nString collectionName = getCollectionName(persistentEntity, entry);\nDBCollection dbCollection = con.getCollection(collectionName);\nDBObject dbo = createDBObjectWithKey(key);\nDBObject previous = null;\nif (isVersioned(ea)) {\nprevious = dbCollection.findOne(dbo);\ncheckVersion(ea, previous, persistentEntity, key);\n}\nDBObject newEntry = modifyNullsToUnsets(entry);\nMongoSession mongoSession = (MongoSession) session;\nWriteConcern writeConcern = mongoSession.getDeclaredWriteConcern(getPersistentEntity());\nif (writeConcern!= null) {\ndbCollection.update(dbo, newEntry, false, false, writeConcern);\n}\nelse {\ndbCollection.update(dbo, newEntry, false, false);\n}\nreturn null;\n}\n        });\n}", "4963": "private static String getJSON( IContext context )\n{\nreturn context.getJSON();\n}", "4965": "public static void validate(Object obj) {\ntry {\ngetMonitorId(obj);\n} catch (Exception e) {\nthrow new IllegalArgumentException(\n                \"invalid MonitorId annotation on object \" + obj, e);\n}\ntry {\ngetMonitorTags(obj);\n} catch (Exception e) {\nthrow new IllegalArgumentException(\n                \"invalid MonitorTags annotation on object \" + obj, e);\n}\ntry {\ngetMonitorAnnotations(obj);\n} catch (Exception e) {\nthrow new IllegalArgumentException(\n                \"invalid MonitorAnnotations annotation on object \" + obj, e);\n}\n}", "4967": "@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent intent)\n{\nsuper.onActivityResult(requestCode, resultCode, intent);\nif (requestCode == PICK_DECK_REQUEST)\n{\n//Clean the previous card before showing the first of the new loaded deck (so the transition is not so abrupt)\nupdateCard(\"\");\nhideSdError();\nhideDeckErrors();\ninDeckPicker = false;\nif (resultCode!= RESULT_OK)\n{\nLog.e(TAG, \"onActivityResult - Deck browser returned with error\");\n//Make sure we open the database again in onResume() if user pressed \"back\"\ndeckSelected = false;\nreturn;\n}\nif (intent == null)\n{\nLog.e(TAG, \"onActivityResult - Deck browser returned null intent\");\n//Make sure we open the database again in onResume()\ndeckSelected = false;\nreturn;\n}\n// A deck was picked. Save it in preferences and use it.\nLog.i(TAG, \"onActivityResult = OK\");\ndeckFilename = intent.getExtras().getString(OPT_DB);\nsavePreferences();\nLog.i(TAG, \"onActivityResult - deckSelected = \" + deckSelected);\ndisplayProgressDialogAndLoadDeck();\n} else if (requestCode == PREFERENCES_UPDATE)\n{\nrestorePreferences();\n//If there is no deck loaded the controls have not to be shown\nif(deckLoaded && cardsToReview)\n{\nshowOrHideControls();\nshowOrHideAnswerField();\n}\n} else if (requestCode == EDIT_CURRENT_CARD)\n{\nDeckTask.launchDeckTask(\n                                DeckTask.TASK_TYPE_UPDATE_FACT,\n                                mUpdateCardHandler,\n                                new DeckTask.TaskData(0, AnkiDroidApp.getDeck(), currentCard));\n//TODO: code to save the changes made to the current card.\nmFlipCard.setChecked(true);\ndisplayCardQuestion();\n} else if(requestCode == GET_SHARED_DECK)\n{\n//Clean the previous card before showing the first of the new loaded deck (so the transition is not so abrupt)\nupdateCard(\"\");\nhideSdError();\nhideDeckErrors();\nif (resultCode!= RESULT_OK)\n{\nLog.e(TAG, \"onActivityResult - Deck browser returned with error\");\n//Make sure we open the database again in onResume() if user pressed \"back\"\ndeckSelected = false;\nreturn;\n}\nif (intent == null)\n{\nLog.e(TAG, \"onActivityResult - Deck browser returned null intent\");\n//Make sure we open the database again in onResume()\ndeckSelected = false;\nreturn;\n}\n// A deck was picked. Save it in preferences and use it.\nLog.i(TAG, \"onActivityResult = OK\");\ndeckFilename = intent.getExtras().getString(OPT_DB);\nsavePreferences();\nLog.i(TAG, \"onActivityResult - deckSelected = \" + deckSelected);\n// Load deck and update all cards, because if that is not done both the answer and question will be empty\ndisplayProgressDialogAndLoadDeck(true);\n}\n}", "4972": "@Override\npublic void matchEnded() {\nif (threadPool.getActiveThreadCount() == 0) {\nthreadPool.stop();\n}\n}", "4976": "@Override\npublic void doJoin() throws Exception {\nsuper.doJoin();\n_call1.setState(CallState.PROCESSED);\n((SIPOutgoingCall) _call2).call(_call1.getRemoteSdp());\n}", "4978": "private void doFile(String href, String base) {\ntry {\nDataStore store = runtime.getDataStore();\nstore.readEntry(href, base, \"application/xml, text/xml, */*\", overrideContentType, new DataReader() {\n                public void load(URI id, String contentType, InputStream bodyStream, long len)\nthrows IOException {\nString charset = HttpUtils.getCharset(contentType);\nTreeWriter tree = new TreeWriter(runtime);\ntree.startDocument(id);\ntry {\nif (xmlContentType(contentType)) {\nreadBodyContentPart(tree, bodyStream, contentType, charset);\n} else {\ntree.addStartElement(XProcConstants.c_body);\ntree.addAttribute(_content_type, contentType);\nif (!xmlContentType(contentType) &&!textContentType(contentType)) {\ntree.addAttribute(_encoding, \"base64\");\n}\ntree.startContent();\nreadBodyContentPart(tree, bodyStream, contentType, charset);\ntree.addEndElement();\n}\ntree.endDocument();\nXdmNode doc = tree.getResult();\nresult.write(doc);\n} catch (SaxonApiException sae) {\nthrow new XProcException(sae);\n}\n}\n            });\n} catch (FileNotFoundException fnfe) {\nthrow new XProcException(fnfe);\n} catch (IOException ioe) {\nthrow new XProcException(ioe);\n}\n}", "4980": "public static void fail(String string) {\nassumeThat(string, nullValue());\n}", "4984": "@Override\npublic void executeTask(Intent intent) {\nlog(\"checking scheduled message result services\");\nmFileManager.appendAndClose(getString(R.string.check_scheduled_message_result_services));\nmProcessMessageResult.processMessageResult();\n}", "4985": "public void renderBook( BookContext context )\nthrows BookDoxiaException\n{\nBookModel book = context.getBook();\nif (!context.getOutputDirectory().exists() )\n{\nif (!context.getOutputDirectory().mkdirs() )\n{\nthrow new BookDoxiaException( \"Could not make directory: \"\n+ context.getOutputDirectory().getAbsolutePath() + \".\" );\n}\n}\nFile bookFile = new File( context.getOutputDirectory(), book.getId() + \".xhtml\" );\nWriter fileWriter;\ntry\n        {\nfileWriter = new FileWriter( bookFile );\n}\ncatch ( IOException e )\n{\nthrow new BookDoxiaException( \"Error while opening file.\", e );\n}\nXhtmlBookSink sink = new XhtmlBookSink( fileWriter,\n              new RenderingContext( context.getOutputDirectory(), bookFile.getAbsolutePath() ) );\ntry\n        {\nsink.bookHead();\nsink.text( \"Book \" + book.getTitle() );\nsink.bookHead_();\nsink.bookBody();\nint chapterNumber = 1;\nfor ( Iterator it = book.getChapters().iterator(); it.hasNext(); )\n{\nChapter chapter = (Chapter) it.next();\nsink.sectionTitle();\nsink.text( Integer.toString( chapterNumber ) + \". \" + chapter.getTitle() );\nsink.sectionTitle_();\nrenderChapter( sink, chapter, context );\nchapterNumber++;\n}\nsink.bookBody_();\n}\nfinally\n        {\nsink.flush();\nsink.close();\nIOUtil.close( fileWriter );\n}\n}", "4987": "private void compareEntries( Entry originalEntry, Entry destinationEntry, LdifEntry modificationEntry )\n{\n// Creating a list to store the already evaluated attribute type\nList<AttributeType> evaluatedATs = new ArrayList<AttributeType>();\n// Checking attributes of the original entry\nfor ( Attribute originalAttribute : originalEntry )\n{\nAttributeType originalAttributeType = originalAttribute.getAttributeType();\n// We're only working on 'userApplications' attributes\nif ( originalAttributeType.getUsage() == UsageEnum.USER_APPLICATIONS )\n{\nAttribute destinationAttribute = destinationEntry.get( originalAttributeType );\nif ( destinationAttribute == null )\n{\n// Creating a modification for the removed AT\nModification modification = new DefaultModification();\nmodification.setOperation( ModificationOperation.REMOVE_ATTRIBUTE );\nmodification.setAttribute( new DefaultAttribute( originalAttribute.getAttributeType() ) );\nmodificationEntry.addModification( modification );\n}\nelse\n                {\n// Comparing both attributes\ncompareAttributes( originalAttribute, destinationAttribute, modificationEntry );\n}\nevaluatedATs.add( originalAttributeType );\n}\n}\n// Checking attributes of the destination entry\nfor ( Attribute destinationAttribute : destinationEntry )\n{\nAttributeType destinationAttributeType = destinationAttribute.getAttributeType();\n// We're only working on 'userApplications' attributes\nif ( destinationAttributeType.getUsage() == UsageEnum.USER_APPLICATIONS )\n{\n// Checking if the current AT has already been evaluated\nif (!evaluatedATs.contains( destinationAttributeType ) )\n{\n// Creating a modification for the added AT\nModification modification = new DefaultModification();\nmodification.setOperation( ModificationOperation.ADD_ATTRIBUTE );\nAttribute attribute = new DefaultAttribute( destinationAttributeType );\nmodification.setAttribute( attribute );\nfor ( Value<?> value : destinationAttribute )\n{\ntry\n                        {\nattribute.add( value );\n}\ncatch ( LdapInvalidAttributeValueException liave )\n{\nthrow new LdapException( \"Failed to add an attribute to the destination entry.\", liave );\n}\n}\nmodificationEntry.addModification( modification );\n}\n}\n}\n}", "4988": "@Override\npublic void onUpdate(World world, int x, int y, int z) {\nif (!VanillaConfiguration.CACTUS_PHYSICS.getBoolean()) {\nreturn;\n}\nboolean destroy = false;\nBlockMaterial below = world.getBlockMaterial(x, y - 1, z);\nif (!below.equals(VanillaMaterials.SAND) &&!below.equals(VanillaMaterials.CACTUS)) {\ndestroy = true;\n}\nif (!destroy) {\nBlockFace faces[] = {BlockFace.NORTH, BlockFace.SOUTH, BlockFace.EAST, BlockFace.WEST};\nfor (BlockFace face : faces) {\nint tx = (int) (x + face.getOffset().getX());\nint tz = (int) (z + face.getOffset().getZ());\nBlockMaterial side = world.getBlockMaterial(tx, y, tz);\nif (!side.equals(VanillaMaterials.AIR)) {\ndestroy = true;\nbreak;\n}\n}\n}\nif (destroy) {\nworld.setBlockMaterial(x, y, z, VanillaMaterials.AIR, (short) 0, true, world);\nfor (ItemStack item : world.getItems(x, y, z)) {\nworld.removeItem(x, y, z, item);\n}\n}\n}", "4998": "@EventHandler(\"saveButton\")\npublic void onSaveButtonClicked(ClickEvent event) {\nTypedQuery<Department> deptQuery = em.createNamedQuery(\"departmentByName\", Department.class);\ndeptQuery.setParameter(\"name\", department.getText());\nDepartment resolvedDepartment;\nList<Department> resultList = deptQuery.getResultList();\nif (resultList.isEmpty()) {\nresolvedDepartment = new Department();\nresolvedDepartment.setName(department.getText());\n}\nelse {\nresolvedDepartment = resultList.get(0);\n}\nitemBinder.getModel().setDepartment(resolvedDepartment);\nUser fakeUser = new User();\nfakeUser.setName(\"me\");\nitemBinder.getModel().setAddedBy(fakeUser);\nitemBinder.getModel().setAddedOn(new Date());\nem.persist(itemBinder.getModel());\nem.flush();\nif (afterSaveAction!= null) {\nafterSaveAction.run();\n}\n}", "5001": "public void sendMessage(I destVertex, M msg) {\nLOG.info(\"Send bytes (\" + msg.toString() + \") to \" + destVertex);\n// TODO: implement getPartition\n//Partition<I> destPartition = service.getPartition(destVertex);\nPartition<I> destPartition = new Partition<I>(localHostname,\n                       Integer.parseInt(getName().split(\":\")[1]), null);\nInetSocketAddress addr = new InetSocketAddress(\n    \t\t                                 destPartition.getHostname(),\n    \t\t                                 destPartition.getPort());\nHashMap<I, ArrayList<M>> msgMap = outMessages.get(addr);\nif (msgMap == null) { // should never happen after constructor\nmsgMap = new HashMap<I, ArrayList<M>>();\noutMessages.put(addr, msgMap);\n}\nArrayList<M> msgList = msgMap.get(destVertex);\nif (msgList == null) {\nmsgList = new ArrayList<M>();\nmsgMap.put(destVertex, msgList);\n}\nsynchronized(msgList) {\nmsgList.add(msg);\nLOG.info(\"added msg, size=\" + msgList.size());\n}\nsynchronized (waitingOn) {\nwaitingOn.notify();\n}\n}", "5004": "@Test\npublic void testConfigRoundTrip() throws Exception {\nPatchsetCreated event = Setup.createPatchsetCreated(PluginImpl.DEFAULT_SERVER_NAME);\nWorkflowJob job = createWorkflowJob(event);\njenkinsRule.configRoundtrip(job);\njob = (WorkflowJob)jenkinsRule.jenkins.getItem(\"WFJob\");\nGerritTrigger trigger = GerritTrigger.getTrigger(job);\nassertFalse(trigger.isSilentMode());\nassertEquals(1, trigger.getGerritBuildSuccessfulCodeReviewValue().intValue());\nassertEquals(1, trigger.getGerritBuildSuccessfulVerifiedValue().intValue());\nassertEquals(0, trigger.getGerritBuildFailedCodeReviewValue().intValue());\nassertThat(trigger.getGerritProjects(), hasItem(\n                allOf(\n                    isA(GerritProject.class),\n                    hasProperty(\"compareType\", is(CompareType.PLAIN)),\n                    hasProperty(\"pattern\", equalTo(event.getChange().getProject()))\n                )\n        ));\n}", "5008": "private static boolean isRecursive(NameID root, Type type) {\nif (type.isRecursive()) {\nreturn true;\n}\nfor (Type child : type.getChildren()) {\nif (isRecursive(root.append(\".\"), child)) {\nreturn true;\n}\n}\nreturn false;\n}", "5010": "private void setup(Manifest appManifest)\n{\nMap<String, String> appMap = readManifestIntoMap(appManifest);\n// configure the appSymbolicName and appVersion\nthis.appSymbolicName = appMap.get(AppConstants.APPLICATION_SYMBOLIC_NAME);\nthis.appVersion = new Version(appMap.get(AppConstants.APPLICATION_VERSION));\nthis.appName = appMap.get(AppConstants.APPLICATION_NAME);\nthis.appScope = this.appSymbolicName + \"_\" + this.appVersion.toString();\nif (this.appSymbolicName == null || this.appVersion == null) {\nthrow new IllegalArgumentException(\"Failed to create ApplicationMetadataImpl object from Manifest \" + appManifest);\n}\n// configure appContents\nString applicationContents = appMap.get(AppConstants.APPLICATION_CONTENT);\nList<String> appContentsArray = ManifestProcessor.split(applicationContents, \",\");\nfor (String content : appContentsArray) {\nthis.appContents.add(new ContentImpl(content));\n}\n// configure importServices and exportServices\nList<ServiceMetadata> importServices = readImportServices(appMap.get(AppConstants.IMPORT_SERVICES));\nList<ServiceMetadata> exportServices = readExportServices(appMap.get(AppConstants.EXPORT_SERVICES));\nfor (ServiceMetadata service : importServices) {\nthis.importServices.add(service);\n}\nfor (ServiceMetadata service : exportServices) {\nthis.exportServices.add(service);\n}\n}", "5011": "public void init(FilterConfig filterConfig) {\nthis.requestMappers = new ArrayList();\nthis.requestMappers.add(new WeblogRequestMapper());\n}", "5016": "public void infer(int index, Code.Debug code, Block.Entry entry,\n\t\t\tEnv environment) {\nenvironment.push(Type.T_LIST(Type.T_INT));\n}", "5017": "@Test\npublic void testMergeCatalogItemMetadataHref() {\nVCloudDirectorApi api = requestsSendResponses(loginRequest, sessionResponse, mergeItemMetadata, mergeItemMetadataResponse);\nMetadata metadata = Metadata.builder().entry(MetadataEntry.builder().entry(\"KEY\", \"VALUE\").build()).build();\nassertEquals(api.getCatalogApi().getItemMetadataApi(itemHref).merge(metadata), mergeMetadataTask());\n}", "5020": "public void decorate( Object element, IDecoration decoration )\n{\nSchemaChecker schemaChecker = Activator.getDefault().getSchemaChecker();\nif ( element instanceof AttributeTypeWrapper )\n{\nAttributeTypeImpl at = ( ( AttributeTypeWrapper ) element ).getAttributeType();\nif ( schemaChecker.hasErrors( at ) )\n{\ndecoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                    PluginConstants.IMG_OVERLAY_ERROR ), IDecoration.BOTTOM_LEFT );\nreturn;\n}\nif ( schemaChecker.hasWarnings( at ) )\n{\ndecoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                    PluginConstants.IMG_OVERLAY_WARNING ), IDecoration.BOTTOM_LEFT );\n}\n}\nelse if ( element instanceof ObjectClassWrapper )\n{\nObjectClassImpl oc = ( ( ObjectClassWrapper ) element ).getObjectClass();\nif ( schemaChecker.hasErrors( oc ) )\n{\ndecoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                    PluginConstants.IMG_OVERLAY_ERROR ), IDecoration.BOTTOM_LEFT );\nreturn;\n}\nif ( schemaChecker.hasWarnings( oc ) )\n{\ndecoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                    PluginConstants.IMG_OVERLAY_WARNING ), IDecoration.BOTTOM_LEFT );\n}\n}\nelse if ( element instanceof SchemaWrapper )\n{\nSchema schema = ( ( SchemaWrapper ) element ).getSchema();\nfor ( AttributeTypeImpl at : schema.getAttributeTypes() )\n{\nif ( schemaChecker.hasErrors( at ) )\n{\ndecoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                        PluginConstants.IMG_OVERLAY_ERROR ), IDecoration.BOTTOM_LEFT );\nreturn;\n}\nif ( schemaChecker.hasWarnings( at ) )\n{\ndecoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                        PluginConstants.IMG_OVERLAY_WARNING ), IDecoration.BOTTOM_LEFT );\n}\n}\nfor ( ObjectClassImpl oc : schema.getObjectClasses() )\n{\nif ( schemaChecker.hasErrors( oc ) )\n{\ndecoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                        PluginConstants.IMG_OVERLAY_ERROR ), IDecoration.BOTTOM_LEFT );\nreturn;\n}\nif ( schemaChecker.hasWarnings( oc ) )\n{\ndecoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                        PluginConstants.IMG_OVERLAY_WARNING ), IDecoration.BOTTOM_LEFT );\n}\n}\n}\nelse if ( element instanceof Folder )\n{\nFolder folder = ( Folder ) element;\nSchema schema = ( ( SchemaWrapper ) folder.getParent() ).getSchema();\nif ( folder.getType().equals( FolderType.ATTRIBUTE_TYPE ) )\n{\nfor ( AttributeTypeImpl at : schema.getAttributeTypes() )\n{\nif ( schemaChecker.hasErrors( at ) )\n{\ndecoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                            PluginConstants.IMG_OVERLAY_ERROR ), IDecoration.BOTTOM_LEFT );\nreturn;\n//                    }\n//\n//                    if ( schemaChecker.hasWarnings( at ) )\n//                    {\n//                        decoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                            PluginConstants.IMG_OVERLAY_WARNING ), IDecoration.BOTTOM_LEFT );\n//                    }\n//                }\n//            }\n//            else if ( folder.getType().equals( FolderType.OBJECT_CLASS ) )\n//            {\nfor ( ObjectClassImpl oc : schema.getObjectClasses() )\n//            {\nif ( schemaChecker.hasErrors( oc ) )\n{\ndecoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activator.PLUGIN_ID,\n                            PluginConstants.IMG_OVERLAY_ERROR ), IDecoration.BOTTOM_LEFT );\nreturn;\n//                    }\n//\n//                    if ( schemaChecker.hasWarnings( oc ) )\n//                    {\n//                        decoration.addOverlay( AbstractUIPlugin.imageDescriptorFromPlugin( Activ", "5021": "public void index(final Object value, final Long primaryKey) {\nif(value!= null) {\ntemplate.sadd(createRedisKey(value), primaryKey);\n// for numbers and dates we also create a list index in order to support range queries\nif(value instanceof Number) {\nString propSortKey = entityPersister.getPropertySortKey(property);\nNumber n = (Number) value;\ntemplate.zadd(propSortKey,n.doubleValue(),primaryKey);\n// delete any cached indices\nfinal String[] toDelete = template.keys(propSortKey + \"~*\");\nif(toDelete!= null && toDelete.length>0)\ntemplate.del(toDelete);\n}\nelse if(value instanceof Date) {\nString propSortKey = entityPersister.getPropertySortKey(property);\nDate d = (Date) value;\ntemplate.zadd(propSortKey, d.getTime(),primaryKey);\n}\n}\n}", "5022": "@SuppressWarnings({\"unchecked\"})\npublic void start() throws IOException {\nfinal int bindCount = bindAddresses.length;\nfinal MulticastSocket[] sockets = new MulticastSocket[bindCount];\nboolean ok = false;\ntry {\nchannels = new BioMulticastChannelImpl[bindCount];\nfor (int i = 0; i < bindCount; i++) {\nMulticastSocket socket = new MulticastSocket(bindAddresses[i]);\nsocket.setBroadcast(broadcast);\nif (receiveBufferSize!= -1) socket.setReceiveBufferSize(receiveBufferSize);\nsocket.setReuseAddress(reuseAddress);\nif (sendBufferSize!= -1) socket.setSendBufferSize(sendBufferSize);\nif (trafficClass!= -1) socket.setTrafficClass(trafficClass);\nsockets[i] = socket;\nchannels[i] = new BioMulticastChannelImpl(sendBufferSize, receiveBufferSize, executor, handlerFactory.createHandler(), socket);\n}\nok = true;\n} finally {\nif (! ok) {\nfor (MulticastSocket socket : sockets) {\nif (socket!= null) try {\nsocket.close();\n} catch (Throwable t) {\nlogger.trace(t, \"Failed to close socket for address %s\", bindAddresses[i]);\n}\n}\n}\n}\n}", "5023": "public void decode(int[] received, int numECCodewords) throws ChecksumException {\nModulusPoly poly = new ModulusPoly(field, received);\nint[] syndromeCoefficients = new int[numECCodewords];\nboolean noError = true;\nfor (int i = 0; i < numECCodewords; i++) {\nint eval = poly.evaluateAt(field.exp(i + 1));\nsyndromeCoefficients[syndromeCoefficients.length - 1 - i] = eval;\nif (eval!= 0) {\nnoError = false;\n}\n}\nif (!noError) {\nthrow ChecksumException.getChecksumInstance();\n}\nfor (int i = 0; i < syndromeCoefficients.length; i++) {\nint eval = syndromeCoefficients[i];\nif (eval!= 0) {\nthrow new ChecksumException(\"Bad coefficient \" + i + \" at \" + poly.getField().exp(i + 1));\n}\n}\n}", "5026": "public void useItemOnBlock(EntityRef item, EntityRef user, Vector3i targetBlock, Side surfaceDirection, Side secondaryDirection) {\nif (item == null) return;\nItemComponent itemComp = item.getComponent(ItemComponent.class);\nif (itemComp == null) return;\nPlaceableBlockComponent placeableBlock = item.getComponent(PlaceableBlockComponent.class);\nif (placeableBlock!= null) {\nif (placeBlock(placeableBlock.blockGroup, targetBlock, surfaceDirection, secondaryDirection)) {\nitemComp.stackCount--;\nif (itemComp.stackCount == 0) {\nitem.destroy();\n}\n}\n}\nItemComponent normalItemComp = item.getComponent(ItemComponent.class);\nif (normalItemComp!= null) {\nnormalItemComp.stackCount--;\nif (normalItemComp.stackCount == 0) {\nitem.destroy();\n}\n}\n}", "5030": "@Override\npublic void updateProgress(Event event) {\nif (event instanceof PlayerMoveEvent) {\nPlayerMoveEvent ev = (PlayerMoveEvent) event;\nif (traveled >= distance) {\ncompleted = true;\nsuper.updateProgress(event);\n}\n}\n}", "5031": "@Test\npublic void testActiveE2ECloseSimple() throws InterruptedException,\n      IOException, FlumeSpecException {\nfinal String lnode = \"e2eSimple\";\nfinal FlumeMaster master = new FlumeMaster(cfg);\nMasterRPC rpc = new DirectMasterRPC(master);\nfinal FlumeNode node = new FlumeNode(rpc, false, false);\n// should have nothing.\nassertEquals(0, node.getLogicalNodeManager().getNodes().size());\nLivenessManager liveMan = node.getLivenessManager();\n// update config node to something that will be interrupted.\nLOG.info(\"setting to invalid e2e host\");\nmaster.getSpecMan().setConfig(lnode, \"flow\", \"asciisynth(0)\",\n        \"agentE2ESink(\\\"localhost\\\", 12347)\");\nmaster.getSpecMan().addLogicalNode(NetUtils.localhost(), lnode);\nliveMan.heartbeatChecks();\nLogicalNode n = node.getLogicalNodeManager().get(lnode);\nDriver d = n.getDriver();\nassertTrue(\"Attempting to start driver timed out\",\n        d.waitForAtLeastState(DriverState.ACTIVE, 10000));\n// update config node to something that will be interrupted.\nLOG.info(\"!!! decommissioning node on master\");\nmaster.getSpecMan().removeLogicalNode(lnode);\nliveMan.heartbeatChecks();\nassertTrue(\"Attempting to stop driver timed out\",\n        d.waitForAtLeastState(DriverState.ERROR, 15000));\n}", "5032": "public static void main(String[] args) {\nDemoUtil.setUp();\ntry {\ntestGetCustomFieldSetsByType();\ntestGetCentresByPage();\ntestGetCentre();\ntestGetCurrency();\ntestGetAllBranches();\ntestGetCentresByBranch();\ntestGetBranchesByPage();\ntestGetBranch();\n} catch (MambuApiException e) {\nSystem.out.println(\"Exception caught in Demo Test Organization Service\");\nSystem.out.println(\"Exception Error code=\" + e.getErrorCode());\nSystem.out.println(\" Cause=\" + e.getCause() + \".  Message=\" + e.getMessage());\n}\n}", "5034": "@SuppressWarnings(\"unchecked\")\npublic static Matcher<PrintableResult> hasFailureContaining(final String string) {\nreturn new BaseMatcher<PrintableResult>() {\n\t\t\tpublic boolean matches(Object item) {\nreturn item.toString().contains(string);\n}\npublic void describeTo(Description description) {\ndescription.appendText(\"has single failure containing \" + string);\n}\n\t\t};\n}", "5035": "@Override\nprotected void processRequest(javax.servlet.http.HttpServletRequest request,\n\t\t\tjavax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException,\n\t\t\tjava.io.IOException {\nRpcRequest reqType = RpcRequest.fromName(request.getParameter(\"req\"));\nlogger.info(MessageFormat.format(\"Rpc {0} request from {1}\", reqType,\n\t\t\t\trequest.getRemoteAddr()));\nif (!GitBlit.getBoolean(Keys.web.enableRpcServlet, false)) {\nlogger.warn(Keys.web.enableRpcServlet + \" must be set TRUE for rpc requests.\");\nresponse.sendError(HttpServletResponse.SC_FORBIDDEN);\nreturn;\n}\nUserModel user = null;\nObject result = null;\nif (RpcRequest.LIST_REPOSITORIES.equals(reqType)) {\n// list repositories\n// Determine the Gitblit clone url\nString gitblitUrl = HttpUtils.getGitblitURL(request);\nStringBuilder sb = new StringBuilder();\nsb.append(gitblitUrl);\nsb.append(Constants.GIT_PATH);\nsb.append(\"{0}\");\nString cloneUrl = sb.toString();\nList<RepositoryModel> list = GitBlit.self().getRepositoryModels(user);\nMap<String, RepositoryModel> repositories = new HashMap<String, RepositoryModel>();\nfor (RepositoryModel model : list) {\nString url = MessageFormat.format(cloneUrl, model.name);\nrepositories.put(url, model);\n}\nresult = repositories;\n} else if (RpcRequest.LIST_USERS.equals(reqType)) {\n// list users\nif (user == null ||!user.canAdmin) {\nresponse.sendError(HttpServletResponse.SC_FORBIDDEN);\nreturn;\n}\n// user is authorized to retrieve all accounts\nList<String> names = GitBlit.self().getAllUsernames();\nList<UserModel> users = new ArrayList<UserModel>();\nfor (String name : names) {\nusers.add(GitBlit.self().getUserModel(name));\n}\nresult = users;\n}\n// send the result of the request\nserialize(response, result);\n}", "5038": "@Test\npublic void testTabInTableConfigDialog()\n{\nTableConfigPane tableConfig = this.editPage.insertTable();\n// Assert that the row count input has the focus.\nAssert.assertEquals(tableConfig.getRowCountInput(), getDriver().switchTo().activeElement());\ngetDriver().switchTo().defaultContent();\n// Press Tab to move the focus to the next input.\ntableConfig.getRowCountInput().sendKeys(Keys.TAB);\n// Assert that the column count input has the focus.\nAssert.assertEquals(tableConfig.getColumnCountInput(), getDriver().switchTo().activeElement());\ngetDriver().switchTo().defaultContent();\n}"}